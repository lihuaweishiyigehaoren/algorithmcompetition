### 4-1 动态规划法

在基础部分，我们介绍了动态规划法的两个重点和实现动态规划法的四个步骤

在第 4 部分动态规划中，我们将介绍一系列动态规划类的算法例子，这些例子覆盖**一维动态规划、串模型的动态规划、区间模型动态规划以及状态压缩类型的动态规划**，但是在开始之前，先通过几个简单的例子，帮助大家进一步理解动态规划。

#### 如何理解动态规划

动态规划法中有几个概念比较抽象，一个是重叠子问题，一个是最优子结构，还有一个是子问题的无后向性（无后效性）。

这几个概念不是独立的，它们之间是相互联系的，首先说说重叠子问题。千万不要望文生义，这里重叠的意思不是子问题之间互相有重叠的部分，是指一个问题的子问题可以被重复使用，每个决策阶段的子问题的状态（子问题的解），可由其他已经决策过的子问题（已经求解过的子问题）的状态通过某种关系决策（堆叠）后得到，而不是必须引入新的子问题才能解决。

一旦某个阶段的子问题的状态需要引入新的子问题而不是用已经决策过的，并且是确定了状态的子问题才能解决，说明子问题不满足无后向性。所谓的无后向性，是指子问题在某个阶段的状态一旦确定，其后续的状态变迁都是一样的，不会因为之前到达这个状态的路径或方式不同而变化。

怎么理解呢，举个例子，假如子问题在某个阶段的状态确定后，其后续经过若干个决策阶段后可以得到一个最优解，那么不管之前通过何种决策路经，只要在搜索过程中达到这个公共状态，就可以得到最优解，这个结果不会再改变，因此可以记录下来，其他阶段的决策可以直接用状态值表达，不需要再重复计算其后续各个阶段的子问题的状态值。一个问题的最优解可以从其子问题的最优解中得到，那么我们称这个问题具有最优子结构。最优子结构并不是动态规划法独有的要求，很多求解最优化问题的算法都要求子问题的划分满足最优子结构的要求。

用动态规划法设计算法的关键是找出子问题和子问题状态的定义。子问题的状态就是子问题的最优解，当子问题的规模是最终的问题的时候，那么其对应的状态就是问题的最优解。

基于这一思想，通常选择把问题的规模作为状态变量的方式定义子问题。以取硬币问题为例，其问题是取 N 元硬币需要的最小硬币数量。

于是我们就选择“取 i（0 ≤ i ≤ N）元硬币需要的最小硬币数量”作为子问题，并定义状态 d[i] 为取 i 元硬币需要的最小硬币数量。

本课介绍的字符串编辑距离问题，问题的规模有两个，一个是源字符串长度 n，另一个是目标字符串长度 m，于是我们可以选择“长度为 i 的源字符串和长度为 j 的目标字符串的最小编辑距离”作为子问题，并定义状态 d[i,j] 为子问题的解（最小编辑距离）。最终，d[n,m] 就是原始问题的解。

如果大家在尝试用动态规划法设计算法时感到无从下手，不妨尝试一下这种从**问题的规模入手**的方法。

关于子问题以及子问题在某个决策阶段的维度，也是可以用来综合考虑子问题分解的参考方向。比如 0-1 背包问题，第一次接触这个问题很容易将其决策状态理解为装入第 i 个物品时包中物品的总价值，于是将子问题定义为装入第 i 个物品。

实际上这样是不对的，**因为空包的情况下选择第 i 个物品和包中已经装了几个物品后再选择第 i 个物品所产生的状态是不一样的，也就是说对于状态 d[i]，用不同的选择物品的顺序得到的 d[i] 值是不一样的，这就不能满足子问题的无后向性**。之所以出现错误，是因为一个重要的信息没有考虑，那就是选择物品 i 时包的剩余容量，因此子问题的状态应该增加一个维度，即定义状态 d[i,j] 为将第 i 个物品装入剩余容量为 j 的包中所得到的物品价值，对应的子问题就是将第 i 个物品装入剩余容量为 j 的包中。这样增加一个维度，子问题的定义就能满足无后向性。

一个问题经过多个阶段的决策可以得到最优解，这一系列的状态变化可以视为一个决策序列。动态规划的每个阶段的决策，并不要求之前阶段的状态必须是最优的，它只是保证现阶段的决策采用最优的策略，尽力而为得到当前阶段的“最优解”。在动态规划法的状态表中，并不是每个状态都是最优的，但是它把所有的状态都计算了一遍，根据最优子结构的性质，总有一个决策序列最终能得到全局的最优解。所以，动态规划本质上依然是搜索，它会把所有的决策序列都搜索一遍，尽管绝大多数决策序列都不会得到最优解。动态规划的高效体现在对于每个决策阶段的子问题的状态只计算一次，存储结果，当需要再次使用这个子问题时，直接查表，不需要再次求解，不需要再次求解的原因正是因为子问题的无后向性。也正因为如此，动态规划法对那些每个决策阶段都会产生指数级重复子问题的问题特别有效。关于这一点，Kleigberg 在《算法导论》这本书中，对动态规划有如下描述：

> 动态规划法通过将问题细分为一系列子问题，从而隐含地探查了所有可行解的空间，于是我们可以从某种程度上把动态规划看作接近暴力搜索边缘的危险操作。动态规划对子问题的处理方式，使得它可以遍历问题可行解的指数规模的集合，甚至可以在没有明确检查所有解的情况下做到这一点。这是一种对重叠子问题（子问题包含子子问题）处理的内在机制。

理解了这段话的意思，也就能理解动态规划法的实质，即动态规划就是利用子问题的“无后向性”特点，通过递推关系隐含地实现了所有子问题序列的求解，其内在机制也避免了同类子问题的重复求解。如果问题不是线性的，那么即使是动态规划法，也会呈现出类似穷举的广域搜索的效果，即便是没有出现最优解的子问题序列也会被求解。

#### 上楼梯问题

为了更好地理解动态规划法，这里用一个实际的算法例子，从盲目穷举法开始，逐渐过渡到动态规划法。大家可以从这个过程中，理解 Kleigberg 这段话的意思，理解动态规划法。

《算法的乐趣》一书中用了一个“字符串的编辑距离问题”作为例子，但因为问题本身有一定的难度，读者反馈不容易理解。这里我们从《国际大学生程序设计竞赛例题集》这本书中找了一个简单的“上楼梯问题”作为例子，这个问题也是一个非常常见的面试题。

#### 问题提出

小明上楼梯有个习惯，就是一次要么走 1 级台阶，要么走 2 级台阶，有一个楼梯有 20 级台阶，问按照小明的习惯，他有多少种上楼梯的方法。

分析这个问题，我们先试试减小问题的规模。假设楼梯只有 1 级台阶，那么只有一种上楼的方法。假设楼梯有 2 级台阶，那么小明会有 2 种上楼的方法，一种是一次走 1 级台阶，需要走 2 次才能上楼，另一种是一次走 2 级台阶，走 1 次就能上楼。再进一步，假设楼梯有 3 级台阶，此时小明会想，如果我选择先走 1 级台阶，那么楼梯还剩 2 级台阶，对于 2 级台阶的楼梯，此前已经知道有 2 种上楼方法。那么反过来，如果我选择先走 2 级台阶，那么楼梯还剩 1 级台阶，对于 1 级台阶的楼梯，此前也知道只有 1 种上楼的方法。所以，小明分别做这两个选择以后，共有 3 种上楼梯的方法。

楼梯有更多的台阶时怎么办呢？

#### 分治法 + 穷举法

实际上，上一节对 3 级台阶的分析，已经隐含了一个很重要的思想，就是分治法。

对于有 n 个台阶的楼梯，解决的方法就是先选择走 1 级台阶，将剩下的 n-1 级台阶作为子问题求解，然后再选择走 2 级台阶，将剩下的 n-2 级台阶作为子问题求解，两个选择的上楼方法求和，就是 n 个台阶的上楼方法。

对于上楼梯问题 f(n)，可以分解为 f(n-1) 和 f(n-2) 两个子问题，两个子问题的和就是 f(n) 的解：

f(n) = f(n-1) + f(n-2)

实际上，除了分治法，这里面还隐含了穷举法，尽管只是对两种选择的穷举（走 1 级台阶，还是走 2 级台阶），但那也是穷举。

用分治法就会用到递归算法实现，递归算法实现的重点就是递归主体和递归退出条件。很显然，这个问题的递归主体就是上面求 f(n) 的关系式，递归退出条件就是当问题的规模减小到 1 或 2 级台阶的时候，直接返回对应的上楼梯方法。

用分治法解决这个问题的算法实现如下：

```c++
int f(int n)
{
    if(n == 1)//递归退出条件
    {
        return 1;
    }
    else if(n==2) // 递归退出条件
    {
        return 2;
	}
    else //递归主体
    {
        return f(n-1)+f(n-2);
    }
}
```

用分治法结合递归实现的算法代码总是优雅、简单，但是也存在效率低下的问题。

在前面的基础部分介绍过，分治法效率不高的原因在于子问题的重复求解，这种重复求解造成大量不必要的开销。

图（1）展示了当台阶数 n=5 的时候，按照上述分治法分治与求解子问题的过程，可以看到，3 级台阶对应的子问题被求解了 2 次，2 个台阶的子问题被求解了 3 次。随着问题规模（台阶数） n 的增加，重复出现的子问题会更多，重复计算的开销也越大。

![QQ截图20190610180535](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190610180535.png)

#### 动态规划—带备忘录的穷举 + 分治

分治法对子问题的分解方法，不考虑无后向性，因此很多情况下都不适用于动态规划法，但是这个问题例外，我们用楼梯台阶数定义的子问题，适用于动态规划法。

**我们看图（1）中两次出现的 f(3) 状态，其后续的状态演化都是一样的，结果也是一样的，这说明什么问题？**

这说明这个子问题的分解满足无后向性要求，无论之前是通过何种子问题分解途径来到了 f(3) 这个状态（f(3) 对应子问题的解），其结果是固定的，不会因为是从 f(5) 演化过来的 f(3)，就和从 f(4) 演化过来的 f(3) 不一样。

既然子问题满足无后向性要求，那么我们就来解决子问题的重复求解问题。

解决子问题重复计算的方法就是**设置一个“状态备忘录”**，这个备忘录记录每个子问题的状态（对应子问题的解）。因为子问题的解都是大于 0 的整数，所以我们用 -1 表示这个备忘录条目是无效的，也就是这个子问题还没有被求解过。

```c++
int memo[N];
for(int i = 0; i < N; i++)
{
    memo[i] = -1;
}
```

确定好状态备忘录，还要确定边界状态，也就是子问题 f(1) 和 f(2) 的状态是已知的，直接记录到备忘录中即可：

```c++
memo[1] = 1;
memo[2] = 2;
```

有读者会问，memo[0] 好像没用到？是的，memo[0] 不用，放在那里就好了，这样就可以使 memo[1] 与子问题 f(1) 对应，memo[2] 与子问题 f(2) 对应，以此类推，这也是一种常用的技巧吧。接下来就是改造我们的算法，把备忘录的处理加上：

```c++
int f(int n)
{
    if(memo[n] != -1)
    {
        return memo[n];
    }
    
    // 求解子问题，别忘了更新备忘录
    memo[n] = f(n-1) + f(n-2);
    return memo[n];
}
```

动态规划是一种思想，千万不要形而上学地以为动态规划就是子问题的递推关系式。对于多阶段决策的优化问题，只要阶段划分明确，子问题定义清晰且满足无后效性，不管算法实现用何种形式，它都是动态规划。

#### 动态规划—递推关系式

上一节的例子使用备忘录避免子问题重复求解，这是一种显式的剪枝方法。

我们之前提到过动态规划法内在的剪枝机制，实际上是通过直接搜索递推关系式的方式实现的，也就是大家眼中“正统”的动态规划法。

这一节我们直接给出状态递推关系方式的动态规划算法，用这种方法设计算法实现，需要解决三个问题，首先是子问题状态的定义，这个在上一节已经分析过了；

其次是确定递推关系式，递推关系前面也介绍过，假设我们定义子问题的状态是 f[n]，则状态递推关系式就是：

f[n] = f[n - 1] + f[n - 2]

最后是确定边界条件，边界条件就是：

```c++
f[1] = 1   
f[2] = 2
```

最后，典型的用递推关系式实现的动态规划法算法实现如下：

```c++
int dp(int n)
{
    int f[N] = {0};
    
    // 初始化边界值
    f[1] = 1;
    f[2] = 2;
    // 递推求解f[n]
    for(int i = 2;i<=n;i++)
    {
        f[i] = f[i-1] + f[i-2];
    }
    
    return f[n];
}
```

这是一个简单的例子，演示了子问题定义和对子问题无后向性的理解，通过带备忘录的分治法 + 穷举法实现，是大家对动态规划有一个较深入的理解。

读者看到这里，应该理解，凡是对多阶段决策问题有明确的子问题和状态定义，且子问题满足无后向性条件，并能够通过优化解决子问题的重复求解效率问题的方法，都是动态规划法，希望大家对动态规划有更全面的认识

#### 状态递推关系常用的模式

对付动态规划类问题的，首先要做的是识别子问题以及子问题的状态递推关系式。

说直白一点，就是先用分治法的思想看看能不能分解子问题，如果一种方法分解出的子问题不满足无后向性，就换一种方法。

无论读者之前看过多少动态规划的资料，对动态规划的基本原理讲的再头头是道，如果遇到问题不能识别子问题以及子问题的状态定义，也是无用的。

好在动态规划虽然飘逸，但还是有规律可循，前人还是总结了好几种常见的递推关系模式，这些模式都不是我发明的，我只是搬运工，中间结合了我的理解和经验，希望对大家有所帮助。

根据我的经验，这一节介绍的内容第一遍看不懂是很正常的，多看一些动态规划算法实现，特别是它们对状态定义的分析，再回头理解这些模式，就会容易一点。如果还不行，就再多看一些资料，特别是那些对问题分析比较多的文章，不要只关注代码。

#### 来自黑书的内容

动态规划算法有三个要素：

（1）所有不同的子问题所组成的表（它包含的问题数目称为问题的大小，即 size）；

（2）问题解决的依赖关系可以看成是一个图；

（3）填充子问题的顺序（实际上就是（2）所得到的图的一个拓扑排序）。如果子问题的数组为 O(n^t)，且每个子问题需要依赖于 O(n^e) 个其他子问题，则称这个问题为 tD/eD 问题，总结起来可得到四种典型的动态规划关系递推方程（opt 是最优关系，可能是 max，也可能是 min）。

##### **1D/1D**

![QQ截图20190620190955](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620190955.png)

##### **2D/0D**

![QQ截图20190620191412](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620191412.png)

##### **2D/1D**

![QQ截图20190620191502](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620191502.png)

##### **2D/2D**

![QQ截图20190620191540](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620191540.png)

#### 区间动态规划的算法模式

区间动态规划，顾名思义，就是求解一个区间内的某种最优解，这种题目在分解子问题的时候，通常考虑子问题就是其中任意一个子区间，而规划的内容就是如何分解子区间。无论题目内容怎样，算法的实现模式基本上就是一个如下所示的三重循环。

```c++
for(区间长度 size：从最小可分区间开始到最大区间长度)
{
    for(小区间起始位置 i：从第一个位置开始到区间长度 size 所决定的结束位置)
    {
        j = i + szie - 1; //j 定义区间结束位置，具体计算方法因问题而异
        for(区间分割点位置 k：从 i 开始到 j 结束)//遍历所有区间 [i,j] 内的位置，将其分割为两个小区间
        {
            f[i][j] = max(f[i][j],f[i][k]+f[k][j] + 某种最优值计算方法)
            或
            f[i][j] = min(f[i][j],f[i][k]+f[k][j] + 某种开销计算方法)
        }
    }
}
```

第一重循环枚举区间的大小，一般是从最小可分解区间开始，直到最大区间长度。为什么枚举区间长度要从“最小可分解区间”开始呢？因为区间长度太小的话，不满足题目的分解区间要求，后续的处理也没有意义。具体的“最小可分解区间”的值，因题而异，比如三角形组合问题，最小区间长度至少是 3 条边才行，否则连一个三角形都凑不齐，后续还怎么处理？对于经典的“石子合并”问题，区间长度就是石子的堆数，要能够合并，至少要 2 堆石子吧，所以石子堆数就从 2 开始枚举。

实现模式的第二重循环是对区间内的起始位置开始枚举。第一重循环给定了区间的大小（范围）；第二重循环就尝试从**区间的不同位置开始定义子区间**。举个简单的例子，假设第一重循环给定了区间长度是 5，则第二重循环要处理的最大区间就是 [1,2,3,4,5]，第二重循环的作用就是分别尝试定义子区间，共可得到 5 个子区间： [1,2,3,4,5]、[2,3,4,5]、[3,4,5]、[4,5] 和 [5]；第三重循环就是尝试对每个子区间分解，假设前两重循环选择了第二步分解的 5 个子区间中的第 2 个子区间，也就是 [2,3,4,5]，则 k 的值就是从 2 到 5，拆分子区间，共得到三组拆分结果：[2] 和 [3,4,5]、[2,3] 和 [4,5]、[2,3,4] 和 [5]。对于每一组拆分结果，计算状态值：

```
state1 = f[2][2] + f[3][5] + 根据当前 k=2 的分解得到的某种最优值（或开销值） 
state2 = f[2][3] + f[4][5] + 根据当前 k=3 的分解得到的某种最优值（或开销值）
state3 = f[2][4] + f[5][5] + 根据当前 k=4 的分解得到的某种最优值（或开销值）
```

然后将三个 state 分别与 f 2 5 比较，根据题目的要求，用最优值更新 f 2 5 的值。当全部三重循环都完成后，题目要求的解就在 f 1 n 中。

这就是区间动态规划的解题思路和实现模板，如果还不理解也没关系，后面我们会介绍几个区间动态规划的例子，结合例子再来理解这里的解题模式就可以了。

#### 总结

这一课，我们用一个简单的上楼梯问题作为例子，从简单穷举法开始，通过明确子问题的最优子结构，逐步过渡到带备忘录的穷举法和有递推关系驱动的高效动态规划法实现，帮助大家体会动态规划的设计思想。虽然动态规划的概念很抽象，但是只要确定问题的实质，理解动态规划法的思想，按照动态规划法的要求确定子问题和子问题最优解的递推关系，准确识别边界条件，设计动态规划法的算法也不是一件很困难的事情。

这一课，我们还介绍了典型的动态规划问题的几种常见递推关系式模型，还有区间动态规划的典型算法实现模式。

这一课，你还应该知道，并不是只有用递推关系式的方式实现的代码才是动态规划，只要子问题满足无后向性，用辅助备忘录的形式也是动态规划。根据我玩 OJ（Online Judge）算法的经验，一些问题如果最优解递推关系式不明显，直接编写代码有困难，可以尝试用分治 + 穷举的方法，只要子问题满足无后向性要求，用辅助备忘录的形式消除子问题的重复求解开销，基本上都能满足 OJ 题目对运行时间的要求。



### 4-2 装配线与工作站问题

>在前面的内容中，我们介绍过用穷举法设计“装配线与工作站问题”的算法实现，这一课我们将介绍如何用动态规划法设计这个问题的算法实现。
>
>两种不同的设计思想它们的算法实现肯定也是相差千里，穷举法中的遍历过程需要算法代码显式控制，而动态规划法的遍历过程则是算法本身隐含的，说具体一点，就是隐含在状态递推的过程中。
>
>在开始本课的内容之前，请大家再回忆一下[第4-1课]的内容，用动态规划思想设计算法实现，需要明确的三个问题：**子问题与决策阶段状态的定义、状态递推关系式、边界条件**。

#### 问题回顾

为了便于理解本课的内容，在开始算法分析之前，再回顾一下这个题目：Colonel 汽车公司在有两条装配线的工厂内生产汽车，一个汽车底盘在进入每一条装配线后，在每个工作站会在汽车底盘上安装不同的部件，最后完成的汽车从装配线的末端离开，如图（1）所示：

![QQ截图20190620193746](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620193746.png)

每一条装配线上有 n 个工作站，编号为 j=1,2,…,n，将装配线 i（i 为 1 或 2）的第 j 个工作站表示为 S(i,j)。装配线 1 的第 j 个工作站 S(1,j) 和装配线 2 的第 j 个工作站 S(2,j) 执行相同的功能。然而这些工作站是在不同的时间建造的，并且采用了不同的技术，因此，每个工作站上完成装配所需要的时间也不相同，即使是在两条装配线相同位置的工作站也是这样。把每个工作站上所需要的装配时间记为 a(i,j)，并且，底盘进入装配线 i 需要的时间为 e(i)，离开装配线 i 需要的时间是 x(i)。

正常情况下，底盘从一条装配线的上一个工作站移到下一个工作站所花费的时间可以忽略，但是偶尔也会将未完成的底盘从一条装配线的一个工作站移到另一条装配线的下一个工作站，比如遇到紧急订单的时候。假设将已经通过工作站 S(i,j) 的底盘从装配线 i 移走所花费的时间为 t(i,j)，现在的问题是要确定在装配线 1 内选择哪些工作站以及在装配线 2 内选择哪些工作站，以使汽车通过工厂的总时间最小，如图（2）所示，最快的时间是选择装配线 1 的 1、3 和 6 号工作站以及装配线 2 的 2、4 和 5 号工作站。

![QQ截图20190620193833](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620193833.png)

根据题目的意思，汽车底盘即使选择一条装配线不换，从第一个工作站移动到最后一个工作站，也能完成安装，但是这样所花费的时间可能不是最短的。如果另一条装配线上的某个工作站效率比较高，那么装配到这一步的时候，换到那条装配线上进行装配肯定会节省时间，但是考虑到从一条装配线移动到另一条装配线也需要花费时间，那就要综合考虑了。“移”还是“不移”？这再次成为问题。

#### 子问题和决策阶段状态的定义

![QQ截图20190620194334](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620194334.png)

这个问题看似是求每个装配站完成对应工序的装配需要的最短时间，但感觉应该是个线性动态规划问题。

我们讲过很多这样的问题，一般用 f[j] 表示第 j 个决策阶段的状态，对于这个问题，具体的子问题就是第 j 个工作站完成装配的最小花费时间，f[j] 就表示这个时间。

很可惜，这个问题不是普通的线性动态规划，因为它有两条装配线。对于两条生产线上的第 i 个工作站来说，用一个 f[j] 无法表示，并且子问题不能满足无后向性。那么按照第 4-1 课中给的方法，给这个子问题增加一个决策维度如何呢？不妨试试用 f[i] [j] 表示第 i 条生产线的第 j 个装配站完成装配需要的最小花费时间，其**子问题就是“汽车底盘在第 i 条生产线的第 j 个工作站完成安装”**。

事实上，这样做是可以的，但是增加的这个维度将动态规划搜索的时间复杂度从 O(n)变成了 O(n^2)。事实上，如果问题的规模是 m 条装配线，那么用这个状态和子问题的定义方式完全没有问题，因为问题的时间复杂度本身就是 O(n^2)。

对于本题只有两条生产线的情况，《算法导论》这本书给出了一个解决策略，使得问题的时间复杂度仍然是 O(n)级别。具体方法就是为每条装配线定义一个决策状态，分别用 f_1[j] 和 f_2[j]表示，然后对两条装配线分别规划最优解。如图（3）所示，对于第一条装配线来说，通过装配站 S(1,j) 的最小时间开销为以下两个装配方法中所花费时间较小的那种方法：

- 从装配站 S(1,j-1) 直接通过装配线 S(1,j) 完成装配
- 从装配站 S(2,j-1) 移到装配线 1 上，再通过装配线 S(1,j) 完成安装

![QQ截图20190620195012](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620195012.png)

#### 状态递推关系和边界值

上一节对子问题决策状态的分析过程中，实际上已经给出了决策状态的递推关系式，现在看看递推的边界值怎么确定。

很显然，这个问题的边界值其实就是汽车底盘开始装配和结束装配两个时间点。对于第一条装配线，S(1,1) 完成装配需要的时间开销是将底盘移入第一条装配线的移动时间和 S(1,1) 装配站的装配时间之和，同样，对于第二条装配线，S(2,1) 完成装配需要的时间开销是将底盘移入第二条装配线的移动时间和 S(2,1) 装配站的装配时间之和。

![QQ截图20190620195156](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620195156.png)

结束装配时的边界值其实就是问题的解，因为根据最优子结构的性质，最终 *f*1[*n*] 是通过第一条生产线的最后一个装配站的最快时间，f2[n] 是通过第二条生产线的最后一个装配站的最快时间，最后移出装配线的最小时间开销就是：

![QQ截图20190620195258](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620195258.png)

其中，x[1] 是将底盘从第一条装配线移出的时间开销，x[2] 是将底盘从第二条装配线移出的时间开销。

#### 算法实现

“兵马未动、粮草先行”，开始算法代码的实现之前，先要设计好**数据模型**，使得算法实现中可以方便地存取各种需要的数据。大多数算法题目，都可以将数据模型分为程序原始数据和结果数据两部分，在设计数据模型的时候可以将它们分开考虑。程序原始数据是算法题目中给出的各种参数，需要将其转化为数据模型，本题的原始数据非常简单，直接照搬描述就可以了，不需要细化讨论了。

```c++
typedef struct
{
    int a[LINES][STATIONS];
    int t[LINES][STATIONS];
    int e[LINES];
    int x[LINES];
}Program_T;
```

结果数据存放算法运算的结果和必要的中间过程数据，运算结果通常是题目要求的解。本题的结果数据包括各个阶段的决策状态中间过程和最优解的决策过程：

```c++
typedef struct
{
    int line[STATIONS];  //遍历过程中的最优决策
    int ls;
    int f[LINES][STATIONS];  //当前已知的决策状态
    int fs;  //最优解的值
}Result_T;
```

用动态规划法设计算法的三部曲是：**初始化边界值、用合适的程序结构实现递推关系求解和计算最优解并给出最优解的决策过程（如果有必要的话）**。根据程序算法的特点，我们用 0 作为第一个装配站的编号，则初始化边界值的代码就是上一节完整递推关系式中 j=1 的情况，给第一个装配站赋值，翻译成代码就是给 f[0] [0] 和 f[1] [0] 赋值，接着是根据递推关系式依次计算各个装配站对应的最优决策状态值，直到计算出最先有一个装配站的结果 f[0] [n-1] 和 f[1] [n-1] 为止，最后是根据 f* 的计算公式得到最终的最优解。

根据递推关系式的特点，用代码实现递推关系计算可以采用循环结构，循环起点是从第二个装配站到最后一个装配站，即：

```c++
for(int j = 1; j < STATIONS; j++)
```

动态规划类的问题，往往还需要保存最优解递推计算过程中的决策过程，以便于在得到最优解后能反向追踪其决策过程，目的是满足题目要求输出决策结果的要求。本题要求的决策结果是给出汽车底盘在各个装配站上的转移过程，用数据语言描述就是需要记录对于每一个装配站，最优决策选择的是第一条装配线还是第二条装配线。`Result_T` 中用二维数组 line 记录决策过程，line 数组的每个元素值是装配线的编号，简单理解就是对于第 i 条装配线的第 j 个装配站来说，它的最优决策的上一个装配站，即第 j-1 个装配站来自 line[i] [j] 中记录的装配线上。`fast_station_sequence()`函数是算法的完整实现，该解释的基本上都解释过了。对于 line 决策过程的回放处理代码在`print_result()`中，注意这是倒着输出结果的，你需要把脖子拧一下反着看。如果想按照正向的顺序输出决策过程，很多情况下都要用到递归，实现起来并不困难（几行代码），就留给读者自己完成吧。

```c++
void fast_station_sequence(Program_T *para, Result_T *result)
{
    //初始进站化边界值
    result->f[0][0] = para->a[0][0] + para->e[0];
    result->f[1][0] = para->a[1][0] + para->e[1];

    //递推关系计算
    for(int j = 1; j < STATIONS; j++)
    {
        if((result->f[0][j - 1] + para->a[0][j]) <= (result->f[1][j - 1] + para->t[1][j] + para->a[0][j]))
        {
            result->f[0][j] = result->f[0][j - 1] + para->a[0][j];
            result->line[0][j] = 0;
        }
        else
        {
            result->f[0][j] = result->f[1][j - 1] + para->t[1][j] + para->a[0][j];
            result->line[0][j] = 1;
        }
        if((result->f[1][j - 1] + para->a[1][j]) <= (result->f[0][j - 1] + para->t[0][j] + para->a[1][j]))
        {
            result->f[1][j] = result->f[1][j - 1] + para->a[1][j];
            result->line[1][j] = 1;
        }
        else
        {
            result->f[1][j] = result->f[0][j - 1] + para->t[0][j] + para->a[1][j];
            result->line[1][j] = 0;
        }
    }
    //计算离站边界值
    if(result->f[0][STATIONS - 1] + para->x[0] <= result->f[1][STATIONS - 1] + para->x[1])
    {
        result->fs = result->f[0][STATIONS - 1] + para->x[0];
        result->ls = 0;
    }
    else
    {
        result->fs = result->f[1][STATIONS - 1] + para->x[1];
        result->ls = 1;
    }
}

void print_result(Result_T *result)
{
    std::cout << "Total Time " << result->fs << std::endl;

    int i = result->ls;
    std::cout << "Station " << STATIONS << " on Line " << i + 1 << std::endl;
    for (int j = STATIONS - 1; j > 0; j--)
    {
        i = result->line[i][j];
        std::cout << "Station " << j << " on Line " << i + 1 << std::endl;
    }
}
```

#### 总结

这一课我们使用动态规划法实现了对“装配线和工作站”问题的算法设计，演示了动态规划三部曲的思考和分析过程。希望读者看完这一课的内容，能够再掌握一种动态规划类型的算法问题分析求解方法，并且对动态规划法能够有更深入的理解。



### 4-3 凸多边形最优三角剖分问题

>凸多边形上的最优三角剖分问题也是动态规划经典题目，此类问题基本上都是在一个给定的凸多边形上规划三角形分割，使得剖分后得到的一系列三角形的某种结果最优，比如三角形的面积之和最大（或最小），或者是三角形的各边权重之和最大（或最小）等等。
>
>这一课，我们要介绍的题目是要求根据三角形的权重之和最小来剖分多边形，结合这个题目，希望大家能掌握如何分析此类问题，并用动态规划的方法设计出求解此类问题的算法实现。

#### 子问题的定义

先来解释一下题目中提到的“三角形权重之和”是什么意思。边的权是图论中的一个很重要的概念，实际上就是为边赋予一个人为指定的属性，常用来表示边代表的两点的距离，或者两点之间的各种开销。这个题目中说的权实际上更简单，就是多边形每条边的一个附加属性。一个三角形的权重就是组成三角形的三条边的权重之和，而题目中的“三角形权重之和”表示的是多边形拆分成的一系列小三角形的权重之和。

如图（1）所示，把一个凸多边形分割成多个三角形有多种剖分形式，根据题目给出的条件，每种分割方法得到的三角形的权重之和也各不相同。用动态规划方法解决算法问题，首先要确定子问题和各决策阶段状态的定义，然后是给出最优子结构的性质。每个决策阶段的状态，实际上就是子问题在这个决策阶段的解，这个阶段的最优解一般是根据最优子结构的性质由之前各阶段的解和当前的最优决策堆叠出来。所以，用动态规划法解决算法问题的关键是识别出子问题并给出决策状态的定义。

![QQ截图20190620205557](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620205557.png)

《如何理解动态规划法》这一课我们介绍可一种分析定义子问题的方法，就是确定问题的规模，**通过缩小问题规模的方式确定子问题**，这里不妨应用一下。

首先看问题的解，问题的解是按照三角形剖分后的多边形具有最小的三角形权重和，这句话有点拗口，我们就用多边形的最小权重这个概念来代替前面那句话。那么在某个决策阶段的子问题的状态就是当前子问题定义的多边形（规模较小的多边形）的最小权重，于是缩减问题的规模就是选择多边形中的某几个点组成一个小多边形（子多边形）。

既然原始问题中多边形是由 N 个顶点，那么子问题是否可以定义为“由 i 个点组成的多边形”，其中 i 的取值范围是：0⩽*i*⩽*N*，用状态 d[i] 表示由 i 个顶点组成的多边形的最小权重值。

请大家思考一下，这样定义子问题是否合适？显然不合适，因为这样定义的子问题不满足无后向性，为什么这么说呢？举个“栗子”，请看图（1）中的多边形例子，由 *V*0、*V*1 和 *V*2 三个点组成的子问题的状态 d[3] 和由 *V*4、*V*5 和 *V*6 三个点组成的子问题的状态 d[3] 在后续的状态演化过程中的结果肯定不一样，那就意味着虽然之前的搜索通过两个不同的路径都到了 d[3] 状态，但是却是两个不同的 d[3]，其后续得到的结果也不一样，这就不满足无后向性原则了。

**按照无后向性原则，不管之前通过什么途径到了 d[3] 状态，其后续演化的结果应该是不变的**。

这样定义子问题的错误在于只看到了问题规模的一部分，没有看到问题的全部。对于凸多边形问题，因为任意两个顶点之间的边的权重是不一样的，所以每个顶点之间都是不一样的，不同简单地只关注顶点的数量。**基于这一点考虑，子问题中除了应该含有顶点数量的信息，还应该包含顶点信息**。

如果原始问题的规模是“由顶点 *V*0 到 *V*7 组成的多边形”，那么子问题可以考虑成“由顶点到 Vi 到  Vj 组成的多边形”，其中 i 和 j 的范围是：1 ⩽*i*<*j*⩽*N*−1，这样定义的子问题既考虑了顶点的数量，又包含了顶点信息。既然子问题需要两个变量描述，那么我们考虑子问题的状态用 d[i] [j]表示子问题“由顶点 Vi到 Vj 组成的多边形”的最小权重。当然，这样定义子问题的前提是要求多边形的顶点从 i 到 j 之间的顶点是连续的，但这并不妨碍我们解决这个问题。

在分割多边形子问题的时候，只要保证顶点 i 和顶点 j 之间的连线始终是分割三角形的一条边，就可以使得被此三角形分割的两个小多边形的顶点也是连续的，大家可以参考图（2）的最优子结构示意图来理解这一点。

为什么说做了这个约束仍然不影响对问题的解决呢？原因就在于动态规划法对这个问题的解决思想本质上还是遍历，对每个子多边形的遍历有多种顺序，但是只要按照一种顺序遍历就可以了，不需要处理所有的遍历顺序，因为它们最终都会在遍历其他子多边形的时候被重复遍历到。所以我们要求子多边形的起始点必须是分割三角形的一条边其实是约定了一种遍历顺序，被忽略的其他顶点之间的边会在遍历其他子多边形的时候被处理，并不会漏掉任何一种状态。

当然，这个约束条件也简化了算法程序的实现难度，毕竟用二维数组直接表示一个状态，要比用顶点的集合映射一个状态要简单很多。

#### 子问题最优子结构

定义了子问题，接下来就要分析最优子结构的性质了。所谓最优子结构的性质，其实就是确定是否能找出一种决策方法，该方法能够根据前一个阶段或前几个阶段的子问题的状态，通过某种策略或方法得到当前阶段的状态，并使得当前的状态是最优的。我们首先假设在某个决策阶段的一个三角形分割形式如图（2）所示，当前要决策的状态是 d[1][7]*d*[1][7]（后面会解释为什么这个状态是 d[1][7]*d*[1][7]，而不是 d[0][7]*d*[0][7]），由 V_{0}*V*0 和 V_{7}*V*7 两个顶点组成的边，可以和其他 6 个顶点（V_{1}-V_{6}*V*1−*V*6）中的任意一个组成一个三角形，从而将多边形分割成一个三角形加上两个小多边形的状态。

假设我们选择 V_{4}*V*4，则得到三角形 V_{0}V_{4}V_{7}*V*0*V*4*V*7 和两个小多边形 \{V_{0},V_{1},V_{2},V_{3},V_{4}\}{*V*0,*V*1,*V*2,*V*3,*V*4} 和 \{V_{4},V_{5},V_{6},V_{7}\}{*V*4,*V*5,*V*6,*V*7}，根据之前对子问题和状态的定义，我们用 d[1][4]*d*[1][4] 和 d[5][7]*d*[5][7] 分别两个小多边形的最小权重，用 w(0,4,7)*w*(0,4,7) 表示三角形 V_{0}V_{4}V_{7}*V*0*V*4*V*7 的权重，则选择顶点 V_{4}*V*4 时，计算出来的权重值就是：d[1][4]+d[5][7]+w(0,4,7)*d*[1][4]+*d*[5][7]+*w*(0,4,7)。同样，当选择顶点 V_{3}*V*3 时，计算出来的权重值就是：d[1][3]+d[4][7]+w(0,3,7)*d*[1][3]+*d*[4][7]+*w*(0,3,7)。

**为了使子问题的结果最优，子问题的最优子结构就应该是将 V_{1}-V_{6}V1−V6 这6个顶点都尝试一遍，然后选择结果最小的那个权重值作为状态 d[1][7]d[1][7] 的值**，假如按照顶点 V_{3}*V*3 的分割能使得 d[1][3]+d[4][7]+w(0,3,7)*d*[1][3]+*d*[4][7]+*w*(0,3,7) 的值在所有 6 个结果中是最小的，则最后状态 d[1][7]*d*[1][7] 的值就是：d[1][3]+d[4][7]+w(0,3,7)*d*[1][3]+*d*[4][7]+*w*(0,3,7)。



### 4-4 状态压缩与动态规划

### 4-5 铺瓷砖问题



### 4-6 矩阵链乘问题

这一课介绍的矩阵链乘问题，是区间类型动态规划的典型例子，区间类型的动态规划是在线性动态规划基础上的扩展。

我的理解是，这个扩展就是将固定的线性问题变成一个变长的线性问题，也就是说，所谓的区间动态规划，就是在一个可选择的线性区间中寻找某种最优的结果，而线性区间长度本身也是可变化的，最优结果的组合也是可变化的，需要在两重变化中寻找最优解。

除了矩阵链乘问题，此类问题的典型例子还有石子合并问题、能量项链问题、最优排序二叉树问题等。除此之外，前几年非常火的多边形三角剖分问题，也被归纳为区间动态规划类型的题目。

#### 问题介绍

《算法导论》一书在介绍动态规划问题时，举了一个矩阵链乘（Matrix-chain Multiplication）的例子。我知道很多读者害怕公式，看见《矩阵论》就头疼，但是不要怕，这个题目只涉及了一个简单的概念，就是矩阵的**相容性**（Compatible）。

矩阵 A 和 B 能够相乘，前提是矩阵 A 和矩阵 B 必须相容，所谓的相容，就是矩阵 A 的列数等于矩阵 B 的行数。假设矩阵 A 是 p×q 的矩阵，矩阵 B 是 q×r的矩阵，则矩阵 A 和矩阵 B 的乘积是一个 p×r 的矩阵。计算这个乘积需要 p×q×r 次标量乘法计算和若干次加法，其计算量的主要代价就是这 p×q×r 次乘法计算。

对于一组满足相容性条件（顺序）排列的矩阵做链乘，无论选择中间哪两个矩阵先计算，其结果都能与剩下的矩阵继续保持相容性条件，这是一个很重要的前提，因为调整矩阵的位置会破坏相容性。但是，在矩阵位置不变的情况下，选择计算的顺序对标量乘法的计算量有巨大的影响。

例如，有三个矩阵 A B C 相乘，其中 A 是 10×100 的矩阵，B 是 100×5 的矩阵，C 是 5×50 的矩阵。如果我们按照（（A B）C）的顺序计算，则需要计算的乘法次数是 10 × 100 × 5 + 10 × 5 × 50 = 7500 次。如果我们按照（A（B C））的顺序计算，则需要计算的乘法次数是 100 × 5 × 50 + 10 × 100 × 50 = 75000 次。可见，第二种计算方法需要的计算量是第一种方法的 10 倍。那么，最后的问题来了，对于 n 个矩阵序列 A1,A2,A3,...,An，我们要计算它们的乘积，请用括号化的方式给出一种计算次序，使得最终需要的标量乘法次数最少。

#### 算法原理分析

根据我们的经验（读者也应该掌握这个经验），典型的线性动态规划问题，一般会将状态定义为 f[i,j]，其中 i 代表状态出现的位置，j 代表阶段的划分。

对于矩阵链乘问题，阶段的划分其实就是参与相乘的矩阵的数量，每多一个矩阵参与乘法计算，阶段就增加一个。因此，对于本问题，位置 i 就是参与计算的矩阵链的第一个矩阵的编号，阶段 j 其实就是参与链乘计算的最后一个矩阵的编号，状态 f[i,j] 就是矩阵 AiAi+1,...,Aj 乘积的最优解。

有了状态的定义，实际上子问题就很清晰了，就是矩阵序列 A1,A2,A3,...,An 中的一个子串，那么这样定义子问题是否满足无后向性要求呢？我们来分析一下，假设子问题 A3A4A5 的最小标量乘法次数是状态 f[3,5]，那么它前面的矩阵 A2 无论是直接和 A3A4A5 的结果相乘，还是 A1 和 A2 先相乘，然后再和 A3A4A5 的结果相乘，都不影响 A3A4A5 之前计算出来的结果（即状态 f[3,5] 的值）。A3A4A5 的结果与后面的矩阵做乘法运算，无论以何种方式组合相乘，也同样都不会改变状态 [3,5] 的值，因此，我们这样划分的子问题满足无后向性要求。

那么，状态 f[i,j] 怎么计算呢？很简单，就是将其分解为更小一点的子问题，通过求解子问题的状态递推计算状态 f[i, j] 的值。设区间 [i,j][i,j] 之间有分割点 k 满足 i≤k<j，则以 k 为分割点时得到的状态结果就是：
$$
f[i,j]_{k} = f[i,k] + f[k+1,j] + cost(k) 
$$
其中，cost(k) 是两个子问题得到矩阵相乘的开销，即标量乘法的次数。区间 [i,j][i,j] 之间能有多少个分割点 k，就有多少个 f[i,j]k，最后状态 f[i,j] 取所有 f[i,j]k 中最小的那个即可：

![QQ截图20190609230725](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190609230725.png)

怎么理解这个公式呢，我们用一个实际例子来解释一下。假设有以下 6 个矩阵

![QQ截图20190609230824](C:\Users\12069\Desktop\QQ截图20190609230824.png)



那么，读者可能会问，既然可以拆分成子问题，那为什么只拆成两个子问题，难道不能拆成更多的子问题？当然，为了遍历各种组合情况，我们也会拆分更多的子问题，但是无论怎么拆分，最终都是得到各种规模的子问题所组成的一张表。那么怎么做到拆分各种规模的子问题呢？回忆一下[第4-1课：如何理解动态规划]中给出的区间类型动态规划算法实现模式，套用一下就好了：



### 4-7 投资问题



### 4-8 方块消除游戏

>前面基础部分我们介绍过简单的串模型的动态规划，在这个系列中，我们又介绍了区间动态规划模型、状态压缩动态规划模型和线性动态规划模型。
>
>我们用的算法实现都是尽量使用状态递推关系式直接用递推的方法，大家可能都忘了“备忘录（或状态记忆）”也是动态规划
>
>这一课我们将讲解如何用这种方法来求解方块消除游戏的算法实现。

