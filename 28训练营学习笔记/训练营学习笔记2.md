### 4-1 动态规划法

在基础部分，我们介绍了动态规划法的两个重点和实现动态规划法的四个步骤

在第 4 部分动态规划中，我们将介绍一系列动态规划类的算法例子，这些例子覆盖**一维动态规划、串模型的动态规划、区间模型动态规划以及状态压缩类型的动态规划**，但是在开始之前，先通过几个简单的例子，帮助大家进一步理解动态规划。

#### 如何理解动态规划

动态规划法中有几个概念比较抽象，一个是重叠子问题，一个是最优子结构，还有一个是子问题的无后向性（无后效性）。

这几个概念不是独立的，它们之间是相互联系的，首先说说重叠子问题。千万不要望文生义，这里重叠的意思不是子问题之间互相有重叠的部分，是指一个问题的子问题可以被重复使用，每个决策阶段的子问题的状态（子问题的解），可由其他已经决策过的子问题（已经求解过的子问题）的状态通过某种关系决策（堆叠）后得到，而不是必须引入新的子问题才能解决。

一旦某个阶段的子问题的状态需要引入新的子问题而不是用已经决策过的，并且是确定了状态的子问题才能解决，说明子问题不满足无后向性。所谓的无后向性，是指子问题在某个阶段的状态一旦确定，其后续的状态变迁都是一样的，不会因为之前到达这个状态的路径或方式不同而变化。

怎么理解呢，举个例子，假如子问题在某个阶段的状态确定后，其后续经过若干个决策阶段后可以得到一个最优解，那么不管之前通过何种决策路经，只要在搜索过程中达到这个公共状态，就可以得到最优解，这个结果不会再改变，因此可以记录下来，其他阶段的决策可以直接用状态值表达，不需要再重复计算其后续各个阶段的子问题的状态值。一个问题的最优解可以从其子问题的最优解中得到，那么我们称这个问题具有最优子结构。最优子结构并不是动态规划法独有的要求，很多求解最优化问题的算法都要求子问题的划分满足最优子结构的要求。

用动态规划法设计算法的关键是找出子问题和子问题状态的定义。子问题的状态就是子问题的最优解，当子问题的规模是最终的问题的时候，那么其对应的状态就是问题的最优解。

基于这一思想，通常选择把问题的规模作为状态变量的方式定义子问题。以取硬币问题为例，其问题是取 N 元硬币需要的最小硬币数量。

于是我们就选择“取 i（0 ≤ i ≤ N）元硬币需要的最小硬币数量”作为子问题，并定义状态 d[i] 为取 i 元硬币需要的最小硬币数量。

本课介绍的字符串编辑距离问题，问题的规模有两个，一个是源字符串长度 n，另一个是目标字符串长度 m，于是我们可以选择“长度为 i 的源字符串和长度为 j 的目标字符串的最小编辑距离”作为子问题，并定义状态 d[i,j] 为子问题的解（最小编辑距离）。最终，d[n,m] 就是原始问题的解。

如果大家在尝试用动态规划法设计算法时感到无从下手，不妨尝试一下这种从**问题的规模入手**的方法。

关于子问题以及子问题在某个决策阶段的维度，也是可以用来综合考虑子问题分解的参考方向。比如 0-1 背包问题，第一次接触这个问题很容易将其决策状态理解为装入第 i 个物品时包中物品的总价值，于是将子问题定义为装入第 i 个物品。

实际上这样是不对的，**因为空包的情况下选择第 i 个物品和包中已经装了几个物品后再选择第 i 个物品所产生的状态是不一样的，也就是说对于状态 d[i]，用不同的选择物品的顺序得到的 d[i] 值是不一样的，这就不能满足子问题的无后向性**。之所以出现错误，是因为一个重要的信息没有考虑，那就是选择物品 i 时包的剩余容量，因此子问题的状态应该增加一个维度，即定义状态 d[i,j] 为将第 i 个物品装入剩余容量为 j 的包中所得到的物品价值，对应的子问题就是将第 i 个物品装入剩余容量为 j 的包中。这样增加一个维度，子问题的定义就能满足无后向性。

一个问题经过多个阶段的决策可以得到最优解，这一系列的状态变化可以视为一个决策序列。动态规划的每个阶段的决策，并不要求之前阶段的状态必须是最优的，它只是保证现阶段的决策采用最优的策略，尽力而为得到当前阶段的“最优解”。在动态规划法的状态表中，并不是每个状态都是最优的，但是它把所有的状态都计算了一遍，根据最优子结构的性质，总有一个决策序列最终能得到全局的最优解。所以，动态规划本质上依然是搜索，它会把所有的决策序列都搜索一遍，尽管绝大多数决策序列都不会得到最优解。动态规划的高效体现在对于每个决策阶段的子问题的状态只计算一次，存储结果，当需要再次使用这个子问题时，直接查表，不需要再次求解，不需要再次求解的原因正是因为子问题的无后向性。也正因为如此，动态规划法对那些每个决策阶段都会产生指数级重复子问题的问题特别有效。关于这一点，Kleigberg 在《算法导论》这本书中，对动态规划有如下描述：

> 动态规划法通过将问题细分为一系列子问题，从而隐含地探查了所有可行解的空间，于是我们可以从某种程度上把动态规划看作接近暴力搜索边缘的危险操作。动态规划对子问题的处理方式，使得它可以遍历问题可行解的指数规模的集合，甚至可以在没有明确检查所有解的情况下做到这一点。这是一种对重叠子问题（子问题包含子子问题）处理的内在机制。

理解了这段话的意思，也就能理解动态规划法的实质，即动态规划就是利用子问题的“无后向性”特点，通过递推关系隐含地实现了所有子问题序列的求解，其内在机制也避免了同类子问题的重复求解。如果问题不是线性的，那么即使是动态规划法，也会呈现出类似穷举的广域搜索的效果，即便是没有出现最优解的子问题序列也会被求解。



#### 上楼梯问题

为了更好地理解动态规划法，这里用一个实际的算法例子，从盲目穷举法开始，逐渐过渡到动态规划法。大家可以从这个过程中，理解 Kleigberg 这段话的意思，理解动态规划法。

《算法的乐趣》一书中用了一个“字符串的编辑距离问题”作为例子，但因为问题本身有一定的难度，读者反馈不容易理解。这里我们从《国际大学生程序设计竞赛例题集》这本书中找了一个简单的“上楼梯问题”作为例子，这个问题也是一个非常常见的面试题。

#### 问题提出

小明上楼梯有个习惯，就是一次要么走 1 级台阶，要么走 2 级台阶，有一个楼梯有 20 级台阶，问按照小明的习惯，他有多少种上楼梯的方法。

分析这个问题，我们先试试减小问题的规模。假设楼梯只有 1 级台阶，那么只有一种上楼的方法。假设楼梯有 2 级台阶，那么小明会有 2 种上楼的方法，一种是一次走 1 级台阶，需要走 2 次才能上楼，另一种是一次走 2 级台阶，走 1 次就能上楼。再进一步，假设楼梯有 3 级台阶，此时小明会想，如果我选择先走 1 级台阶，那么楼梯还剩 2 级台阶，对于 2 级台阶的楼梯，此前已经知道有 2 种上楼方法。那么反过来，如果我选择先走 2 级台阶，那么楼梯还剩 1 级台阶，对于 1 级台阶的楼梯，此前也知道只有 1 种上楼的方法。所以，小明分别做这两个选择以后，共有 3 种上楼梯的方法。

楼梯有更多的台阶时怎么办呢？

#### 分治法 + 穷举法

实际上，上一节对 3 级台阶的分析，已经隐含了一个很重要的思想，就是分治法。

对于有 n 个台阶的楼梯，解决的方法就是先选择走 1 级台阶，将剩下的 n-1 级台阶作为子问题求解，然后再选择走 2 级台阶，将剩下的 n-2 级台阶作为子问题求解，两个选择的上楼方法求和，就是 n 个台阶的上楼方法。

对于上楼梯问题 f(n)，可以分解为 f(n-1) 和 f(n-2) 两个子问题，两个子问题的和就是 f(n) 的解：

f(n) = f(n-1) + f(n-2)

实际上，除了分治法，这里面还隐含了穷举法，尽管只是对两种选择的穷举（走 1 级台阶，还是走 2 级台阶），但那也是穷举。

用分治法就会用到递归算法实现，递归算法实现的重点就是递归主体和递归退出条件。很显然，这个问题的递归主体就是上面求 f(n) 的关系式，递归退出条件就是当问题的规模减小到 1 或 2 级台阶的时候，直接返回对应的上楼梯方法。

用分治法解决这个问题的算法实现如下：

```c++
int f(int n)
{
    if(n == 1)//递归退出条件
    {
        return 1;
    }
    else if(n==2) // 递归退出条件
    {
        return 2;
	}
    else //递归主体
    {
        return f(n-1)+f(n-2);
    }
}
```

用分治法结合递归实现的算法代码总是优雅、简单，但是也存在效率低下的问题。

在前面的基础部分介绍过，分治法效率不高的原因在于子问题的重复求解，这种重复求解造成大量不必要的开销。

图（1）展示了当台阶数 n=5 的时候，按照上述分治法分治与求解子问题的过程，可以看到，3 级台阶对应的子问题被求解了 2 次，2 个台阶的子问题被求解了 3 次。随着问题规模（台阶数） n 的增加，重复出现的子问题会更多，重复计算的开销也越大。

![QQ截图20190610180535](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190610180535.png)

#### 动态规划—带备忘录的穷举 + 分治

分治法对子问题的分解方法，不考虑无后向性，因此很多情况下都不适用于动态规划法，但是这个问题例外，我们用楼梯台阶数定义的子问题，适用于动态规划法。

**我们看图（1）中两次出现的 f(3) 状态，其后续的状态演化都是一样的，结果也是一样的，这说明什么问题？**

这说明这个子问题的分解满足无后向性要求，无论之前是通过何种子问题分解途径来到了 f(3) 这个状态（f(3) 对应子问题的解），其结果是固定的，不会因为是从 f(5) 演化过来的 f(3)，就和从 f(4) 演化过来的 f(3) 不一样。

既然子问题满足无后向性要求，那么我们就来解决子问题的重复求解问题。

解决子问题重复计算的方法就是**设置一个“状态备忘录”**，这个备忘录记录每个子问题的状态（对应子问题的解）。因为子问题的解都是大于 0 的整数，所以我们用 -1 表示这个备忘录条目是无效的，也就是这个子问题还没有被求解过。

```c++
int memo[N];
for(int i = 0; i < N; i++)
{
    memo[i] = -1;
}
```

确定好状态备忘录，还要确定边界状态，也就是子问题 f(1) 和 f(2) 的状态是已知的，直接记录到备忘录中即可：

```c++
memo[1] = 1;
memo[2] = 2;
```

有读者会问，memo[0] 好像没用到？是的，memo[0] 不用，放在那里就好了，这样就可以使 memo[1] 与子问题 f(1) 对应，memo[2] 与子问题 f(2) 对应，以此类推，这也是一种常用的技巧吧。接下来就是改造我们的算法，把备忘录的处理加上：

```c++
int f(int n)
{
    if(memo[n] != -1)
    {
        return memo[n];
    }
    
    // 求解子问题，别忘了更新备忘录
    memo[n] = f(n-1) + f(n-2);
    return memo[n];
}
```

动态规划是一种思想，千万不要形而上学地以为动态规划就是子问题的递推关系式。对于多阶段决策的优化问题，只要阶段划分明确，子问题定义清晰且满足无后效性，不管算法实现用何种形式，它都是动态规划。

#### 动态规划—递推关系式

上一节的例子使用备忘录避免子问题重复求解，这是一种显式的剪枝方法。

我们之前提到过动态规划法内在的剪枝机制，实际上是通过直接搜索递推关系式的方式实现的，也就是大家眼中“正统”的动态规划法。

这一节我们直接给出状态递推关系方式的动态规划算法，用这种方法设计算法实现，需要解决三个问题，首先是子问题状态的定义，这个在上一节已经分析过了；

其次是确定递推关系式，递推关系前面也介绍过，假设我们定义子问题的状态是 f[n]，则状态递推关系式就是：

f[n] = f[n - 1] + f[n - 2]

最后是确定边界条件，边界条件就是：

```c++
f[1] = 1   
f[2] = 2
```

最后，典型的用递推关系式实现的动态规划法算法实现如下：

```c++
int dp(int n)
{
    int f[N] = {0};
    
    // 初始化边界值
    f[1] = 1;
    f[2] = 2;
    // 递推求解f[n]
    for(int i = 2;i<=n;i++)
    {
        f[i] = f[i-1] + f[i-2];
    }
    
    return f[n];
}
```

这是一个简单的例子，演示了子问题定义和对子问题无后向性的理解，通过带备忘录的分治法 + 穷举法实现，是大家对动态规划有一个较深入的理解。

读者看到这里，应该理解，凡是对多阶段决策问题有明确的子问题和状态定义，且子问题满足无后向性条件，并能够通过优化解决子问题的重复求解效率问题的方法，都是动态规划法，希望大家对动态规划有更全面的认识

#### 状态递推关系常用的模式

对付动态规划类问题的，首先要做的是识别子问题以及子问题的状态递推关系式。

说直白一点，就是先用分治法的思想看看能不能分解子问题，如果一种方法分解出的子问题不满足无后向性，就换一种方法。

无论读者之前看过多少动态规划的资料，对动态规划的基本原理讲的再头头是道，如果遇到问题不能识别子问题以及子问题的状态定义，也是无用的。

好在动态规划虽然飘逸，但还是有规律可循，前人还是总结了好几种常见的递推关系模式，这些模式都不是我发明的，我只是搬运工，中间结合了我的理解和经验，希望对大家有所帮助。

根据我的经验，这一节介绍的内容第一遍看不懂是很正常的，多看一些动态规划算法实现，特别是它们对状态定义的分析，再回头理解这些模式，就会容易一点。如果还不行，就再多看一些资料，特别是那些对问题分析比较多的文章，不要只关注代码。

#### 来自黑书的内容

动态规划算法有三个要素：（1）所有不同的子问题所组成的表（它包含的问题数目称为问题的大小，即 size）；（2）问题解决的依赖关系可以看成是一个图；（3）填充子问题的顺序（实际上就是（2）所得到的图的一个拓扑排序）。如果子问题的数组为 O(n^t)，且每个子问题需要依赖于 O(n^e)*个其他子问题，则称这个问题为 tD/eD 问题，总结起来可得到四种典型的动态规划关系递推方程（opt 是最优关系，可能是 max，也可能是 min）。



### 4-6 矩阵链乘问题

这一课介绍的矩阵链乘问题，是区间类型动态规划的典型例子，区间类型的动态规划是在线性动态规划基础上的扩展。

我的理解是，这个扩展就是将固定的线性问题变成一个变长的线性问题，也就是说，所谓的区间动态规划，就是在一个可选择的线性区间中寻找某种最优的结果，而线性区间长度本身也是可变化的，最优结果的组合也是可变化的，需要在两重变化中寻找最优解。

除了矩阵链乘问题，此类问题的典型例子还有石子合并问题、能量项链问题、最优排序二叉树问题等。除此之外，前几年非常火的多边形三角剖分问题，也被归纳为区间动态规划类型的题目。

#### 问题介绍

《算法导论》一书在介绍动态规划问题时，举了一个矩阵链乘（Matrix-chain Multiplication）的例子。我知道很多读者害怕公式，看见《矩阵论》就头疼，但是不要怕，这个题目只涉及了一个简单的概念，就是矩阵的**相容性**（Compatible）。

矩阵 A 和 B 能够相乘，前提是矩阵 A 和矩阵 B 必须相容，所谓的相容，就是矩阵 A 的列数等于矩阵 B 的行数。假设矩阵 A 是 p×q 的矩阵，矩阵 B 是 q×r的矩阵，则矩阵 A 和矩阵 B 的乘积是一个 p×r 的矩阵。计算这个乘积需要 p×q×r 次标量乘法计算和若干次加法，其计算量的主要代价就是这 p×q×r 次乘法计算。

对于一组满足相容性条件（顺序）排列的矩阵做链乘，无论选择中间哪两个矩阵先计算，其结果都能与剩下的矩阵继续保持相容性条件，这是一个很重要的前提，因为调整矩阵的位置会破坏相容性。但是，在矩阵位置不变的情况下，选择计算的顺序对标量乘法的计算量有巨大的影响。

例如，有三个矩阵 A B C 相乘，其中 A 是 10×100 的矩阵，B 是 100×5 的矩阵，C 是 5×50 的矩阵。如果我们按照（（A B）C）的顺序计算，则需要计算的乘法次数是 10 × 100 × 5 + 10 × 5 × 50 = 7500 次。如果我们按照（A（B C））的顺序计算，则需要计算的乘法次数是 100 × 5 × 50 + 10 × 100 × 50 = 75000 次。可见，第二种计算方法需要的计算量是第一种方法的 10 倍。那么，最后的问题来了，对于 n 个矩阵序列 A1,A2,A3,...,An，我们要计算它们的乘积，请用括号化的方式给出一种计算次序，使得最终需要的标量乘法次数最少。

#### 算法原理分析

根据我们的经验（读者也应该掌握这个经验），典型的线性动态规划问题，一般会将状态定义为 f[i,j]，其中 i 代表状态出现的位置，j 代表阶段的划分。

对于矩阵链乘问题，阶段的划分其实就是参与相乘的矩阵的数量，每多一个矩阵参与乘法计算，阶段就增加一个。因此，对于本问题，位置 i 就是参与计算的矩阵链的第一个矩阵的编号，阶段 j 其实就是参与链乘计算的最后一个矩阵的编号，状态 f[i,j] 就是矩阵 AiAi+1,...,Aj 乘积的最优解。

有了状态的定义，实际上子问题就很清晰了，就是矩阵序列 A1,A2,A3,...,An 中的一个子串，那么这样定义子问题是否满足无后向性要求呢？我们来分析一下，假设子问题 A3A4A5 的最小标量乘法次数是状态 f[3,5]，那么它前面的矩阵 A2 无论是直接和 A3A4A5 的结果相乘，还是 A1 和 A2 先相乘，然后再和 A3A4A5 的结果相乘，都不影响 A3A4A5 之前计算出来的结果（即状态 f[3,5] 的值）。A3A4A5 的结果与后面的矩阵做乘法运算，无论以何种方式组合相乘，也同样都不会改变状态 [3,5] 的值，因此，我们这样划分的子问题满足无后向性要求。

那么，状态 f[i,j] 怎么计算呢？很简单，就是将其分解为更小一点的子问题，通过求解子问题的状态递推计算状态 f[i, j] 的值。设区间 [i,j][i,j] 之间有分割点 k 满足 i≤k<j，则以 k 为分割点时得到的状态结果就是：
$$
f[i,j]_{k} = f[i,k] + f[k+1,j] + cost(k) 
$$
其中，cost(k) 是两个子问题得到矩阵相乘的开销，即标量乘法的次数。区间 [i,j][i,j] 之间能有多少个分割点 k，就有多少个 f[i,j]k，最后状态 f[i,j] 取所有 f[i,j]k 中最小的那个即可：

![QQ截图20190609230725](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190609230725.png)

怎么理解这个公式呢，我们用一个实际例子来解释一下。假设有以下 6 个矩阵

![QQ截图20190609230824](C:\Users\12069\Desktop\QQ截图20190609230824.png)



那么，读者可能会问，既然可以拆分成子问题，那为什么只拆成两个子问题，难道不能拆成更多的子问题？当然，为了遍历各种组合情况，我们也会拆分更多的子问题，但是无论怎么拆分，最终都是得到各种规模的子问题所组成的一张表。那么怎么做到拆分各种规模的子问题呢？回忆一下[第4-1课：如何理解动态规划]中给出的区间类型动态规划算法实现模式，套用一下就好了：





