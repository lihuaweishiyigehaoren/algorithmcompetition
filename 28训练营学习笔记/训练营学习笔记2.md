### 4-1 动态规划法

在基础部分，我们介绍了动态规划法的两个重点和实现动态规划法的四个步骤

在第 4 部分动态规划中，我们将介绍一系列动态规划类的算法例子，这些例子覆盖**一维动态规划、串模型的动态规划、区间模型动态规划以及状态压缩类型的动态规划**，但是在开始之前，先通过几个简单的例子，帮助大家进一步理解动态规划。

#### 如何理解动态规划

动态规划法中有几个概念比较抽象，一个是重叠子问题，一个是最优子结构，还有一个是子问题的无后向性（无后效性）。

这几个概念不是独立的，它们之间是相互联系的，首先说说重叠子问题。千万不要望文生义，这里重叠的意思不是子问题之间互相有重叠的部分，是指一个问题的子问题可以被重复使用，每个决策阶段的子问题的状态（子问题的解），可由其他已经决策过的子问题（已经求解过的子问题）的状态通过某种关系决策（堆叠）后得到，而不是必须引入新的子问题才能解决。

一旦某个阶段的子问题的状态需要引入新的子问题而不是用已经决策过的，并且是确定了状态的子问题才能解决，说明子问题不满足无后向性。所谓的无后向性，是指子问题在某个阶段的状态一旦确定，其后续的状态变迁都是一样的，不会因为之前到达这个状态的路径或方式不同而变化。

怎么理解呢，举个例子，假如子问题在某个阶段的状态确定后，其后续经过若干个决策阶段后可以得到一个最优解，那么不管之前通过何种决策路经，只要在搜索过程中达到这个公共状态，就可以得到最优解，这个结果不会再改变，因此可以记录下来，其他阶段的决策可以直接用状态值表达，不需要再重复计算其后续各个阶段的子问题的状态值。一个问题的最优解可以从其子问题的最优解中得到，那么我们称这个问题具有最优子结构。最优子结构并不是动态规划法独有的要求，很多求解最优化问题的算法都要求子问题的划分满足最优子结构的要求。

用动态规划法设计算法的关键是找出子问题和子问题状态的定义。子问题的状态就是子问题的最优解，当子问题的规模是最终的问题的时候，那么其对应的状态就是问题的最优解。

基于这一思想，通常选择把问题的规模作为状态变量的方式定义子问题。以取硬币问题为例，其问题是取 N 元硬币需要的最小硬币数量。

于是我们就选择“取 i（0 ≤ i ≤ N）元硬币需要的最小硬币数量”作为子问题，并定义状态 d[i] 为取 i 元硬币需要的最小硬币数量。

本课介绍的字符串编辑距离问题，问题的规模有两个，一个是源字符串长度 n，另一个是目标字符串长度 m，于是我们可以选择“长度为 i 的源字符串和长度为 j 的目标字符串的最小编辑距离”作为子问题，并定义状态 d[i,j] 为子问题的解（最小编辑距离）。最终，d[n,m] 就是原始问题的解。

如果大家在尝试用动态规划法设计算法时感到无从下手，不妨尝试一下这种从**问题的规模入手**的方法。

关于子问题以及子问题在某个决策阶段的维度，也是可以用来综合考虑子问题分解的参考方向。比如 0-1 背包问题，第一次接触这个问题很容易将其决策状态理解为装入第 i 个物品时包中物品的总价值，于是将子问题定义为装入第 i 个物品。

实际上这样是不对的，**因为空包的情况下选择第 i 个物品和包中已经装了几个物品后再选择第 i 个物品所产生的状态是不一样的，也就是说对于状态 d[i]，用不同的选择物品的顺序得到的 d[i] 值是不一样的，这就不能满足子问题的无后向性**。之所以出现错误，是因为一个重要的信息没有考虑，那就是选择物品 i 时包的剩余容量，因此子问题的状态应该增加一个维度，即定义状态 d[i,j] 为将第 i 个物品装入剩余容量为 j 的包中所得到的物品价值，对应的子问题就是将第 i 个物品装入剩余容量为 j 的包中。这样增加一个维度，子问题的定义就能满足无后向性。

一个问题经过多个阶段的决策可以得到最优解，这一系列的状态变化可以视为一个决策序列。动态规划的每个阶段的决策，并不要求之前阶段的状态必须是最优的，它只是保证现阶段的决策采用最优的策略，尽力而为得到当前阶段的“最优解”。在动态规划法的状态表中，并不是每个状态都是最优的，但是它把所有的状态都计算了一遍，根据最优子结构的性质，总有一个决策序列最终能得到全局的最优解。所以，动态规划本质上依然是搜索，它会把所有的决策序列都搜索一遍，尽管绝大多数决策序列都不会得到最优解。动态规划的高效体现在对于每个决策阶段的子问题的状态只计算一次，存储结果，当需要再次使用这个子问题时，直接查表，不需要再次求解，不需要再次求解的原因正是因为子问题的无后向性。也正因为如此，动态规划法对那些每个决策阶段都会产生指数级重复子问题的问题特别有效。关于这一点，Kleigberg 在《算法导论》这本书中，对动态规划有如下描述：

> 动态规划法通过将问题细分为一系列子问题，从而隐含地探查了所有可行解的空间，于是我们可以从某种程度上把动态规划看作接近暴力搜索边缘的危险操作。动态规划对子问题的处理方式，使得它可以遍历问题可行解的指数规模的集合，甚至可以在没有明确检查所有解的情况下做到这一点。这是一种对重叠子问题（子问题包含子子问题）处理的内在机制。

理解了这段话的意思，也就能理解动态规划法的实质，即动态规划就是利用子问题的“无后向性”特点，通过递推关系隐含地实现了所有子问题序列的求解，其内在机制也避免了同类子问题的重复求解。如果问题不是线性的，那么即使是动态规划法，也会呈现出类似穷举的广域搜索的效果，即便是没有出现最优解的子问题序列也会被求解。

#### 上楼梯问题

为了更好地理解动态规划法，这里用一个实际的算法例子，从盲目穷举法开始，逐渐过渡到动态规划法。大家可以从这个过程中，理解 Kleigberg 这段话的意思，理解动态规划法。

《算法的乐趣》一书中用了一个“字符串的编辑距离问题”作为例子，但因为问题本身有一定的难度，读者反馈不容易理解。这里我们从《国际大学生程序设计竞赛例题集》这本书中找了一个简单的“上楼梯问题”作为例子，这个问题也是一个非常常见的面试题。

#### 问题提出

小明上楼梯有个习惯，就是一次要么走 1 级台阶，要么走 2 级台阶，有一个楼梯有 20 级台阶，问按照小明的习惯，他有多少种上楼梯的方法。

分析这个问题，我们先试试减小问题的规模。假设楼梯只有 1 级台阶，那么只有一种上楼的方法。假设楼梯有 2 级台阶，那么小明会有 2 种上楼的方法，一种是一次走 1 级台阶，需要走 2 次才能上楼，另一种是一次走 2 级台阶，走 1 次就能上楼。再进一步，假设楼梯有 3 级台阶，此时小明会想，如果我选择先走 1 级台阶，那么楼梯还剩 2 级台阶，对于 2 级台阶的楼梯，此前已经知道有 2 种上楼方法。那么反过来，如果我选择先走 2 级台阶，那么楼梯还剩 1 级台阶，对于 1 级台阶的楼梯，此前也知道只有 1 种上楼的方法。所以，小明分别做这两个选择以后，共有 3 种上楼梯的方法。

楼梯有更多的台阶时怎么办呢？

#### 分治法 + 穷举法

实际上，上一节对 3 级台阶的分析，已经隐含了一个很重要的思想，就是分治法。

对于有 n 个台阶的楼梯，解决的方法就是先选择走 1 级台阶，将剩下的 n-1 级台阶作为子问题求解，然后再选择走 2 级台阶，将剩下的 n-2 级台阶作为子问题求解，两个选择的上楼方法求和，就是 n 个台阶的上楼方法。

对于上楼梯问题 f(n)，可以分解为 f(n-1) 和 f(n-2) 两个子问题，两个子问题的和就是 f(n) 的解：

f(n) = f(n-1) + f(n-2)

实际上，除了分治法，这里面还隐含了穷举法，尽管只是对两种选择的穷举（走 1 级台阶，还是走 2 级台阶），但那也是穷举。

用分治法就会用到递归算法实现，递归算法实现的重点就是递归主体和递归退出条件。很显然，这个问题的递归主体就是上面求 f(n) 的关系式，递归退出条件就是当问题的规模减小到 1 或 2 级台阶的时候，直接返回对应的上楼梯方法。

用分治法解决这个问题的算法实现如下：

```c++
int f(int n)
{
    if(n == 1)//递归退出条件
    {
        return 1;
    }
    else if(n==2) // 递归退出条件
    {
        return 2;
	}
    else //递归主体
    {
        return f(n-1)+f(n-2);
    }
}
```

用分治法结合递归实现的算法代码总是优雅、简单，但是也存在效率低下的问题。

在前面的基础部分介绍过，分治法效率不高的原因在于子问题的重复求解，这种重复求解造成大量不必要的开销。

图（1）展示了当台阶数 n=5 的时候，按照上述分治法分治与求解子问题的过程，可以看到，3 级台阶对应的子问题被求解了 2 次，2 个台阶的子问题被求解了 3 次。随着问题规模（台阶数） n 的增加，重复出现的子问题会更多，重复计算的开销也越大。

![QQ截图20190610180535](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190610180535.png)

#### 动态规划—带备忘录的穷举 + 分治

分治法对子问题的分解方法，不考虑无后向性，因此很多情况下都不适用于动态规划法，但是这个问题例外，我们用楼梯台阶数定义的子问题，适用于动态规划法。

**我们看图（1）中两次出现的 f(3) 状态，其后续的状态演化都是一样的，结果也是一样的，这说明什么问题？**

这说明这个子问题的分解满足无后向性要求，无论之前是通过何种子问题分解途径来到了 f(3) 这个状态（f(3) 对应子问题的解），其结果是固定的，不会因为是从 f(5) 演化过来的 f(3)，就和从 f(4) 演化过来的 f(3) 不一样。

既然子问题满足无后向性要求，那么我们就来解决子问题的重复求解问题。

解决子问题重复计算的方法就是**设置一个“状态备忘录”**，这个备忘录记录每个子问题的状态（对应子问题的解）。因为子问题的解都是大于 0 的整数，所以我们用 -1 表示这个备忘录条目是无效的，也就是这个子问题还没有被求解过。

```c++
int memo[N];
for(int i = 0; i < N; i++)
{
    memo[i] = -1;
}
```

确定好状态备忘录，还要确定边界状态，也就是子问题 f(1) 和 f(2) 的状态是已知的，直接记录到备忘录中即可：

```c++
memo[1] = 1;
memo[2] = 2;
```

有读者会问，memo[0] 好像没用到？是的，memo[0] 不用，放在那里就好了，这样就可以使 memo[1] 与子问题 f(1) 对应，memo[2] 与子问题 f(2) 对应，以此类推，这也是一种常用的技巧吧。接下来就是改造我们的算法，把备忘录的处理加上：

```c++
int f(int n)
{
    if(memo[n] != -1)
    {
        return memo[n];
    }
    
    // 求解子问题，别忘了更新备忘录
    memo[n] = f(n-1) + f(n-2);
    return memo[n];
}
```

动态规划是一种思想，千万不要形而上学地以为动态规划就是子问题的递推关系式。对于多阶段决策的优化问题，只要阶段划分明确，子问题定义清晰且满足无后效性，不管算法实现用何种形式，它都是动态规划。

#### 动态规划—递推关系式

上一节的例子使用备忘录避免子问题重复求解，这是一种显式的剪枝方法。

我们之前提到过动态规划法内在的剪枝机制，实际上是通过直接搜索递推关系式的方式实现的，也就是大家眼中“正统”的动态规划法。

这一节我们直接给出状态递推关系方式的动态规划算法，用这种方法设计算法实现，需要解决三个问题，首先是子问题状态的定义，这个在上一节已经分析过了；

其次是确定递推关系式，递推关系前面也介绍过，假设我们定义子问题的状态是 f[n]，则状态递推关系式就是：

f[n] = f[n - 1] + f[n - 2]

最后是确定边界条件，边界条件就是：

```c++
f[1] = 1   
f[2] = 2
```

最后，典型的用递推关系式实现的动态规划法算法实现如下：

```c++
int dp(int n)
{
    int f[N] = {0};
    
    // 初始化边界值
    f[1] = 1;
    f[2] = 2;
    // 递推求解f[n]
    for(int i = 2;i<=n;i++)
    {
        f[i] = f[i-1] + f[i-2];
    }
    
    return f[n];
}
```

这是一个简单的例子，演示了子问题定义和对子问题无后向性的理解，通过带备忘录的分治法 + 穷举法实现，是大家对动态规划有一个较深入的理解。

读者看到这里，应该理解，凡是对多阶段决策问题有明确的子问题和状态定义，且子问题满足无后向性条件，并能够通过优化解决子问题的重复求解效率问题的方法，都是动态规划法，希望大家对动态规划有更全面的认识

#### 状态递推关系常用的模式

对付动态规划类问题的，首先要做的是识别子问题以及子问题的状态递推关系式。

说直白一点，就是先用分治法的思想看看能不能分解子问题，如果一种方法分解出的子问题不满足无后向性，就换一种方法。

无论读者之前看过多少动态规划的资料，对动态规划的基本原理讲的再头头是道，如果遇到问题不能识别子问题以及子问题的状态定义，也是无用的。

好在动态规划虽然飘逸，但还是有规律可循，前人还是总结了好几种常见的递推关系模式，这些模式都不是我发明的，我只是搬运工，中间结合了我的理解和经验，希望对大家有所帮助。

根据我的经验，这一节介绍的内容第一遍看不懂是很正常的，多看一些动态规划算法实现，特别是它们对状态定义的分析，再回头理解这些模式，就会容易一点。如果还不行，就再多看一些资料，特别是那些对问题分析比较多的文章，不要只关注代码。

#### 来自黑书的内容

动态规划算法有三个要素：

（1）所有不同的子问题所组成的表（它包含的问题数目称为问题的大小，即 size）；

（2）问题解决的依赖关系可以看成是一个图；

（3）填充子问题的顺序（实际上就是（2）所得到的图的一个拓扑排序）。如果子问题的数组为 O(n^t)，且每个子问题需要依赖于 O(n^e) 个其他子问题，则称这个问题为 tD/eD 问题，总结起来可得到四种典型的动态规划关系递推方程（opt 是最优关系，可能是 max，也可能是 min）。

##### **1D/1D**

![QQ截图20190620190955](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620190955.png)

##### **2D/0D**

![QQ截图20190620191412](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620191412.png)

##### **2D/1D**

![QQ截图20190620191502](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620191502.png)

##### **2D/2D**

![QQ截图20190620191540](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620191540.png)

#### 区间动态规划的算法模式

区间动态规划，顾名思义，就是求解一个区间内的某种最优解，这种题目在分解子问题的时候，通常考虑子问题就是其中任意一个子区间，而规划的内容就是如何分解子区间。无论题目内容怎样，算法的实现模式基本上就是一个如下所示的三重循环。

```c++
for(区间长度 size：从最小可分区间开始到最大区间长度)
{
    for(小区间起始位置 i：从第一个位置开始到区间长度 size 所决定的结束位置)
    {
        j = i + szie - 1; //j 定义区间结束位置，具体计算方法因问题而异
        for(区间分割点位置 k：从 i 开始到 j 结束)//遍历所有区间 [i,j] 内的位置，将其分割为两个小区间
        {
            f[i][j] = max(f[i][j],f[i][k]+f[k][j] + 某种最优值计算方法)
            或
            f[i][j] = min(f[i][j],f[i][k]+f[k][j] + 某种开销计算方法)
        }
    }
}
```

第一重循环枚举区间的大小，一般是从最小可分解区间开始，直到最大区间长度。为什么枚举区间长度要从“最小可分解区间”开始呢？因为区间长度太小的话，不满足题目的分解区间要求，后续的处理也没有意义。具体的“最小可分解区间”的值，因题而异，比如三角形组合问题，最小区间长度至少是 3 条边才行，否则连一个三角形都凑不齐，后续还怎么处理？对于经典的“石子合并”问题，区间长度就是石子的堆数，要能够合并，至少要 2 堆石子吧，所以石子堆数就从 2 开始枚举。

实现模式的第二重循环是对区间内的起始位置开始枚举。第一重循环给定了区间的大小（范围）；第二重循环就尝试从**区间的不同位置开始定义子区间**。举个简单的例子，假设第一重循环给定了区间长度是 5，则第二重循环要处理的最大区间就是 [1,2,3,4,5]，第二重循环的作用就是分别尝试定义子区间，共可得到 5 个子区间： [1,2,3,4,5]、[2,3,4,5]、[3,4,5]、[4,5] 和 [5]；第三重循环就是尝试对每个子区间分解，假设前两重循环选择了第二步分解的 5 个子区间中的第 2 个子区间，也就是 [2,3,4,5]，则 k 的值就是从 2 到 5，拆分子区间，共得到三组拆分结果：[2] 和 [3,4,5]、[2,3] 和 [4,5]、[2,3,4] 和 [5]。对于每一组拆分结果，计算状态值：

```
state1 = f[2][2] + f[3][5] + 根据当前 k=2 的分解得到的某种最优值（或开销值） 
state2 = f[2][3] + f[4][5] + 根据当前 k=3 的分解得到的某种最优值（或开销值）
state3 = f[2][4] + f[5][5] + 根据当前 k=4 的分解得到的某种最优值（或开销值）
```

然后将三个 state 分别与 f 2 5 比较，根据题目的要求，用最优值更新 f 2 5 的值。当全部三重循环都完成后，题目要求的解就在 f 1 n 中。

这就是区间动态规划的解题思路和实现模板，如果还不理解也没关系，后面我们会介绍几个区间动态规划的例子，结合例子再来理解这里的解题模式就可以了。

#### 总结

这一课，我们用一个简单的上楼梯问题作为例子，从简单穷举法开始，通过明确子问题的最优子结构，逐步过渡到带备忘录的穷举法和有递推关系驱动的高效动态规划法实现，帮助大家体会动态规划的设计思想。虽然动态规划的概念很抽象，但是只要确定问题的实质，理解动态规划法的思想，按照动态规划法的要求确定子问题和子问题最优解的递推关系，准确识别边界条件，设计动态规划法的算法也不是一件很困难的事情。

这一课，我们还介绍了典型的动态规划问题的几种常见递推关系式模型，还有区间动态规划的典型算法实现模式。

这一课，你还应该知道，并不是只有用递推关系式的方式实现的代码才是动态规划，只要子问题满足无后向性，用辅助备忘录的形式也是动态规划。根据我玩 OJ（Online Judge）算法的经验，一些问题如果最优解递推关系式不明显，直接编写代码有困难，可以尝试用分治 + 穷举的方法，只要子问题满足无后向性要求，用辅助备忘录的形式消除子问题的重复求解开销，基本上都能满足 OJ 题目对运行时间的要求。



### 4-2 装配线与工作站问题

>在前面的内容中，我们介绍过用穷举法设计“装配线与工作站问题”的算法实现，这一课我们将介绍如何用动态规划法设计这个问题的算法实现。
>
>两种不同的设计思想它们的算法实现肯定也是相差千里，穷举法中的遍历过程需要算法代码显式控制，而动态规划法的遍历过程则是算法本身隐含的，说具体一点，就是隐含在状态递推的过程中。
>
>在开始本课的内容之前，请大家再回忆一下[第4-1课]的内容，用动态规划思想设计算法实现，需要明确的三个问题：**子问题与决策阶段状态的定义、状态递推关系式、边界条件**。

#### 问题回顾

为了便于理解本课的内容，在开始算法分析之前，再回顾一下这个题目：Colonel 汽车公司在有两条装配线的工厂内生产汽车，一个汽车底盘在进入每一条装配线后，在每个工作站会在汽车底盘上安装不同的部件，最后完成的汽车从装配线的末端离开，如图（1）所示：

![QQ截图20190620193746](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620193746.png)

每一条装配线上有 n 个工作站，编号为 j=1,2,…,n，将装配线 i（i 为 1 或 2）的第 j 个工作站表示为 S(i,j)。装配线 1 的第 j 个工作站 S(1,j) 和装配线 2 的第 j 个工作站 S(2,j) 执行相同的功能。然而这些工作站是在不同的时间建造的，并且采用了不同的技术，因此，每个工作站上完成装配所需要的时间也不相同，即使是在两条装配线相同位置的工作站也是这样。把每个工作站上所需要的装配时间记为 a(i,j)，并且，底盘进入装配线 i 需要的时间为 e(i)，离开装配线 i 需要的时间是 x(i)。

正常情况下，底盘从一条装配线的上一个工作站移到下一个工作站所花费的时间可以忽略，但是偶尔也会将未完成的底盘从一条装配线的一个工作站移到另一条装配线的下一个工作站，比如遇到紧急订单的时候。假设将已经通过工作站 S(i,j) 的底盘从装配线 i 移走所花费的时间为 t(i,j)，现在的问题是要确定在装配线 1 内选择哪些工作站以及在装配线 2 内选择哪些工作站，以使汽车通过工厂的总时间最小，如图（2）所示，最快的时间是选择装配线 1 的 1、3 和 6 号工作站以及装配线 2 的 2、4 和 5 号工作站。

![QQ截图20190620193833](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620193833.png)

根据题目的意思，汽车底盘即使选择一条装配线不换，从第一个工作站移动到最后一个工作站，也能完成安装，但是这样所花费的时间可能不是最短的。如果另一条装配线上的某个工作站效率比较高，那么装配到这一步的时候，换到那条装配线上进行装配肯定会节省时间，但是考虑到从一条装配线移动到另一条装配线也需要花费时间，那就要综合考虑了。“移”还是“不移”？这再次成为问题。

#### 子问题和决策阶段状态的定义

![QQ截图20190620194334](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620194334.png)

这个问题看似是求每个装配站完成对应工序的装配需要的最短时间，但感觉应该是个线性动态规划问题。

我们讲过很多这样的问题，一般用 f[j] 表示第 j 个决策阶段的状态，对于这个问题，具体的子问题就是第 j 个工作站完成装配的最小花费时间，f[j] 就表示这个时间。

很可惜，这个问题不是普通的线性动态规划，因为它有两条装配线。对于两条生产线上的第 i 个工作站来说，用一个 f[j] 无法表示，并且子问题不能满足无后向性。那么按照第 4-1 课中给的方法，给这个子问题增加一个决策维度如何呢？不妨试试用 f[i] [j] 表示第 i 条生产线的第 j 个装配站完成装配需要的最小花费时间，其**子问题就是“汽车底盘在第 i 条生产线的第 j 个工作站完成安装”**。

事实上，这样做是可以的，但是增加的这个维度将动态规划搜索的时间复杂度从 O(n)变成了 O(n^2)。事实上，如果问题的规模是 m 条装配线，那么用这个状态和子问题的定义方式完全没有问题，因为问题的时间复杂度本身就是 O(n^2)。

对于本题只有两条生产线的情况，《算法导论》这本书给出了一个解决策略，使得问题的时间复杂度仍然是 O(n)级别。具体方法就是为每条装配线定义一个决策状态，分别用 f_1[j] 和 f_2[j]表示，然后对两条装配线分别规划最优解。如图（3）所示，对于第一条装配线来说，通过装配站 S(1,j) 的最小时间开销为以下两个装配方法中所花费时间较小的那种方法：

- 从装配站 S(1,j-1) 直接通过装配线 S(1,j) 完成装配
- 从装配站 S(2,j-1) 移到装配线 1 上，再通过装配线 S(1,j) 完成安装

![QQ截图20190620195012](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620195012.png)

#### 状态递推关系和边界值

上一节对子问题决策状态的分析过程中，实际上已经给出了决策状态的递推关系式，现在看看递推的边界值怎么确定。

很显然，这个问题的边界值其实就是汽车底盘开始装配和结束装配两个时间点。对于第一条装配线，S(1,1) 完成装配需要的时间开销是将底盘移入第一条装配线的移动时间和 S(1,1) 装配站的装配时间之和，同样，对于第二条装配线，S(2,1) 完成装配需要的时间开销是将底盘移入第二条装配线的移动时间和 S(2,1) 装配站的装配时间之和。

![QQ截图20190620195156](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620195156.png)

结束装配时的边界值其实就是问题的解，因为根据最优子结构的性质，最终 *f*1[*n*] 是通过第一条生产线的最后一个装配站的最快时间，f2[n] 是通过第二条生产线的最后一个装配站的最快时间，最后移出装配线的最小时间开销就是：

![QQ截图20190620195258](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620195258.png)

其中，x[1] 是将底盘从第一条装配线移出的时间开销，x[2] 是将底盘从第二条装配线移出的时间开销。

#### 算法实现

“兵马未动、粮草先行”，开始算法代码的实现之前，先要设计好**数据模型**，使得算法实现中可以方便地存取各种需要的数据。大多数算法题目，都可以将数据模型分为程序原始数据和结果数据两部分，在设计数据模型的时候可以将它们分开考虑。程序原始数据是算法题目中给出的各种参数，需要将其转化为数据模型，本题的原始数据非常简单，直接照搬描述就可以了，不需要细化讨论了。

```c++
typedef struct
{
    int a[LINES][STATIONS];
    int t[LINES][STATIONS];
    int e[LINES];
    int x[LINES];
}Program_T;
```

结果数据存放算法运算的结果和必要的中间过程数据，运算结果通常是题目要求的解。本题的结果数据包括各个阶段的决策状态中间过程和最优解的决策过程：

```c++
typedef struct
{
    int line[STATIONS];  //遍历过程中的最优决策
    int ls;
    int f[LINES][STATIONS];  //当前已知的决策状态
    int fs;  //最优解的值
}Result_T;
```

用动态规划法设计算法的三部曲是：**初始化边界值、用合适的程序结构实现递推关系求解和计算最优解并给出最优解的决策过程（如果有必要的话）**。根据程序算法的特点，我们用 0 作为第一个装配站的编号，则初始化边界值的代码就是上一节完整递推关系式中 j=1 的情况，给第一个装配站赋值，翻译成代码就是给 f[0] [0] 和 f[1] [0] 赋值，接着是根据递推关系式依次计算各个装配站对应的最优决策状态值，直到计算出最先有一个装配站的结果 f[0] [n-1] 和 f[1] [n-1] 为止，最后是根据 f* 的计算公式得到最终的最优解。

根据递推关系式的特点，用代码实现递推关系计算可以采用循环结构，循环起点是从第二个装配站到最后一个装配站，即：

```c++
for(int j = 1; j < STATIONS; j++)
```

动态规划类的问题，往往还需要保存最优解递推计算过程中的决策过程，以便于在得到最优解后能反向追踪其决策过程，目的是满足题目要求输出决策结果的要求。本题要求的决策结果是给出汽车底盘在各个装配站上的转移过程，用数据语言描述就是需要记录对于每一个装配站，最优决策选择的是第一条装配线还是第二条装配线。`Result_T` 中用二维数组 line 记录决策过程，line 数组的每个元素值是装配线的编号，简单理解就是对于第 i 条装配线的第 j 个装配站来说，它的最优决策的上一个装配站，即第 j-1 个装配站来自 line[i] [j] 中记录的装配线上。`fast_station_sequence()`函数是算法的完整实现，该解释的基本上都解释过了。对于 line 决策过程的回放处理代码在`print_result()`中，注意这是倒着输出结果的，你需要把脖子拧一下反着看。如果想按照正向的顺序输出决策过程，很多情况下都要用到递归，实现起来并不困难（几行代码），就留给读者自己完成吧。

```c++
void fast_station_sequence(Program_T *para, Result_T *result)
{
    //初始进站化边界值
    result->f[0][0] = para->a[0][0] + para->e[0];
    result->f[1][0] = para->a[1][0] + para->e[1];

    //递推关系计算
    for(int j = 1; j < STATIONS; j++)
    {
        if((result->f[0][j - 1] + para->a[0][j]) <= (result->f[1][j - 1] + para->t[1][j] + para->a[0][j]))
        {
            result->f[0][j] = result->f[0][j - 1] + para->a[0][j];
            result->line[0][j] = 0;
        }
        else
        {
            result->f[0][j] = result->f[1][j - 1] + para->t[1][j] + para->a[0][j];
            result->line[0][j] = 1;
        }
        if((result->f[1][j - 1] + para->a[1][j]) <= (result->f[0][j - 1] + para->t[0][j] + para->a[1][j]))
        {
            result->f[1][j] = result->f[1][j - 1] + para->a[1][j];
            result->line[1][j] = 1;
        }
        else
        {
            result->f[1][j] = result->f[0][j - 1] + para->t[0][j] + para->a[1][j];
            result->line[1][j] = 0;
        }
    }
    //计算离站边界值
    if(result->f[0][STATIONS - 1] + para->x[0] <= result->f[1][STATIONS - 1] + para->x[1])
    {
        result->fs = result->f[0][STATIONS - 1] + para->x[0];
        result->ls = 0;
    }
    else
    {
        result->fs = result->f[1][STATIONS - 1] + para->x[1];
        result->ls = 1;
    }
}

void print_result(Result_T *result)
{
    std::cout << "Total Time " << result->fs << std::endl;

    int i = result->ls;
    std::cout << "Station " << STATIONS << " on Line " << i + 1 << std::endl;
    for (int j = STATIONS - 1; j > 0; j--)
    {
        i = result->line[i][j];
        std::cout << "Station " << j << " on Line " << i + 1 << std::endl;
    }
}
```

#### 总结

这一课我们使用动态规划法实现了对“装配线和工作站”问题的算法设计，演示了动态规划三部曲的思考和分析过程。希望读者看完这一课的内容，能够再掌握一种动态规划类型的算法问题分析求解方法，并且对动态规划法能够有更深入的理解。



### 4-3 凸多边形最优三角剖分问题

>凸多边形上的最优三角剖分问题也是动态规划经典题目，此类问题基本上都是在一个给定的凸多边形上规划三角形分割，使得剖分后得到的一系列三角形的某种结果最优，比如三角形的面积之和最大（或最小），或者是三角形的各边权重之和最大（或最小）等等。
>
>这一课，我们要介绍的题目是要求根据三角形的权重之和最小来剖分多边形，结合这个题目，希望大家能掌握如何分析此类问题，并用动态规划的方法设计出求解此类问题的算法实现。

#### 子问题的定义

先来解释一下题目中提到的“三角形权重之和”是什么意思。边的权是图论中的一个很重要的概念，实际上就是为边赋予一个人为指定的属性，常用来表示边代表的两点的距离，或者两点之间的各种开销。这个题目中说的权实际上更简单，就是多边形每条边的一个附加属性。一个三角形的权重就是组成三角形的三条边的权重之和，而题目中的“三角形权重之和”表示的是多边形拆分成的一系列小三角形的权重之和。

如图（1）所示，把一个凸多边形分割成多个三角形有多种剖分形式，根据题目给出的条件，每种分割方法得到的三角形的权重之和也各不相同。用动态规划方法解决算法问题，首先要确定子问题和各决策阶段状态的定义，然后是给出最优子结构的性质。每个决策阶段的状态，实际上就是子问题在这个决策阶段的解，这个阶段的最优解一般是根据最优子结构的性质由之前各阶段的解和当前的最优决策堆叠出来。所以，用动态规划法解决算法问题的关键是识别出子问题并给出决策状态的定义。

![QQ截图20190620205557](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190620205557.png)

《如何理解动态规划法》这一课我们介绍可一种分析定义子问题的方法，就是确定问题的规模，**通过缩小问题规模的方式确定子问题**，这里不妨应用一下。

首先看问题的解，问题的解是按照三角形剖分后的多边形具有最小的三角形权重和，这句话有点拗口，我们就用多边形的最小权重这个概念来代替前面那句话。那么在某个决策阶段的子问题的状态就是当前子问题定义的多边形（规模较小的多边形）的最小权重，于是缩减问题的规模就是选择多边形中的某几个点组成一个小多边形（子多边形）。

既然原始问题中多边形是由 N 个顶点，那么子问题是否可以定义为“由 i 个点组成的多边形”，其中 i 的取值范围是：0⩽*i*⩽*N*，用状态 d[i] 表示由 i 个顶点组成的多边形的最小权重值。

请大家思考一下，这样定义子问题是否合适？显然不合适，因为这样定义的子问题不满足无后向性，为什么这么说呢？举个“栗子”，请看图（1）中的多边形例子，由 *V*0、*V*1 和 *V*2 三个点组成的子问题的状态 d[3] 和由 *V*4、*V*5 和 *V*6 三个点组成的子问题的状态 d[3] 在后续的状态演化过程中的结果肯定不一样，那就意味着虽然之前的搜索通过两个不同的路径都到了 d[3] 状态，但是却是两个不同的 d[3]，其后续得到的结果也不一样，这就不满足无后向性原则了。

**按照无后向性原则，不管之前通过什么途径到了 d[3] 状态，其后续演化的结果应该是不变的**。

这样定义子问题的错误在于只看到了问题规模的一部分，没有看到问题的全部。对于凸多边形问题，因为任意两个顶点之间的边的权重是不一样的，所以每个顶点之间都是不一样的，不同简单地只关注顶点的数量。**基于这一点考虑，子问题中除了应该含有顶点数量的信息，还应该包含顶点信息**。

如果原始问题的规模是“由顶点 *V*0 到 *V*7 组成的多边形”，那么子问题可以考虑成“由顶点到 Vi 到  Vj 组成的多边形”，其中 i 和 j 的范围是：1 ⩽*i*<*j*⩽*N*−1，这样定义的子问题既考虑了顶点的数量，又包含了顶点信息。既然子问题需要两个变量描述，那么我们考虑子问题的状态用 d[i] [j]表示子问题“由顶点 Vi到 Vj 组成的多边形”的最小权重。当然，这样定义子问题的前提是要求多边形的顶点从 i 到 j 之间的顶点是连续的，但这并不妨碍我们解决这个问题。

在分割多边形子问题的时候，只要保证顶点 i 和顶点 j 之间的连线始终是分割三角形的一条边，就可以使得被此三角形分割的两个小多边形的顶点也是连续的，大家可以参考图（2）的最优子结构示意图来理解这一点。

为什么说做了这个约束仍然不影响对问题的解决呢？

**原因就在于动态规划法对这个问题的解决思想本质上还是遍历**，对每个子多边形的遍历有多种顺序，但是**只要按照一种顺序遍历就可以了，不需要处理所有的遍历顺序，因为它们最终都会在遍历其他子多边形的时候被重复遍历到**。所以我们要求子多边形的起始点必须是分割三角形的一条边其实是约定了一种遍历顺序，被忽略的其他顶点之间的边会在遍历其他子多边形的时候被处理，并不会漏掉任何一种状态。

当然，这个约束条件也简化了算法程序的实现难度，毕竟用二维数组直接表示一个状态，要比用顶点的集合映射一个状态要简单很多。

#### 子问题最优子结构

定义了子问题，接下来就要分析最优子结构的性质了。所谓最优子结构的性质，其实就是确定是否能找出一种决策方法，该方法能够根据前一个阶段或前几个阶段的子问题的状态，通过某种策略或方法得到当前阶段的状态，并使得当前的状态是最优的。

我们首先假设在某个决策阶段的一个三角形分割形式如图（2）所示，当前要决策的状态是 d[1] [7]（后面会解释为什么这个状态是 d[1] [7]，而不是 d[0] [7]），由 V0 和 V7 两个顶点组成的边，可以和其他 6 个顶点（*V*1−*V*6）中的任意一个组成一个三角形，从而将多边形分割成一个三角形加上两个小多边形的状态

![QQ截图20190621101019](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621101019.png)

#### 状态递推关系和边界值

![QQ截图20190621101303](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621101303.png)

![QQ截图20190621101444](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621101444.png)

### 算法实现说明

既然是**区间动态规划**，实现上基本上就是《如何理解动态规划法》里提到的三重循环模式，对照这个模式，很容易就可以做出代码实现。

第一层循环穷举的是子多边形的规模，毫无疑问，子多边形最少有两个顶点（不包括编号是 0 的顶点），最多则是 N-1 个点（同样不包括编号是 0 的顶点），第一层循环遍历子多边形规模：

```c++
for (int r = 2; r < N; r++)
```

对于每种规模的子问题，还要进一步确定子多边形包含哪些顶点，这也是一层遍历，多边形起点 Vi 从 1 开始遍历，终点 Vj则由起始点和子多边形规模r决定，这是第二层遍历：

```c++
for (int i = 1; i < N - r + 1; i++)
int j = i + r - 1;  //确定 Vj,r 是子问题规模
```

对于已经确定的子多边形 \{ V_{i},...V_{j}}继续遍历顶点 k，根据递推公式计算状态值，并选择最小的一个作为子多边形的权重，这也是递推表达式中那个 min 的体现。k 的取值是从 i 到 j（不包括 j），这是第三层循环：

```c++
for (int k = i; k < j; k++)
```

完整的算法实现请参考 polygon_triangulation() 函数的代码，需要说明一下 RESULT 数据结构的定义。d[N] [N] 是记录子问题的决策状态，和之前分析的递推关系一致，k[N] [N]是个稀疏矩阵，主要是记录子多边形 \{ V_{i},...V_{j}\}最终选定的作为最优分割的顶点 k。记录这个 k 值的目的是为了最后能反向回溯整个决策过程，输出三角形剖分的结果，毕竟 d[1] [N-1] 中只是记录了最优的权重值。

```c++
typedef struct
{
    int d[N][N];  //d[i][j] 表示多边形 {Vi - Vj} 的最优权值
    int k[N][N];  //k[i][j] 记录 Vi 到 Vj 最优三角剖分的中间点 K
}RESULT;
void polygon_triangulation(RESULT *result)
{
    int min_d;

    //初始化边界值
    for (int m = 1; m < N; m++)
    {
        result->d[m][m] = 0;
    }

    //开始规划
    for (int r = 2; r < N; r++) //子多边形规模遍历
    {
        for (int i = 1; i < N - r + 1; i++) //子多边形遍历，确定起始点 Vi
        {
            int j = i + r - 1;  //确定 Vj,r 是子问题规模
            //遍历从 Vi 到 Vj 的点（不包括 Vj）, 找最小权重值分割的k点
            min_d = INFINITE; 
            for (int k = i; k < j; k++)
            {
                //递推计算
                result->d[i][j] = result->d[i][k] + result->d[k + 1][j] + triangle_weight(i - 1, k, j);
                if (result->d[i][j] < min_d) 
                {
                    min_d = result->d[i][j];
                    result->k[i][j] = k;  //记下这个分割点
                }
            }
            result->d[i][j] = min_d;
        }
    }
}
```

用动态规划方法设计算法，如果只考虑各个决策阶段的状态，最终只能得到一个最优的解（最终的状态），要想得到决策结果，就需要在动态规划决策过程中，记录决策点信息，并在算法结束后输出这些决策点信息，这是动态规划算法设计需要考虑的细节。对于本问题，决策信息就是每次根据子问题 \{ V_{i},...V_{j}\}选择的那个 k 点，我们把这个点的位置记录到 k[i] [j] 中，最后反向搜索一下 k[N] [N]，逐个找出各个阶段的决策点信息，并输出出来，形成最终的决策结果。

是的，这是个递归实现，大家可以用前面介绍的递归程序设计方法理解这个算法实现，记住无非就是递归三要点。

```c++
void trace_result(RESULT *result, int i, int j)
{
    if (i == j)
    {
        return;
    }

    trace_result(result, i, result->k[i][j]);    //输出一个子多边形的剖分结果
    trace_result(result, result->k[i][j] + 1, j);    //输出另一个子多边形的剖分结果
    
    //输出当前三角形，k[i][j]是动态规划去搜索过程中记录下的最优剖分点
    std::cout << "triangle: { V" << i - 1 << " V" << result->k[i][j] << " V" << j << " }" << std::endl;
}

trace_result(&result, 1, N-1); //递归输出决策结果
```

### 总结

我一直说动态规划是一种高效的穷举搜索算法，在这个例子中再次得到了印证。从第二节的分析可以看到，选择当前阶段最优解的时候，是先选择一条边，然后把除这条边之外的所有其他顶点都遍历了一遍，分别与这条边构造成一个三角形，并把多边形分成两个小多边形，最后从这些遍历得到的子问题的分解关系中选择权值最小的那个分解方式作为这个阶段的最优解。

凸多边形的最优三角形剖分问题都可以用本课给出的算法框架求解，只需做很少的修改。假如问题变成求剖分后的三角形面积最大的剖分方式，则只需将计算三角形权重的函数改成计算三角形面积的函数，同时将递推关系中的选择最小值的处理改成选择最大值的处理就可以了。根据边长计算三角形面积可以使用海伦公式，这里就不赘述了。



### 4-4 状态压缩与动态规划

动态规划问题中重要的一环就是确定状态的定义

在大多数情况下，状态中所包含的信息并不多，比如**线性规划问题的状态一般表示为 d[i,j]（i 表示状态的位置，j 表示状态的阶段）**，算法实现时可用二维数组保存计算过程中的状态。

但是也有一些问题，它的状态中包含的信息很多，比如它的状态可能是一个集合中各个元素的情况，或者是像铺瓷砖问题这样，是某一行的覆盖状态。如果沿用简单的状态表示方法，则可能会用到 N 维数组，这样不仅空间占用大，而且状态的转移（状态递推公式）算法也会非常复杂。不信？读者猜猜这个状态 d[i,j,k,l,m,n,o,p,q,r,s,t] 的下一个状态是什么，是 t + 1 还是 q + 1 ?

在这种情况下，如果我们能用一种编码策略，将前面例子中的 j, k, l, m, n, o, p, q, r, s, t 编码成一个整数数字，就可以将状态简化成 d[i, encode(j, k, l, m, n, o, p, q, r, s, t)]，这种情况下就可以用二维数组来保存状态，并且状态的递推公式也会简单很多。这种策略看起来好像状态被“压缩”了，所以被称为**状态压缩动态规划**。

#### 状态压缩和动态规划

严格来说，状态压缩是状态压缩，动态规划是动态规划，是算法模式，它们只是碰巧一起发生了而已。

这种通过某种编码和解码方式将某些离散的信息（比如集合中各个元素的状态）转化成某种简单数值类型进行计算和处理的方法，在很多算法中都有体现，并非状态规划独有的方法。

最常见的就是各种 hash 算法，**通过比较 hash 值的方法比较原始数据的差异要比直接比较原始数据简单高效**。

根据解题的经验（很多资料都是这么认为的），当一个题目具有以下两个特征的时候，就要考虑是否可以使用状态压缩动态规划方法了。

- 数据规模的某一维或某几维非常小。比如 N x M 平面上铺瓷砖问题，大多数情况下给出的题目规模都是类似这样的：N ≤ 5，M ≤ 1000，或 N ≤ 150，M ≤ 10。
- 题目满足动态规划特有的最优化原理和无后向性子问题描述，换句话说就是，我一看这就是个动态规划题目。

第二个特征说的识别就比较虚了，能不能一眼看出来，主要还是靠经验。没别的方法，就是刷题，题目做的多了，遇到问题就会发现脸熟的概率变大了，到那时候差不多一看就能看出来了。

#### 状态压缩的常用方法

状态压缩的方法取决于问题自身的特点，通常根据需要选择合适的编码和解码方法，这一节我们介绍几种常见的状态压缩方法。

#### 整数比特位方式

**如果问题在某些维度上的状态是开关量（0 是一个状态，1 是一个状态，没有其他状态），就可以考虑将这些维度上的状态压缩到一个整数中，整数的每个比特位对应一个状态**。

一般这时候状态的数量都不多，16 位整数或 32 位整数就可以存储这些状态。旅行商（TSP）问题中每个城市有两个状态，假设已经走过的城市标记为 1，没有走过的城市标记为 0，就可以用一个整数 S 表示所有城市的遍历状态，则遍历到第 i 个城市时的状态可以描述为：

![QQ截图20190621103228](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621103228.png)

```c++
S = S ^ (1 << i)；
```

这种压缩方法常用的其他比特位操作方法有：

```c++
if ( ((1 << (i - 1)) & S) > 0)  //判断第 i 位是否是 1

S = S | (1<< (i - 1))   //将第 i 位设置为 1
```

#### 整数分段方法

将一个整数按照位数分段，每一段存储一个状态值的方法，就是整数分段方法。

假如一个问题有三个状态，每个状态的值都不会超过 99，就可以按照整数分段的方法压缩这三个状态。

比如用个位和十位存放一个状态，用百位和千位存放一个状态，用万位和十万位存放一个状态，这种状态压缩的编码方法可以简单表示为：

```c++
S = i * 10000 + j * 100 + k; //状态编码

i = S / 10000;  //解码
j = (S % 10000) / 100;
k = S % 1000000;
```

用 100 来分段是我举的例子，我还没见过单个状态的变化有这么多的（超过 10）的情况，我遇到过单个状态变化是个位数的情况，用 10 来分段，也就是每个十进制数字的位表示一个状态。

#### 二进制位分段方法

二进制分段方法和整数分段方法的机制类似，只不过分段的方式更细化一点，按整数比特位分段其实就是二进制分段的一种极端形式。

如果一个问题的某些单个状态变化不超过 4 个状态，就可以用 2 个比特位表示一个状态；如果问题的单个状态变化不超过 8 个状态，就可以用 3 个比特位表示一个状态，以此类推。最后通过比特位移位将这些状态组装到一个位宽足够的整数中，如果 32 位整数不够就用 64 位整数。64 位都不够用的情况我没遇到过，一般出题的人都会考虑这些情况的，不会让你陷入困境，如果真的遇到了，请优先考虑你的方法是不是错了。

这种方式需要熟练使用各种位操作，基本上 C++ 和 Java 都支持常见的位操作，比如 &、|、^、<< 和 >>。下面以两个比特位分段为例，演示几个常用的操作：

```c++
S = (i & 0x00000003) << 4;  //编码
S |= (j & 0x00000003) << 2;
S |= (k & 0x00000003);

S = S | ((i & 0x00000003) << 4);   //设置状态 i 
i = ((S >> 4) & 0x00000003); //取状态 i
```

### 总结

因为下一课要介绍铺瓷砖问题，这是状态压缩问题的经典例子，这个例子还是比较简单的，但是要解释状态压缩需要的篇幅超过了介绍问题本身，感觉有点头重脚轻，所以将状态压缩部分拿到这里单独介绍，希望大家看了之后，对状态压缩动态规划能有更深的理解。



### 4-5 铺瓷砖问题

>铺瓷砖、铺地板、在电路板上嵌入芯片等问题，都属于一类问题，基本上可以描述为在一个 N × M 的平面空间中摆放一些形状固定的物品，要求覆盖整个平面空间，问有多少种摆放方法。
>
>在某些情况下还会增加一点难度，比如在平面上标记一些位置为“坏”点，摆放物品时要避开这些位置等。**这类问题传统上是使用状态压缩的动态规划方法解题**，因状态递推关系复杂，常用深度优先搜索（DSF）辅助状态的遍历。近些年也流行使用轮廓线动态规划方法求解，但其本质上还是状态压缩。这一课我们就用传统的状态压缩动态规划方法解决铺瓷砖问题。

#### 问题分析

铺瓷砖（地板）问题通常以格子为单位给出 N × M 这样的类似棋盘的平面空间，通常 N 或 M 中的一个明显小于另一个

比如本课要讲的题目：有一块面积为 N × M （N ≤ 6、M ≤ 500）的房间，现在有面积为 1 × 2 和 2 × 1 的地板无数个，要给整个房间铺上地板，有多少种铺地板的方法？题目给出了一个例子，就是当 N = 4、M = 2 的情况，共有 5 种铺法：

![QQ截图20190621161856](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621161856.png)

当看到题目中给出的某个维度明显偏小的时候，就应该知道这可能要用到**状态压缩**了。

为什么这么说呢？因为题目的状态往往是呈几何级数增加的，以铺瓷砖问题为例，状态个数是 2^N个，如果 N 太大，用于表示压缩的状态的维度会变得非常大，大到失去状态压缩的意义，出题的人会考虑到这一点的。

状态压缩不一定必须配合动态规划方法，很多算法实现都会用到状态压缩的思想，但是在算法题目上遇到这种情况，基本上 90% 的概率是要用状态压缩的动态规划方法了。

![QQ截图20190621161928](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621161928.png)

#### 状态定义

假设 N 是两个条件中数值较小的那个，如图（2）所示是建立行和列的模型。

从图（2）可以看出，在第 i 行铺地板，其铺设状态只受第 i 行和第 i − 1 行铺设状态的影响，与其他行的状态无关。当考虑在第 i 行、第 j 列铺设地板时，会遇到两种情况，第一种情况是位置 [i,j] 是空的，没有被覆盖。此时可以选择用 2 × 1 形状的地板竖着铺，如图（2-a）所示，也可以选择用 1 × 2 形状的地板横着铺，如图（2-b）所示。第二种情况是位置 [i,j] 已经被覆盖，因为前一行竖着铺的地板已经覆盖了这个位置，如图（2-c）所示。

无论位置空还是不空，每一行都有 N 个状态（对应 N 个位置）可以决定这一行的地板铺设。

如果用动态规划法解决这个问题，状态的定义要包含行的信息 i ，还要包含这 N 个位置的状态，其状态模型应该是这个样子的：

![QQ截图20190621164339](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621164339.png)

对于这么多状态的维度，**数据模型要用到 N + 1 维数组来存放状态**，不仅空间巨大，而且状态递推关系（状态转移方程）也会非常复杂，算法实现也很困难。这时候就要用到状态压缩了，观察图（2），每一行地板的覆盖状态如果用 0 和 1 表示（等会儿解释为什么会有 0 ），呈现一个由 0 和 1 组成的序列。当 N = 6 的时候，序列长度就是 6，比如第一行是 <110011>，第二行是 <001111>。

我们采用按整数比特位方式压缩这些由 0 和 1 组成的状态序列，将其视为二进制整数，并转化成 10 进制数表示，第一行的状态 110011 对应的压缩后的状态就是 51（0 × 33），第二行的状态 001111 对应压缩后的状态就是 15（0 × 0F）。6 位二进制数组成的状态空间总共有 64个（2^N），不算太大（这就是题目给出的 N 都是很小的值的原因，太大了这里也会膨胀），状态定义处理起来也就简单很多了。压缩后的状态模型就变成了这个样子：

![QQ截图20190621165741](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621165741.png)

对于这样一个压缩后的状态 state 值，可以使用位操作很方便地计算出对应位置的占用情况，比如将其与 0 × 00000001 进行与操作，得到的结果就是 state 对应的这一行的第 1 列的占用情况。状态递推计算时，只要改变对应的位的值，就可以得到一个新的状态，使得递推关系式的计算也非常简单。

#### 状态转移

状态压缩后的状态模型是 d[i, state]，这个状态表示什么意义呢？**d[i, state] 表示的意义是当第 i 行的状态变成 state 的时候，已经有多少种铺地板的方法**。

d[i, state]的值受第 i − 1 行的状态（prev）和本行的铺地板动作共同影响，第 i − 1 行总共有 2^N个状态（其实每一行都有这么多状态），可能存在多个不同的 prev 状态通过变化（横着铺、竖着铺或者不铺）都变成 state 状态的情况，所以要对所有变换成 state 状态的情况求和。

根据以上分析，完整的递推关系式（状态转移方程）就是：

![enter image description here](https://images.gitbook.cn/accae110-eb9d-11e8-9425-4353d4a3006e)

这个状态递推关系式有一个关键点，那就是前一行有多个状态都可能演变成第 i 行的 state 状态，这是理解这个状态转移方程的核心点。

**好了，现在说说为什么同样是覆盖了地板，有的位置是 0、有的是 1 的问题**。这其实是与状态变换有关，当几个 prev 状态都能产生新的 state 状态时，怎么知道这个 state 到底是上一行横着铺产生的，还是竖着铺产生的？这就引入了 0 ，如图（2）所示，当在某一行的一个位置横向铺了一块地板的时候，我们将当前位置和当前位置的下一列（同一行）的位置都设置为 1，表示位置已经覆盖了地板。当在某一行的一个位置竖向铺了一块地板的时候，我们将这个位置设置为 0。

注意，此时仅仅是将这个位置设为 0，并不设置下一行对应列的状态；当处理到下一行的时候，如果发现它的上一行对应位置是 0，我们就知道这是上一行竖着铺了一块地板，那么将这一行的对应位置设置为 1，表示这个位置实际被占用了。

这个操作是怎么实现的呢？举个例子，看图（2）中第 2 行的状态是 <001111>，表示当处理到第三行的时候，就表示第二行已经铺完地板了，其状态已经确定，此时我们只需将第二行的状态取反，就得到了第三行的初始状态 <110000>。这样做避免了在处理第二行的时候影响到第三行的状态，尤其是第二行还在尝试铺的过程中，状态随时变化的时候，不确定地改变第三行的状态，也会影响到无后向性要求。

#### 状态的初始值和结果

根据递推关系式，第 i 行的状态由第 i − 1 行的状态堆叠计算出来，那么第 1 行的状态自然就是用第 0 行的状态决定了。

问题是，第 0 行是个什么鬼，它不存在啊，虽然实际上没有第 0 行地板，但是并不影响第 0 行地板精神上存在。我们在计算之前，就假设第 0 行已经完全铺好地板了（每个位置对应的标志为都是 1），这一行就只有一个状态 <111111>。因为是我们人为摆出来的一个状态，没有其他变化，所以这个状态对应的铺地板的方法个数就是 1。也就是说，第 0 行的 <111111> 状态的值是 1，即 d[0,<111111>] = 1 或 d[0,63] = 1，这就是初始值。

像 Java 和 C++ 这样的编程语言，索引都是从 0 开始的，刚好可以顺势借用精神上存在的第 0 行，实际地板状态就从第 1 行开始。根据这个递推关系，当铺设到第 M 行的最后一个状态时（就是全是 1 的状态 <111111>），其状态值就是最终要求的结果，即 d[M, <111111>] 或 d[M, 63] 就是结果。

#### 如何计算每一行的状态

根据前面的分析，每一行的状态空间有 2^N 个状态，状态值的范围是 0 ~ 2^N - 1，对于 N = 6 的情况，状态值的范围就是 0 ~ 63。需要注意的是，对不同的行来说，每一行的实际有效状态个数并不相同，也就是说，并不是 2^N个状态都是有效状态。

根据本行的铺设情况，还有上一行的铺设情况，有些状态是不会出现在本行的。那么如何遍历本行的有效状态呢？

根据上面“状态定义”的分析，对每一个位置铺设地板，实际有三种情况，第一种情况是如果位置被覆盖就不铺地板，直接后移一列继续处理；第二种情况是如果位置为空，就尝试铺横向地板，然后移动两列再继续处理；第三种情况是如果位置为空，就尝试铺竖向地板，然后移动一列再继续处理。

从这个描述来看，这是一个**天然的穷举搜索策略**，大家“玩”算法，要有这种敏感度，并且对于本问题来说，每次尝试用各种方法铺完一行（就是处理到第 N 列的时候），实际上就得到了一个状态，类似 <001100> 或 <111100> 这样的状态值（注意 0 是竖向铺地板的情况）。此时就需要将前一行的状态值累加到这一行的这个状态上。为什么呢？是因为前一行的 prev 状态，经过一番尝试，能得到当前行的这个状态，而这正是状态递推关系式所描述的状态转移。

为了遍历每一行的有效状态值，我们采用**深度优先的穷举搜索策略**，并且使用递归的方法实现这个穷举搜索算法，具体的实现过程将在下面展开介绍。对每一行的状态值的累加计算，体现在对状态的穷举搜索过程中，即穷举搜索算法每得到一个完整的铺地板状态，就根据状态递推公式进行一次状态值的累加，搜索完所有的状态，实际上也就完成了对每个状态值的累加。

因此，这个算法将看不到类似于多项式累加计算那样的直接递推关系计算，而是将递推关系的累加隐含在深度优先的穷举搜索过程中了，这个需要读者结合下面的具体代码实现自己体会。

#### 算法实现

#### 算法主体

根据上面“状态的初始值和结果”的描述，算法开始之前要对第 0 行的最终状态设置初始值 1。最终状态就是每个位置都是 1 的状态，这个值就是 2^N - 1。

接下来就是从第 1 行到第 M 行，逐行递推计算每一行的有效状态，以及有效状态的值，实际上，当 d[i, state]的值不是 0 的时候，就说明这是一个合法状态，即从 i − 1 行的某个状态能变化（通过相应的铺地板的方法）到这个 state 状态。如果 d[i, state]的值是 0 ，则说明从 i − 1 行的所有合法状态中，没有哪个状态能变化到 state 状态。

**因此，我们采用的方法是遍历前一行的所有合法状态，从前一行的合法状态开始搜索，看看在这个合法状态的基础上，当前行能产生多少个合法状态**。

```
long long MondriaanDream(int n, int m)
{
    long long d[MAX_M][MAX_STATE];

    memset(d, 0, sizeof(d));

    int finalState = (1 << n) - 1; //全是 1 的铺满状态
   
    d[0][finalState] = 1;  //赋初值
    for (int i = 1; i <= m; ++i)
    {
        for (int state = 0; state < (1 << n); ++state) //2^n 个可能的状态
        {
            //这里理解的关键点：state 是作为上一行的状态枚举的
            //这一行的起始状态需要根据 state 取反            
            if (d[i - 1][state] > 0) //值处理前一行的有效状态
            {
                state_dfs(n, d, i, 0, state, ~state & finalState);
            }
        }
    }
    return d[m][finalState];
}
```

MondriaanDream() 函数的实现和上述描述基本一致，只有少数地方需要解释。第一个地方是当前行搜索的初始状态，前面讲过，只需对前一行的状态取反就可以得到当前行的初始状态，代码中和 finalState 做“与”操作的目的是确保状态值只有 N 个有效的二进制位，因为 finalState 的二进制形式就是 N 个 1。第二个就是返回最终的结果，这个结果就是第 M 行的 finalState 状态的值。

#### 铺地板状态的深度优先搜索

前面介绍算法原理的时候提到过，state_dfs() 函数会使用递归方式实现。我们已经讲过很多递归程序如何设计递归函数了，这里又是一个“同一问题结构变形模式”的递归程序，问题的状态还是那个 d，列的规模还是那个 N，变化的是每次对应的行 i 不一样。先来看看递归退出条件，很显然，对每一行都是从第 1 列开始，当搜索完第 N 列时就该结束了。这就是退出条件，退出时的操作就是进行一次状态累加计算（将 i − 1 行的 prev 状态累加到第 i 行的 state 状态上）。

递归子结构的主体就是对 [i,j] 位置尝试铺地板，当这个位置对应的状态位是 1 的时候（前一行的地板是竖着铺的），则直接跳到 j + 1 列继续。当这个位置对应的状态位是 0 的时候，则分别尝试横着铺和竖着铺一块地板，并根据铺的方式跳到 j + 1 列或 j + 2 列继续。因此，这个递归函数的结构应该是这个样子：

```
void state_dfs(...i, j, state, ...)
{
    if(j == n)
    {
        d[i, state] += d[i - 1, prev];  //累加状态
        return
    }
    
    if(state的第 j 列是 1)   //跳过一列，state 没变化
    {
        state_dfs(...i, j + 1, state, ...)
    }
    if(state的第 j 列是 0)   //尝试竖着铺，state 的 j 列置 0，也就是没变化
    {
        state_dfs(...i, j + 1, state, ...);
    }
    if(state的第 j 列是 0 并且 j < n - 1) //如果空间够，尝试横着铺，state 的 j 列和 j + 1 列置 1
    {
        state_dfs(...i, j + 2, state 的j列和j+1列置1, ...);
    }
}
```

在以上伪代码流程中，需要注意铺设地板后递归调用自身进行下一个位置的处理时，传递给递归函数的 state 参数要设置正确的状态位。竖着铺不用设置，因为本身就是 0 了，横着铺的时候，连续设置两列的状态为 1。

接下来分析递归函数的参数，除了之前分析必然需要的行数 i，当前要处理的列数 j，当前铺到第 j 列的状态 state 之外，问题的状态表 d 要传递给递归函数，列的规模 N 也要传递给递归函数。还有一个很重要的信息，就是 i − 1 行的状态 prev，也要传递给递归函数（其实 prev 状态只在状态累加的时候才用到）。这个递归函数的原型就确定了：

```
//i：第几行，j：第几列，prev 是 i-1 行的状态，state 是 i 行的状态
void state_dfs(int n, long long d[][MAX_STATE], int i, int j, int prev, int state)
```

列数 j 从 0 开始，每次加 1 或加 2，当 j == N 时，说明最后一列（N − 1 列）也处理完了，所以递归退出条件就是 if(j == n)。判断 state 的某一列是否是 1，一般先将 1 左移若干位，得到一个只有那一位是 1，其他位都是 0 的掩码，然后将 state 与掩码做与操作，判断结果是否等于 0 即可。其实没有必要每次都先移位得到掩码，这个掩码可以事先计算好，用一个掩码数组存放，利用数组的下标技巧，直接得到掩码。

```
int bitMask[MAX_N] = {0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080};

//要判断 j 列是否是 1，直接用：
if(state & bitMask[j]) 
{ ...  }
```

递归函数的参数确定了，递归函数的细节部分就可以实现了，就是一些位操作，不多说了：

```
void state_dfs(int n, long long d[][MAX_STATE], int i, int j, int prev, int state)
{ 
    if (j == n)   // j==n 表示已经越界了，不需要继续递归了
    {
        d[i][state] += d[i - 1][prev]; //前 i-1 行的 prev 状态经过变化后能够变成 i 行的 state 状态
        return;
    }

    //如果这个位置已经被上一列所占用，直接跳过
    if ((bitMask[j] & state) > 0)
    {
        state_dfs(n, d, i, j + 1, prev, state);
    }
    //如果这个位置是空的，尝试放一个 1 x 2 的（竖排）
    if ((bitMask[j] & state) == 0)
    {
        state_dfs(n, d, i, j + 1, prev, state);
    }
    //如果这个位置以及下一个位置都是空的，尝试放一个 2 * 1 的（横排）
    if ((j < n - 1) && !(state & bitMask[j]) && !(state&bitMask[j + 1]))
    {
        state_dfs(n, d, i, j + 2, prev, state | bitMask[j] | bitMask[j + 1]);
    }
}
```

### 总结

这一课我们以铺地板问题为例，介绍了状态压缩动态规划法的应用。在看这一课之前，最好先看一下[第4-4课：状态压缩与动态规划]的内容，先理解一下状态压缩的目的，理解了目的，也就能理解这个题目中为什么强调 N 不超过 6 了。同时，也要掌握一个技巧，就是给你一个题目，其中某个维度的参数异常小，看起来还像是动态规划，就可以考虑用状态压缩动态规划了。

解决铺地板问题，现在还很流行另一种状态压缩动态规划法，就是轮廓线动态规划法，大家可以搜索一下这个算法的资料，比较一下与本课的传统实现的差异。对于轮廓线动态规划法解决铺地板问题的实现，大家可以在读者圈里或群里发表自己的意见。



### 4-6 矩阵链乘问题

这一课介绍的矩阵链乘问题，是**区间类型动态规划的典型例子**，区间类型的动态规划是在线性动态规划基础上的扩展。

我的理解是，这个扩展就是将固定的线性问题变成一个变长的线性问题，也就是说，所谓的区间动态规划，就是在一个可选择的线性区间中寻找某种最优的结果，而线性区间长度本身也是可变化的，最优结果的组合也是可变化的，需要在两重变化中寻找最优解。

除了矩阵链乘问题，此类问题的典型例子还有**石子合并问题、能量项链问题、最优排序二叉树问题**等。除此之外，前几年非常火的多边形三角剖分问题，也被归纳为区间动态规划类型的题目。

#### 问题介绍

《算法导论》一书在介绍动态规划问题时，举了一个矩阵链乘（Matrix-chain Multiplication）的例子。我知道很多读者害怕公式，看见《矩阵论》就头疼，但是不要怕，这个题目只涉及了一个简单的概念，就是矩阵的**相容性**（Compatible）。

矩阵 A 和 B 能够相乘，前提是矩阵 A 和矩阵 B 必须相容，所谓的相容，就是矩阵 A 的列数等于矩阵 B 的行数。假设矩阵 A 是 p×q 的矩阵，矩阵 B 是 q×r的矩阵，则矩阵 A 和矩阵 B 的乘积是一个 p×r 的矩阵。计算这个乘积需要 p×q×r 次标量乘法计算和若干次加法，其计算量的主要代价就是这 p×q×r 次乘法计算。

对于一组满足相容性条件（顺序）排列的矩阵做链乘，无论选择中间哪两个矩阵先计算，其结果都能与剩下的矩阵继续保持相容性条件，这是一个很重要的前提，因为调整矩阵的位置会破坏相容性。但是，在矩阵位置不变的情况下，选择计算的顺序对标量乘法的计算量有巨大的影响。

例如，有三个矩阵 A B C 相乘，其中 A 是 10×100 的矩阵，B 是 100×5 的矩阵，C 是 5×50 的矩阵。如果我们按照（（A B）C）的顺序计算，则需要计算的乘法次数是 10 × 100 × 5 + 10 × 5 × 50 = 7500 次。如果我们按照（A（B C））的顺序计算，则需要计算的乘法次数是 100 × 5 × 50 + 10 × 100 × 50 = 75000 次。可见，第二种计算方法需要的计算量是第一种方法的 10 倍。那么，最后的问题来了，对于 n 个矩阵序列 A1,A2,A3,...,An，我们要计算它们的乘积，请用括号化的方式给出一种计算次序，使得最终需要的标量乘法次数最少。

#### 算法原理分析

根据我们的经验（读者也应该掌握这个经验），典型的线性动态规划问题，一般会将状态定义为 f[i,j]，其中 i 代表状态出现的位置，j 代表阶段的划分。

对于矩阵链乘问题，阶段的划分其实就是参与相乘的矩阵的数量，每多一个矩阵参与乘法计算，阶段就增加一个。因此，对于本问题，位置 i 就是参与计算的矩阵链的第一个矩阵的编号，阶段 j 其实就是参与链乘计算的最后一个矩阵的编号，状态 f[i,j] 就是矩阵 AiAi+1,...,Aj 乘积的最优解。

有了状态的定义，实际上子问题就很清晰了，就是矩阵序列 A1,A2,A3,...,An 中的一个子串，那么这样定义子问题是否满足无后向性要求呢？我们来分析一下，假设子问题 A3A4A5 的最小标量乘法次数是状态 f[3,5]，那么它前面的矩阵 A2 无论是直接和 A3A4A5 的结果相乘，还是 A1 和 A2 先相乘，然后再和 A3A4A5 的结果相乘，都不影响 A3A4A5 之前计算出来的结果（即状态 f[3,5] 的值）。A3A4A5 的结果与后面的矩阵做乘法运算，无论以何种方式组合相乘，也同样都不会改变状态 [3,5] 的值，因此，我们这样划分的子问题满足无后向性要求。

那么，状态 f[i,j] 怎么计算呢？很简单，就是将其分解为更小一点的子问题，通过求解子问题的状态递推计算状态 f[i, j] 的值。设区间 [i,j][i,j] 之间有分割点 k 满足 i≤k<j，则以 k 为分割点时得到的状态结果就是：
$$
f[i,j]_{k} = f[i,k] + f[k+1,j] + cost(k) 
$$
其中，cost(k) 是两个子问题得到矩阵相乘的开销，即标量乘法的次数。区间 [i,j][i,j] 之间能有多少个分割点 k，就有多少个 f[i,j]k，最后状态 f[i,j] 取所有 f[i,j]k 中最小的那个即可：

![QQ截图20190609230725](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190609230725.png)

怎么理解这个公式呢，我们用一个实际例子来解释一下。假设有以下 6 个矩阵

![QQ截图20190609230824](C:\Users\12069\Desktop\QQ截图20190609230824.png)



那么，读者可能会问，既然可以拆分成子问题，那为什么只拆成两个子问题，难道不能拆成更多的子问题？当然，为了遍历各种组合情况，我们也会拆分更多的子问题，但是无论怎么拆分，最终都是得到各种规模的子问题所组成的一张表。那么怎么做到拆分各种规模的子问题呢？回忆一下[第4-1课：如何理解动态规划]中给出的区间类型动态规划算法实现模式，套用一下就好了：

```c++
for(区间长度 size：从最小可分区间开始到最大区间长度)
{
    for(小区间起始位置 i：从第一个位置开始到区间长度 size 所决定的结束位置)
    {
        j = i + szie - 1; //j 定义区间结束位置，具体计算方法因问题而异
        for(区间分割点位置 k：从 i 开始到 j 结束)//遍历所有区间 [i,j] 内的位置，将其分割为两个小区间
        {
            f[i][j] = min(f[i][j], f[i][k]+f[k][j] + cost(k));
        }
    }
}
```

![QQ截图20190621191712](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621191712.png)

![QQ截图20190621191739](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621191739.png)

好了，可以考虑将这个伪代码描述的模式翻译成代码了，等等，我们好像忘了什么东西。我们定义了子问题和子问题的状态，还有状态的递推计算公式，但是漏掉了边界条件（初始值），也就是 size = 1 时的情况，对于 size = 1 的情况，矩阵当然不需要自己乘自己，也就是不需要做任何乘法计算，显然 f[1,1] = f[2,2] = … f[6,6] = 0。

#### 算法实现

尽管有了三层循环的算法模式框架，也有了递推关系式，但是要实现算法还有一些细节需要确定，比如递推关系中 cost(k)的计算、各层循环中循环变量范围处理的细节等。

#### 计算 cost(k)

![QQ截图20190621193551](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621193551.png)

根据矩阵的相容性，矩阵链中前一个矩阵的列数必然等于后一个矩阵的行数，所以实际编写算法代码的时候，没有必要为这些矩阵准备一个行数和列数的集合，只需要将它们压缩到一个一维数组中即可。以前面给出的 6 个矩阵的例子，我们将它们的行数和列数整理成数组 p：

```
int p[] = { 30,35,15,5,10,20,25 };
```

![QQ截图20190621193645](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621193645.png)

```
cost(k) = p[i - 1] * p[k] * p[j];
```

#### 数据模型

实际上，上面已经介绍了用于计算矩阵乘法开销的压缩数组 p，除了这个数组，我们还需要一个记录状态 f[i,j] 的数据结构，其实也很简单，就是一个二维数组。前面提到过，矩阵的位置索引是从 1 开始，所以这个二维数组中 f[0,0]，以及 f[0,0] 所在的行和列都没有用到，我们直接从 f[1,1] 开始。

除了表示子问题结果的状态数组 f，我们还需要一个记录子问题最优分割点的位置 k 的数组，记录每个子问题的最优分割点的目的是为了最后输出结果。为了与子问题对应，我们同样用一个二维数组 s 存放每个子问题的最优分割点位置，s[i,j] 表示子问题 f[i,j] 对应的最优分割点。图（2）是与前面例子矩阵对应的 s 数组结果，最终输出结果的时候，从 s[1,6] 反向递推出括号化的计算顺序。

![QQ截图20190621193724](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621193724.png)

#### 算法实现

代码的实现就是对上面的模式代码的简单翻译，没有特别值得说明的地方。最内层循环求最小值，给 f[i] [j] 赋初始值为最大整数，这也是求一系列数值中最小值的常用技巧，先给一个明显超出问题域的最大值，然后再用其他值更新它。只要算出来的 q 比 f[i] [j] 小，就更新 f[i] [j]，同时记录分割点的位置 k 到 s[i] [j] 中。

```c++
void matrix_chain_order(int *p, int n, int f[][M], int s[][M])
{
    for (int i = 1; i <= n; i++) /*初始化默认值*/
    {
        f[i][i] = 0;
    }

    for (int size = 2; size <= n; size++) 	/* 矩阵链的长度 */
    {
        for (int i = 1; i <= n - size + 1; i++) /*子问题矩阵链起始位置*/
        {
            int j = i + size - 1;         /* 子问题矩阵链结束位置 */
            f[i][j] = INT_MAX;
            for (int k = i; k < j; k++)  /*分割点k的遍历*/
            {
                int q = f[i][k] + f[k + 1][j] + p[i - 1] * p[k] * p[j];
                if (q < f[i][j])
                {
                    f[i][j] = q;
                    s[i][j] = k; //记录 f[i,j] 的最优分割点位置
                }
            }
        }
    }
}
```

我个人认为在各种动态规划题目中，结果输出部分是最有意思的地方。大家可能注意到了，基本上都是根据最优解的决策点反向递推出原始问题的决策过程，本题也不例外。最终结果 s[1,6] 记录了最大的子问题 f[1,6]（当然就是原始问题）的最优分割点的位置，以本题为例，s[1,6]=3。根据这个位置，f[1,6] 的结果是由 f[1,3] 和 f[4,6] 两个子问题递推出的最优解；同理，s[1,3]=1，说明子问题 f[1,3] 的结果是由 f[1,1] 和 f[2,3] 两个子问题递推出的最优解。以此类推，可以逐级找到各个子问题的分解方式，直到遇到 s[1,1]、s[2,2]、…、s[6,6] 时结束递推查找。

根据上面的分析，输出结果的过程是一个隐含的递归过程，用递归方法实现算法比较简单。老规矩，先找递归三要素中的递归退出条件和递归子结构的主体。递归退出条件就是子问题的规模是 1 的时候，此时直接输出子问题矩阵本身即可；递归主体部分的处理就是找出子问题的分割点 k，将输出委托给子问题 [i,k] 和 [k+1,j] 继续输出。别忘了，题目要求是要输出括号化的结果，就是用括号表示矩阵计算的次序，所以，要将子问题 [i,k] 和 [k+1,j] 的输出用括号括起来。整个递归函数的框架大概是这个样子：

```c++
void print_optimal_parens(int s[][M], int i, int j)
{
    if (i == j)
    {
        std::cout << "A" << i;
        return;
    }

    int k = s[i][j]; //该子问题的最佳分割点
    std::cout << "(";
    print_optimal_parens(s, i, k);
    print_optimal_parens(s, k + 1, j);
    std::cout << ")";
}
```

不要被各种子问题的描述迷惑，这个不是分解子问题类型的递归，这个仍然是同一问题的结构变形模式。问题仍然是 matrix_chain_order() 函数求解得到的分割点表 s，所以，s 必须是递归函数的参数。另外，还需要标识问题范围的参数，很显然，这个范围就是对应子问题分割的范围 [i,j]，所以 i 和 j 也需要通过函数参数传递。这样一来，print_optimal_parens() 函数的参数基本上就定了：

```c++
void print_optimal_parens(int s[][M], int i, int j)
```

定好函数参数，递归函数主体内的细节就可以确定了，判断子问题的规模是 1，就可以用 i 和 j 是否相等来表达，若 i 和 j 相等，则问题规模是 1，否则规模就不是 1，这很容易理解。分割点 k 就是 s[i][j] 中存放的值，两次递归调用的再触发，传递的范围用 k 分割一下即可，这就是整个输出函数的实现：

```c++
void print_optimal_parens(int s[][M], int i, int j)
{
    if (i == j)
    {
        std::cout << "A" << i; //输出 Ai
        return;
    }

    int k = s[i][j]; //该子问题的最佳分割点
    std::cout << "(";
    print_optimal_parens(s, i, k);
    print_optimal_parens(s, k + 1, j);
    std::cout << ")";
}
```

### 总结

区间类型的动态规划不太容易理解，它在线性动态规划的基础上多了一层区间的变化，但是其问题的状态依然是二维的，仍然可以用二维状态定义反推出子问题的定义，为求解问题打开缺口。同时，记住区间类型动态规划解法的典型三重循环模式，也能事半功倍。

好了，问题来了，这一课的问题也是经典的“石子合并”问题。在操场上沿一直线排列着 n 堆石子（每一堆石子的个数不相等），现要将石子有次序地合并成一堆，规定每次只能选相邻的两堆石子合并成新的一堆，并将新的一堆石子数计为该次合并的得分，我们希望这 n−1 次合并后得到的得分总和最小，请给出合并的顺序。

举个“栗子”，假设有三堆石子，个数分别是 2、3 和 9，合并的顺序就是两种，分别是（（2 3）9）和（2 （3 9））。以第一种方式合并石子，第一次合并得到两堆石子分别是 5 和 9，同时得到积分为 5，然后第二次合并，积分累加 14（5 + 9 = 14），共得 19 分；以第二种方式合并石子，第一次合并得到两堆石子分别是 2 和 12，同时得到积分为 12，第二次合并，积分累加 14（2 + 12），共得 26 分，显然，第二种合并方式得分高。

这个题目和矩阵链乘非常像，矩阵链乘是相邻矩阵才能计算，这个题目是相邻的两堆石子才能合并，算法框架基本一致，差别就在状态的递推关系式，一个是求最小值，一个是求最大值，感兴趣的读者可以试试。



### 4-7 投资问题

> 动态规划理论最早被提出来的时候，是用来解决资源的有效分配问题。
>
> 这一课要介绍的投资问题，有个通用的模式，那就是总资源量有限，要分配给若干个项目，每个项目都有一个投入与收益的关系，最终的问题是求如何规划在不同项目上的投资，使得收益能够最大化。

#### 问题分析

这一类问题有很多，我们找了个典型的例子，即项目投资问题。假设有数量为 M 的资金，计划用于 N 个投资项目，每个项目投入的资金和获得的回报用一张二维表记录，比如 f[i, x] 表示第 i 个项目投入 x 万元时能获取的收益。最后的问题是如何在这 N 个投资项目上分配这 M 万元的资金，使得最后的收益最大化。比如有 600 万元，投资 3 个项目，每个项目的投资收益如下表所示：

![QQ截图20190621195054](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190621195054.png)

显然，投资和收益不是线性等比例关系，否则的话，把钱全投到收益比最高的那个项目上就行了，也没啥好规划的了。

这个算法也可以用穷举法，因为 **N 不是固定的值**，所以穷举时可以考虑用递归的方式实现，但是这一课我们考虑用动态规划法来设计这个算法。

投资 N 个项目，看起来好像是毫无关系的离散事件，但是因为投资的总钱数是固定的，这就使它们有了关系。如果我们换个角度看投资的项目，把所有的投资看作是一个求最优解的操作，把对每个项目的投资看作这个操作的一个阶段，就成功地将其转换成了**多阶段决策问题**。

如果要考虑用动态规划解决这个多阶段决策问题，就需要首先证明每个阶段的决策能满足无后向性的要求。在这之前，先要确定决策状态的定义。

状态里肯定要有一个量是标识决策阶段（也就是当前决策的项目）的，不妨用 i 表示决策阶段。肯定还要有一个量是标识投资的钱数，如果我们定义 j 为当前项目（阶段）i 投入的钱数，那么**状态 d[i,j]就表示项目 i 投入 j 万元获取的最大收益**。

现在考虑一下这个状态的定义是否满足无后向性，我们假设给第 2 个项目投入 2 百万元时获取的最大收益为 d[2,2]，这个 d[2,2] 包含两部分收益，一部分是第 2 个项目投 2 百万元获得的 85 万元固定收益，另一部分是给另两个项目投入剩下的（M − 2）百万元获取的收益。很显然，这（M − 2）百万元在第 1 个项目中有很多种投资方法，每种方法获取的收益都不一样，这会使得通过不同的 d[1,x] 计算出来的 d[2,2] 各不相同，后续依赖 d[2,2] 的决策就如同建立在浮沙之上，因此不满足无后向性要求。

单独对第 i 个项目定义状态不能满足无后向性要求，现在换个思路，我们将前 i 个项目合在一起考虑，即定义状态 d[i,j]为**给前 i 个项目投入 j 万元时能获得的最大收益**。前 i 个项目无论怎么分配这 j 万元投资，总能得到一个确定的最大收益，并且这个最大收益在到达 d[i,j] 状态后不会因为之前的分配方式不同而变化，后续做决策时也不会变化，因此满足无后向性要求。







### 4-8 方块消除游戏

>前面基础部分我们介绍过简单的串模型的动态规划，在这个系列中，我们又介绍了区间动态规划模型、状态压缩动态规划模型和线性动态规划模型。
>
>我们用的算法实现都是尽量使用状态递推关系式直接用递推的方法，大家可能都忘了“备忘录（或状态记忆）”也是动态规划
>
>这一课我们将讲解如何用这种方法来求解方块消除游戏的算法实现。

