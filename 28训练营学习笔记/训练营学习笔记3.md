### 5-1 匈牙利算法与二分图的最大匹配

在图论中，二分图（又称二部图）是一个特殊的模型，关于二分图有很多概念，比如匹配、完全匹配、最大匹配等。

这一课我们来介绍一种求二分图的最大匹配的匈牙利算法，匈牙利算法原理是公开的

人们使用匈牙利算法都是根据自己问题域的数据模型，利用算法原理实现具体的算法。这一课我们的关注点仍然是怎么根据算法原理设计数据模型，并实现算法。



#### 二分图的各种匹配

首先介绍一下二分图，二分图 G=(V,E) 是这样的一个图，它的顶点集合 V 可以划分为 X 和 Y 两个集合，它的边集合 E 中的每条边都有一个端点在 X 集合，另一个端点在 Y 集合。

判断二分图的关键是看点集**是否能分成两个独立的点集**，如图（1-a）就是一个二分图，如果一个图的边形成了三角形，那它一定不是二分图，图（1-b）就不是二分图。

![2019-06-11 22-06-31 的屏幕截图](/home/lihuawei/桌面/usegit/algorithmcompetition/28训练营学习笔记/picture/2019-06-11 22-06-31 的屏幕截图.png)

#### 匹配

对于一个二分图 G=(V,E) 中部分边组成的子集 M，如果 M 的边集中任意两条边都不依附于同一个顶点，则称 M 是一个匹配，怎么理解这句话呢？首先匹配是一个边的集合，并且不唯一；其次，匹配 M 中没有任何两条边有公共的顶点。以图（1-a）所示的二分图为例，图（2-a）和图（2-b）中红色的边集就是二分图的两个匹配，而图（2-c）中的红色边集就不是匹配。

![2019-06-11 22-10-29 的屏幕截图](/home/lihuawei/桌面/usegit/algorithmcompetition/28训练营学习笔记/picture/2019-06-11 22-10-29 的屏幕截图.png)

#### 最大匹配

对于一个二分图 G=(V,E) 的所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配，最大匹配所包含的边数就是二分图的最大匹配数。

#### 完全匹配

如果一个二分图 G=(V,E) 的最大匹配，恰好连接了图中所有的顶点，也就是说所有的顶点都有属于最大匹配的边与之相连，则称这个最大匹配是完全匹配，或完美匹配。最大匹配不一定是完全匹配，但是完全匹配一定是最大匹配，图（3）就是图（1-a）所示的二分图的一个完全匹配。

![2019-06-11 22-15-15 的屏幕截图](/home/lihuawei/桌面/usegit/algorithmcompetition/28训练营学习笔记/picture/2019-06-11 22-15-15 的屏幕截图.png)

#### 最大匹配和匈牙利算法

匈牙利算法是埃德蒙德斯（Edmonds）在 1965 年提出的一个简化的最大流算法，该算法根据二分图匹配这个问题的特点将最大流算法进行了简化。匈牙利算法不区分图中的源点和汇点，也不关心边的方向，因此不需要复杂的网络图模型，正因为如此，使得匈牙利算法成为一种很简单的**二分匹配算法**。匈牙利算法的关键是寻找增广路径（Augment Path），首先介绍一下什么是增广路径。

#### 增广路径

设 M 是二分图 G=(V,E) 的一个匹配边集，**若 P 是图 G 中一条连通两个未匹配顶点的路径（P 的两个顶点一个在 X 集合，另一个在 Y 集合），并且在这条路径上，属于 M 的边和不属于 M 的边交替出现，则称 P 为相对于匹配 M 的一条增广路径**。也就是说，增广路径从 X 集合中的一个未匹配点开始，依次交替经过不在匹配 M 中的边和在匹配 M 中的边，最后到达另一个在集合 Y 中的顶点。

根据上述定义，增广路径具有以下三个重要性质：

- 路径中边的条数是**奇数**，对路径上的边按照顺序编号，所有奇数编号的边都不在已知的匹配 M 中，所有偶数编号的边都在 M 中（也就是第一条边和最后一条边不在匹配 M 中）；
- 路径的起点在 X 集合，终点在 Y 集合（反过来也成立），路径上的点一个在 X 集合，一个在 Y 集合，交替出现，整条路径上没有重复的点，并且只有路径的起点和终点是未覆盖的点，路径上其他的点都已经配对；
- 如果对增广路径进行“取反”操作，新的匹配数就比已知匹配数增加一个，也就是说，可以得到一个更大的匹配。

所谓的取反操作，就是把增广路径上奇数编号的边加入到已知匹配中，并把增广路径上偶数编号的边从已知匹配中删除。每做一次“取反”操作，得到的匹配就比原匹配多一个，为啥多一个呢？因为增广路径有奇数条边，在匹配 M 中的边比不在 M 中的边少 1 个（理解第一条特性），取反以后，自然就变成多 1 个了。

寻找增广路径并扩大当前匹配是匈牙利算法的关键，增广路径的起点要么是在二分图的 X 集合中，要么是在 Y 集合中，因此寻找增广路径的算法可以从任何一侧的顶点开始，逐个顶点搜索。从 Xi 顶点开始搜索增广路径的流程如下：

```c++
while(从Xi的邻接表中找到下一个关联顶点Yj)
{
    if(顶点Yj不在增广路径上)
    {
        将 Yj 加入增广路径;
        if(Yj 是未覆盖点 或者 从与 Yj 相关连的顶点（Xk）能找到增广路径)
        {
            将 Yj 的关联顶点修改为 Xi；
            从顶点 Xi 开始有增广路径，返回 true；
        }
	}
    从顶点 Xi 开始没有增广路径，返回 false；
}
```

#### 数据模型

既然是图的算法，肯定要用到图的数据模型，图有邻接矩阵和邻接表两种表达方式，对应的算法实现稍有差异，但是算法的原理是一样的。

我们准备用邻接矩阵存储图，用从 0 开始的数字为每个顶点编号。

当然，邻接矩阵的数组下标自然就借用顶点的编号了。二分图的邻接矩阵有个特点，就是矩阵的二维坐标分别来自 X 集合和 Y 集合，比如 edge[2][4=1，表示 X 集合的 2 号顶点和 Y 集合的 4 号顶点之间有条边。

根据算法原理的描述，在处理的过程中，还需要记录当前匹配的边集用于结果输出，虽然是边，但还是要通过点的信息来表示，有了点就有了边，当然，要两个点才行，虽然有两个点的信息需要存储，但是不一定需要两个数。因为数组下标本身就可以是一个点的信息，那么边的另一个点的信息就用对应数组元素的值来表达，不容易理解吧？举个“栗子”：假设这个数组的第二个元素值是 5，即 path[1] = 5，表示当前匹配边集上有一条边，它的一个顶点编号是 1，另一个顶点的编号是 5，因此 path[1] 是一条边，同样，path[0] 也是一条边，Get 到感觉了吗？

感觉数组下标被“玩”坏了吧，谁说边一定要用两个数字存储？

除了增广路径，算法原理的描述里隐含了一个重要的信息，那就是根据Xi 搜索对应的 Yj 点时，要区分Yj 是否是已经被增广路径覆盖的点。怎么区分？就是给每个顶点Yj 设置一个是否在增广路径上的标识。这个仍然用一维数组就可以了，on_path[2] = true，表示编号为 2 的顶点已经在增广路径上了。

最后把它们放在一起，就是这个样子（实际上，如果对代码设计有追求的读者，会选择把 edge 独立放在 GRAPH 中）。

```c++
typedef struct 
{
    int edge[UNIT_COUNT][UNIT_COUNT];
    bool on_path[UNIT_COUNT];
    int path[UNIT_COUNT];
    int max_match;
}GRAPH_MATCH;
```

#### 算法实现

匈牙利算法的思路就是不停地寻找增广路径，增加匹配的个数，当不能再找到增广路径时，算法就结束了，得到的一个匹配就是最大匹配。

因此，我们先实现寻找增广路径的函数，寻找增广路径可以从 X 集合的点开始，也可以从 Y 集合的点开始。如果从 X 集合的点开始，GRAPH_MATCH 数据结构中的 path 和 on_path 数组的下标就是 Y 集合的顶点编号。

寻找增广路径的算法原理就是根据给出的 X 集合某个顶点Xi，遍历 Y 集合的所有顶点 Yj，看看能否将其加到增广路径上。结合我们的数据模型和上一课的算法原理，寻找增广路径的算法实现就水到渠成了：

```c++
bool FindAugmentPath(GRAPH_MATCH *match, int xi)
{
    for (int yj = 0; yj < UNIT_COUNT; yj++)
    {
        if ((match->edge[xi][yj] == 1) && !match->on_path[yj])
        {
            match->on_path[yj] = true;
            if ((match->path[yj] == -1)
                || FindAugmentPath(match, match->path[yj]))
            {
                match->path[yj] = xi;
                return true;
            }
        }
    }

    return false;
}
```

当 `match->path[yj] == -1` 的时候，说明 Xi 和 Yj 连线的边还不在匹配的边集中，此时直接将其添加到匹配中就可以了。因为根据增广路径的性质，它是从 X 集合开始，到 Y 集合结束，并且 Xi 和 Yj原来都不在匹配中。虽然此时增广路径只有一条边，但那也是奇数啊，因此，它满足增广路径的条件，怎么算是添加到匹配的边集中了呢？就是这句 `match->path[yj] = xi`，还记得前面对 path 数组的解释吗，这说明从 Xi 到 Yj 的边记录在匹配中了。

当 `match->path[yj] != -1` 的时候，说明 X 集合中的某个点（假设是 Xk 点）与 Yj 的边已经在当前匹配中了，假设 `match->path[yj] = xk`，那么我们就从 X_{k}Xk 继续在 Y 集合中查找增广路径，记住，因为算法是从 X 集合开始查找的，所以增广路径必须结束在 Y 集合，要一直找到一个不在路径上的 Y 集合的点为止，如果找不到就返回 false。这个继续查找实际上是个深度优先的搜索过程，采用递归方式实现，`match->path[yj]` 的值就是 xk，直接递归调用 `FindAugmentPath(match, match->path[yj])` 就是了。

最后匈牙利算法的实现就是 Hungary_Match() 函数所展示的内容，`match->max_match` 是找到的最大匹配数，`match->path[]` 记录了最大匹配的边集。特别地，当 Hungary_Match() 函数返回 true 的时候，说明当前找到的最大匹配是个完美匹配。注意每次搜索增广路径之前，要调用 ClearOnPathSign() 函数清除上次搜索增广路径时记录的标志信息。

```c++
void ClearOnPathSign(GRAPH_MATCH *match)
{
    for (int i = 0; i < UNIT_COUNT; i++)
    {
        match->on_path[i] = false;
    }
}

bool Hungary_Match(GRAPH_MATCH *match)
{
    for (int xi = 0; xi < UNIT_COUNT; xi++)
    {
        if (FindAugmentPath(match, xi))
        {
            match->max_match++;
        }

        ClearOnPathSign(match);
    }
    return (match->max_match == UNIT_COUNT);
}
```

#### 总结

图论中的很多算法都有公认的最优算法实现，比如本课介绍的求最大匹配的匈牙利算法，再比如带权二分图最大权匹配（最小权匹配）的 Kuhn-Munkres 算法（KM 算法），还有求稳定匹配的 Gale-Shapley 算法等。这些都是已知问题的高效算法，也没啥好发挥的，玩算法的人基本上都要准备好这些算法的实现模板，只要识别出题目适合用这些算法，直接套模板，算法框架就出来了。当然，也要根据题目的情况，适当修改算法的数据模型。

尽管网上有很多此类算法的实现，但我还是建议大家自己抽空把这些算法写一遍，研究透原理和实现。原因很简单，套模板的时候，少不了要修改数据模型，以便适应题目要求，如果不熟悉算法实现，难免会改错，耽误时间。



### 5-2 Dijkstra算法

Dijkstra 算法是有中文名字的，一般叫做“迪杰斯特拉算法”，该算法是求解单源最短路径问题的经典算法，算不上高效，但确实是最简单的算法。

Dijkstra 算法并不难，很多算法书都有详细的说明，但是这些书基本上都是对着一个类似图（1）这样的图作为例子来演示算法。

如果要理解算法的原理，通常这样做也就足够了，但是要实现一个可用的算法解决实际问题，还需要跨过几个门槛才行。首先要解决数据模型的问题，即需要定义一个能参与到算法运算中的数据结构，存放初始值、结果和运算过程中产生的中间数据；其次是将文字描述的算法原理解释成程序代码；最后是将运算结果转化成人类能理解的方式，或按照题目要求的方式输出出来。

![2019-06-11 23-08-26 的屏幕截图](/home/lihuawei/桌面/usegit/algorithmcompetition/28训练营学习笔记/picture/2019-06-11 23-08-26 的屏幕截图.png)

#### Dijkstra 算法分析与设计

这里简单讲一下 Dijkstra 算法原理的分析，以及如何设计适合 Dijkstra 算法的数据模型。因为 Dijkstra 算法的原理不是重点，很多算法书都会详细介绍并进行正确性的证明，所以此处仅仅是用我的理解把原理描述出来，如果看其他的资料感觉晦涩，不妨看看我的描述是否更好理解一点。

#### Dijkstra 算法原理分析

Dijkstra 算法原理其实很简单，对于一个带权有向图 G=(V,E)，其中任意两个相连顶点 Vi 和 Vj 间的距离用权重表示为：w(Vi,Vj)，那么对于任意一个顶点到其他顶点的最短路径求解过程的描述如下。

（1）准备一个集合 T 存放当前已经找到最短路径的顶点集，再准备一个数组 dist 存放起始点到各个顶点的最短路径，即 dist[Vx] 表示起始点到顶点 Vx 的最短路径值。

（2）将 T 初始化为只包含起始点 S 的状态，即 T{S}，S 可以是任意一个顶点 Vx，比如 V1。初始化 dist 数组的值为起始点 S 到顶点 Vx 的边的权重，即 dist[Vx] = w(S,Vx)，如果起始点 S 到 Vx 没有路径相连（即不能直接到达），则将其值设置为无穷大。对于起始点 S，则设置 dist[S] = 0。

（3）对于所有不属于集合 T 的顶点 Vi，从 dist 数组中寻找最小值 dist[Vi]，这个最小值 dist[Vi] 就是起点到顶点 Vi 的最短路径，此时将顶点 Vi 加入到集合 T 中，完成一个顶点的选择。

（4）对于新加入的顶点 Vi，查看 Vi 能够到达的所有顶点，计算通过 Vi 到达其他顶点的路径长度是否比起始点直接到达该顶点的长度短，如果是，则替换 dist 数组中对应顶点的值。

（5）重复上述过程（3）、（4），直到集合 T 包含了所有顶点。

通过上述原理的描述，可以看出来这个算法需要遍历途中的所有顶点，并且是按照广度优先的方式遍历的。

遍历采用的是迭代法，每个迭代完成一个顶点的处理，根据第（5）步的描述，这个迭代法可以用循环体的方式实现，其中第（3）和第（4）步是循环体的内容，第（5）是退出条件。根据第（3）步的描述，每次都从 dist 中寻找最小的那个值，说明此处使用了贪婪法的策略，即不考虑整体因素，就这一步来说，就只要最小的那个值。如果大家对这 5 个步骤的描述还有疑惑的地方，我们就以图（1）所示的有向图为例，给大家演示一下 Dijkstra 算法的求解运算过程：

![2019-06-11 23-12-21 的屏幕截图](/home/lihuawei/桌面/usegit/algorithmcompetition/28训练营学习笔记/picture/2019-06-11 23-12-21 的屏幕截图.png)

#### 准备数据模型

Dijkstra 算法适用于权值为非负数的有向图，要实现这个算法，绕不开图的定义，计算机的图论里一般采用两种方式描述图，一种是邻接表，另一种是邻接矩阵。

通过对算法描述的理解，算法的第（2）步和第（4）步可能需要频繁地获取两个顶点之间的边的权重（距离）。

如果采用邻接表的方式，则每次都要对邻接表进行遍历，会影响算法的效率；如果采用邻接矩阵的方式，则简单很多，矩阵中每个元素的值就是对应边的权重，算法实现的时候可以利用顶点下标直接从二维数组中获取该值。

每个适用 Dijkstra 算法的例题都有各自不同的描述方法，但是这些描述背后，无怪乎都是要提供算法所需的参数信息，而这些信息其实就是两个内容：问题抽象之后的那个“图”和求解最短路径的起始点。我们定义数据结构 Problem_T 用于描述问题：

```c++
typedef struct
{
    int vertexs;  //题目给出的实际顶点个数
    int w[MAX_VERTEX][MAX_VERTEX]; //图的权重矩阵，表示顶点间的距离
    int start_vertex;   //起始点编号
}Problem_T;
```

选择了图的表示方法，有了 Problem_T 的定义，那么，现在问题来了，顶点怎么定义？显然，我们无法像图（1）那样让计算机处理 V1、V2 这样的名字，因此选择用数字给顶点编号，这也是算法中常用的问题抽象方法。我们的数据定义中使用了一维和二维数组，因为很多编程语言的数组下标都是从 0 开始的，所以顶点选择从 0 开始的数字进行编号，在代码处理上能带来很大的好处。

根据第（1）步的描述，实现 Dijkstra 算法还需要一个集合 T 和 dist 数组。集合可以用多种数据结构描述，C++ 和 Java 都支持 set，可以用于集合操作，但是对于这个算法来说，对集合 T 的操作很简单，就是存放所有已经知道最短路径的顶点，原本用数组表示集合 T 实现起来更简单。

dist 原本用数组就可以简单描述，但是考虑到第（3）步中取最小值 dist[Vi] 时需要判断 Vi 是否已经在集合 T 中，此时如果用遍历集合 T 的方式判断每个 dist 对应的顶点是否已经在集合中，算法实现起来比较低效。

为此，我们给每个 dist[Vi] 再附加一个属性，即除了表示起始点到 Vi 的最小距离值之外，再表示一下 Vi 是否已经在集合 T 中。很多编程语言的数组都不支持多值表达，因此我们将 dist 数组元素设计为一个数据结构：

```c++
typedef struct
{
    int value;
    bool is_in_t;
}Dist_T;
```

综合以上描述，我们定义一个数据结构 Dijkstra_T，包含了 Dijkstra 算法所需要操作的全部数据：

```c++
typedef struct
{
    int vertexs;  //题目给出的实际顶点个数
    int T[MAX_VERTEX];  //集合 T
    int tc; //当前 T 中顶点个数
    Dist_T dist[MAX_VERTEX];  //dist 数组
}Dijkstra_T;
```

#### Dijkstra 算法设计

Dijkstra 算法只是给出了理论上的原理，针对不同的具体问题，在实现上可能有细微的差异。结合 Dijkstra_T 的定义，我们可以设计出一个类似算法模板的实现，遇到具体问题，如果识别出来是求单源最短路径问题，只需根据题意对模型稍作修改，就可以套用 Dijkstra 算法求解，这也是很多人“玩” Online 算法比赛常用的套路。

定义了 Dijkstra_T 数据结构，Dijkstra 算法原理的第（1）步就完成了，接下来完成第（2）步，对 Dijkstra_T 数据结构中的 T 和 dist 进行初始化。初始化的工作相对比较独立，从代码实现的角度理解，用一个单独的接口函数完成数据初始化是一种比较好的代码风格。

```c++
void init_dijkstra(Dijkstra_T *dj, Problem_T *p_data)
{
    //将 T 初始化为只包含起始点 S 的状态，即 T{ S }
    dj->T[0] = p_data->start_vertex;
    dj->tc = 1;

    //初始化 dist 数组的值为起始点 S 到顶点 Vx 的边的权重，即 dist[Vx] = w(S, Vx)
    dj->vertexs = p_data->vertexs;
    for (int i = 0; i < dj->vertexs; i++)
    {
        dj->dist[i].is_in_t = false;
        //对无穷大的处理，已经隐含在邻接矩阵 w 的处理中了
        dj->dist[i].value = p_data->w[p_data->start_vertex][i];
    }
    //起始点特殊处理一下
    dj->dist[p_data->start_vertex].is_in_t = true;  //起始点初始化在 T 中了
    dj->dist[p_data->start_vertex].value = 0; //对于起始点 S，则设置 dist[S] = 0；
}
```

init_dijkstra() 函数的代码比较简单，对照其中的注释，可以看出来第（2）步的文字描述是如何翻译成代码的。如果两个顶点不直接相连，算法原理的描述是用无穷大表示两个顶点的距离，这里需要说明一下对无穷大的处理方式。

计算机无法表示无穷大和无穷小，一般的处理原则是用一个计算机能表达的特殊值代替无穷大或无穷小，很多人喜欢用“−1”这样的负数表示这个特殊值，以区别正数表示的距离值。实际上这是个不好的习惯，除非别无选择，否则尽量不要使用这种方法。

好的做法是，使用一个明显超出问题域中各值范围的正整数值来表示无穷大的概念，这样选择可以很好地满足代码处理的一致性原则。邻接矩阵 w 中，如果两个顶点之间不直接相连，其对应的权值被设置为 INFINITE，INFINITE 是一个定义的常量：

```c++
const int INFINITE = 108000; //十万八千里
```

使用 INFINITE 常量而不是“−1”这样的特殊值的好处就是不需要在代码中到处去做 if-else 这样的判断，无论那个距离，只要加上这个 INFINITE，都不可能是最小距离，在第（3）步做选择的时候自然就会被排除，算法代码不需要做特殊处理，也就显得十分简洁。对于常见的邮递员问题，汽车航行问题，这个值够大，但是如果你遇到的是星际贸易这样的问题，需要根据题意，谨慎地调整这个常量的值。

接下来是第（3）~（5）步的实现，这个是算法的主体部分。根据之前对算法原理的分析，算法的主题应该是一个循环结构，其中第（5）步给出了循环结束的条件，基本上这个循环结构应该是这样的：

```c++
while (dj->tc < dj->vertexs) //直到集合 T 包含了所有顶点
    {
        //......
    }
```

第（3）步的操作中有一个约束条件，就是“对于所有不属于集合 T 的顶点 Vi”，根据我们的数据模型定义，只需要判断 `dist[i].is_in_t` 是否为 true 即可，不需要遍历集合 T 做判断。从这个例子可以看出来，设计算法时，数据模型的定义在很大程度上会影响算法的具体实现，甚至影响算法的效率。从线性表中找最大和最小值的方法在前面的课程中都有介绍，本例中使用只需增加一个对 `dist[i].is_in_t` 的判断即可。向 T 中添加顶点 Vi，就是在数组 T 的末尾增加元素，tc 值是数组中有效元素的个数，同时也是数组末尾的下标：

```c++
dj->T[dj->tc] = min_vi;
dj->tc++;
```

第（4）步是比较容易困惑的地方，首先第一句“对于新加入的顶点 Vi，查看 Vi 能够到达的所有顶点”，就常常让很多新手无法下手。其实，这就是对邻接矩阵的遍历操作。起点 Vi 是固定的，只要将 w 的第二维下标遍历一遍就可以了，只要小于 INFINITE，就说明 Vi 能到达这个顶点。现在看第二句话，假如从 Vi 到顶点 j 可以直达，那么“通过 Vi 到达其他顶点的路径长度”其实就是 dist[Vi] + >w[Vi]j，“起始点直接到达该顶点的长度”就是 dist[j]，这句描述翻译成伪代码描述就是：

```c++
IF (dist[Vi] + >wVi) < dist[j]
　　dist[j] = dist[Vi] + >wVi
END IF   
```

第（5）步做的事情其实就是根据实际情况更新各个顶点目前已经得到的 dist 距离。dist 中的距离是之前用贪婪策略得到的最短距离（局部最优解），实际可能并不是最短的距离，因为贪婪法一般都不可能直接得到全局最优解，所以对于 Dijkstra 算法来说，这个更新（替换）操作非常重要。

至此，我们已经完整地理解并翻译了全部算法原理描述的内容，看看最终的算法实现吧：

```c++
void dijkstra(Dijkstra_T *dj, Problem_T *p_data)
{
    while (dj->tc < dj->vertexs) //直到集合 T 包含了所有顶点，第（5）步描述的循环终止条件
    {
        //第（3）步
        //对于所有不属于集合 T 的顶点 Vi，从 dist 数组中寻找最小值 dist[Vi]
        int min_dist = INFINITE;
        int min_vi = -1;
        for (int i = 0; i < dj->vertexs; i++)
        {
            if (!dj->dist[i].is_in_t && (dj->dist[i].value < min_dist))
            {
                min_dist = dj->dist[i].value;
                min_vi = i;
            }
        }

        //将顶点 Vi 加入到集合T中，完成第（3）步
        dj->T[dj->tc] = min_vi; //新加入顶点 min_vi
        dj->tc++;
        dj->dist[min_vi].is_in_t = true;

        //第（4）步
        //对于新加入的顶点 Vi，查看 Vi 能够到达的所有顶点
        for (int j = 0; j < dj->vertexs; j++)
        {
            if (p_data->w[min_vi][j] < INFINITE) //从 min_vi 能直接到达 j
            {
                int new_dist = dj->dist[min_vi].value + p_data->w[min_vi][j];
                //从起点到 min_vi 的最小距离加上 min_vi 到 j 的距离之和小于从起点直接到 j 的距离
                if(new_dist < dj->dist[j].value)
                {
                    //替换 dist 数组中对应顶点的值
                    dj->dist[j].value = new_dist;
                }
            }
        }
    }

}
```

结合代码中的注释，对应算法原理的描述，对 Dijkstra 算法的实现是否一目了然了？

#### Dijkstra 算法相关的典型例题

虽然我们有了一个符合 Dijkstra 算法原理的简单实现，但是要实用还有一段距离。这里我们通过两个曾经在算法竞赛中出现过的题目，介绍一下如何识别适用于 Dijkstra 算法的题目，并根据题目的描述修改数据模型定义，使之能解决对应的题目。

#### 宋江的困扰

一心想被招安的宋江终于如愿以偿，为了向朝廷递上投名状，宋江被高太尉忽悠去攻打方腊。从梁山到方腊路途遥远，中间间隔众多城镇，这些城镇之间要么是水路相连、要么是山路、要么是平康大道、要么是被山挡着，不能直接到达。梁山大军从一个城镇移动到另一个城镇需要的时间各不相同，如何用最短的时间抵达方腊，这个问题一直困扰着宋江，请你帮宋江解决这个问题吧，规划一条从梁山到方腊的路线，使得梁山大军能用最短的时间到达方腊。

测试数据的格式如下，第一行是一个数字，表示城镇的数量 n，2 ≤ n < 20；第二行是对应城镇的名称，中间用空格隔开；第三行是两个数字，分别表示梁山对应的编号和方腊对应的编号，城市编号从 0 开始；第四行是城镇之间交通信息的数量。之后紧跟着 M 行交通信息，每行有三个数字，分别是起点城镇的编号、终点城镇的编号和这两个城镇的交通时间，单位是天。

根据题目分析，这是个求最短路径的问题，每个城镇看作是图上的一个顶点，城镇之间的交通时间可视为边的权，这个数始终为正数，符合 Dijkstra 算法的要求，可以应用 Dijkstra 算法求解。确定了算法，接下来就看如何把题目描述的信息转化成算法要求的数据模型。Dijkstra 算法可以计算出从起始点到任意点的最短路径，把梁山作为起始点，找到方腊对应的 dist 值没有问题，但是这个题目要求输出从梁山到方腊的路线，这就需要我们修改数据模型的定义，增加最短路径的节点信息，最后在输出信息的时候，除了输出花费的行军时间，还要输出行军路线。

首先修改 Dist_T 数据结构的定义，增加路径信息 path，Dist_T 原本设计就是存放最终结果，路径信息放在这里最合适

```c++
typedef struct
{
    int value;     
    int path[MAX_VERTEX];
    int pc;
    bool is_in_t;  
}Dist_T;
```

接下来对第（2）步初始化的算法代码进行修改，增加 path 的初始化。path 初始化的原则是当存在从起始点到 Vi 的通路时（两个城镇没有被山挡着），则将起始点增加到 path 中，说明当前 dist[Vi] 的值是从起始点到 Vi 的距离，起始点是这条路径的第一个点。需要调整的代码如下：

```c++
dj->dist[i].is_in_t = false;
        dj->dist[i].pc = 0;
        dj->dist[i].value = p_data->w[p_data->start_vertex][i];
        if (dj->dist[i].value < INFINITE)
        {
            dj->dist[i].path[0] = p_data->start_vertex;
            dj->dist[i].pc = 1;
        }
```

最后是修改算法第（4）步的内容，当满足“`(dist[Vi] + >w[Vi][j]) < dist[j]`”条件时，不仅更新 dist[j] 的值，同时更新 dist[j] 的路径信息。更新的方法是从 dist[Vi] 复制 Vi 的最短路径信息，再把 Vi 顶点附加在路径最后，表示是经过 Vi 这个顶点再到 j 的路径。修改后的代码如下：

```c++
    if (new_dist < dj->dist[j].value)
    {
        //替换 dist 数组中对应顶点的值
        dj->dist[j].value = new_dist;
        //从 min_vi 复制路径信息
        for (int k = 0; k < dj->dist[min_vi].pc; k++)
        {
            dj->dist[j].path[k] = dj->dist[min_vi].path[k];
        }
        dj->dist[j].pc = dj->dist[min_vi].pc;
        //附加新路径信息，即从 min_vi 到 j 这一段
        dj->dist[j].path[dj->dist[j].pc] = min_vi;
        dj->dist[j].pc++;
    }
```

最后，在算法的主体不变的情况下，修改结果数据模型定义，并少量修改代码，就可以得到一个针对本问题的算法。例如，题目给出一组测试数据如下：

```
8
梁山 尖庄 茅台 景德镇 雄安 敦煌 龙门 方腊
0 7
15
0 1 20
0 3 10
0 5 30
1 2 60
1 4 50
2 7 60
3 1 100
3 6 20
4 2 90
4 7 40
5 3 50
5 6 40
6 1 70
6 4 30
6 7 80
```

算法最后输出的结果是：

```c++
Total 100 days
Path: 0（梁山）→ 3（景德镇）→ 6（龙门）→ 4（雄安）→ 7（方腊）
```

#### 考虑费用的最短路径问题

给你 n 个点、m 条无向边，每条边都有长度 d 和花费 p，给你起点 s、终点 t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。

**输入要求**：输入 n、m，点的编号是1~ n，然后是 m 行，每行 4 个数 a、b、d、p，表示 a 和 b 之间有一条边，且其长度为 d，花费为 p，最后一行是两个数 s、t，起点 s，终点 t，n 和 m 为 0 时输入结束。

n 的取值范围为 (1,1000]，m 的取值范围为 (0,100000)，并且 s 不等于 t。

**输出要求**：输出一行有两个数，最短距离及其花费，空格分隔。

很多读者一看到最短路径、最小花费，很容易将此题误判为“最小费用最大流”问题，其实不然，这道题本质仍然是求最短路径，只是增加了一个费用的判断条件，即在最短路径相同的情况下，选择花费最少的那条。根据题目要求，每条边除了表示距离的权重，还需要表示费用，这就需要调整邻接矩阵的数据结构设计。首先需要定义一个数据结构 Edge_T 存储每条边的两个属性，然后用这个数据模型重新定义邻接矩阵 w：

```c++
typedef struct
{
    int weight;
    int cost;
}Edge_T;

typedef struct
{
    int vertexs;  //题目给出的实际顶点个数
    Edge_T w[MAX_VERTEX][MAX_VERTEX]; //图的矩阵，表示距离和开销
    int start_vertex;   //起始点编号
}Problem_T;
```

根据题意，dist 也要增加一个表示当前最小费用的属性 cost（题目没有要求输出完整路径信息，因此不需要 path 属性）：

```c++
typedef struct
{
    int value;
    int cost;
    bool is_in_t;
}Dist_T;
```

和上一个例题一样，设计好数学模型，定义好新的数据结构之后，就要修改代码，使之适应新的数学模型或数据结构定义。根据分析，需要修改的地方仍然是第（2）步数据初始化的地方和第（4）步修改最短路径信息的地方。初始化的修改很简单，就是增加对 dist 数据的 cost 元素初始化，如果从起始点到 Vi 存在有效路径，则 dist[Vi].cost 初始化为这条边的费用，否则将 dist[Vi].cost 初始化为 0。

```c++
dj->dist[i].is_in_t = false;
dj->dist[i].value = p_data->w[p_data->start_vertex][i].weight;
dj->dist[i].cost = p_data->w[p_data->start_vertex][i].cost;
```

对第（4）步的修改，主要是对判断条件进行修改，原来的判断条件只是直接比较距离，现在需要在距离相等的情况下，增加对费用的判断。前面设计数学模型的时候，给 dist 数组增加了一个 cost 属性，这个属性承载着和 value 属性一样的使命，就是存放从起始点到当前顶点的最小费用。既然意义一样，那么两个属性的处理方式和判断最小值的依据也是一样的，理解了这一点，代码的修改就比较简单了：

```c++
int new_dist = dj->dist[min_vi].value + p_data->w[min_vi][j].weight;
    int new_cost = dj->dist[min_vi].cost + p_data->w[min_vi][j].cost;
    //从起点到 min_vi 的最小距离加上 min_vi 到 j 的距离之和小于从起点直接到 j 的距离
    //或者距离相等，但是费用比较小
    if ((new_dist < dj->dist[j].value) || ((new_dist == dj->dist[j].value) && (new_cost < dj->dist[j].cost)))
    {
        //替换 dist 数组中对应顶点的值
        dj->dist[j].value = new_dist;
        dj->dist[j].cost = new_cost;
    }
```

问题的解决是不是比想象中简单？只要能理解题意，设计出合适的数学模型和数据结构，套用一下算法模板，一个看起来无从下手的问题解决了。很多“玩”算法 Online Judge 的人，“玩”的就是这个套路。

#### 总结

这一课我们根据对 Dijkstra 算法原理的理解，设计了一个简单的算法实现，并将这个算法实现作为模板，稍加修改就解决了两个常见的算法问题。在设计算法实现的过程中，介绍了针对 Dijkstra 算法建模需要考虑的细节问题，并对着代码讲解了如何将文字描述的算法原理翻译成算法代码，随后通过两个典型的应用 Dijkstra 算法的问题，介绍了如何根据具体问题修改数据模型（模型修改的原则），以及在新的数学模型基础上如何调整算法实现并解决问题的过程。希望读者通过这一课的学习，了解 Dijkstra 算法几个关键步骤是如何实现的，并学会最短路径问题的建模方法，今后遇到此类问题时能独立解决问题。