### 训练营学习笔记1

### 3-3 狼、羊、菜和农夫过河问题

农夫需要把狼、羊、菜和自己运到河对岸去（不知道为啥要运狼，别问我），只有农夫能够划船，而且船比较小，除农夫之外每次只能运一种东西，还有一个棘手的问题，就是如果没有农夫看着，羊会偷吃菜，狼会吃羊。请考虑一种方法，让农夫能够安全地安排这些东西和他自己过河。

#### 算法设计思路

这是一个很简单的问题，在狼、羊和菜这个食物链上，关键是中间的羊，因为狼不吃菜，所以要安全过河，农夫的第一件事就是带羊走，拆开这个食物链。

但是计算机无法理解这个关键的羊，所以我们仍然采用穷举法来解决这个问题，同时借助于穷举搜索找出所有过河的方法。

这个题目的解决思路和“三个水桶倒水”问题的解决思路类似，就是对状态进行穷举搜索，从初始状态开始穷举所有的状态变化，直到某一次变化后得到问题解决的最终状态，就输出一个结果。

前面的几课中已经多次提到穷举法的两个关键步骤，这里不再列出。接下来就直接从这两个步骤入手，介绍如何设计这个问题的穷举算法。

#### 定义问题的状态

在确定以何种方法对解空间进行穷举搜索之前，首先要定义问题的解。

虽然这个题目的要求是给出农夫带着他的小伙伴过河的动作，但是单纯考虑对动作的穷举是没有意义的，因为问题最后的解决状态是农夫、狼、羊和菜过到河对岸，能最终产生这种状态的动作才有意义，为了判断动作的有效性，需要定义一个合适的状态来描述这个游戏在某个时刻的局面。

考虑一下这个题目涉及的所有元素：农夫、狼、羊、菜、船和河，河是固定的，没有状态变化，因为只有农夫可以划船，所以船可以看作和农夫是一体的，简化后其实有 4 个元素需要考虑，分别是农夫、狼、羊和菜。

如图（1）所示的一种过河的过程，状态的定义只要能表达农夫、狼、羊和菜的位置关系即可。在确定以何种方法对解空间进行穷举搜索之前，首先要定义问题的解。虽然这个题目的要求是给出农夫带着他的小伙伴过河的动作，但是单纯考虑对动作的穷举是没有意义的，因为问题最后的解决状态是农夫、狼、羊和菜过到河对岸，能最终产生这种状态的动作才有意义，为了判断动作的有效性，需要定义一个合适的状态来描述这个游戏在某个时刻的局面。考虑一下这个题目涉及的所有元素：农夫、狼、羊、菜、船和河，河是固定的，没有状态变化，因为只有农夫可以划船，所以船可以看作和农夫是一体的，简化后其实有 4 个元素需要考虑，分别是农夫、狼、羊和菜。如图（1）所示的一种过河的过程，状态的定义只要能表达农夫、狼、羊和菜的位置关系即可。

![avatar](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602224622.png?raw=true)

从图（1）可以看出来，状态(a)到(h)变化的其实就是这 4 个元素的位置，每个元素的位置只有两个状态，即在河的左岸和在河的右岸；

问题的初始状态是农夫、狼、羊和菜都在河的左岸，得到解的终止状态是农夫、狼、羊和菜都在河的右岸。

我们用一个四元组来表示四个元素的位置状态，那么初始状态为 [Left,Left,Left,Left]，最终的结果状态为 [Right,Right,Right,Right]。

#### 状态树和解空间

和“三个水桶等分 8 升水”问题一样，对所有状态穷举搜索的结果也是一棵状态树，根节点是初始状态，叶子节点就是解决问题的状态。

这个题目由于限制条件比较特殊，只有农夫可以划船，一次只能带一个小伙伴，同时狼、羊和菜又不能愉快地在一起玩耍，所以状态树上很多状态都是非法状态，客观上起到了很好的剪枝效果。

如图（2）所示的状态树中，蓝色的状态表示此状态已经和之前的状态重复，红色的状态表示这是一个非法状态，不是出现狼吃羊的情况，就是出现羊吃菜的情况。绿色状态是搜索到了结果状态，这是状态树的叶子节点。

![QQ截图20190602225418](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602225418.png?raw=true)

状态树上绿色的节点是要搜索的结果状态，从结果状态到根节点之间的状态序列，就是问题解决的过程，有多个绿色的节点表示有多个解决问题的过程。

根据题目的意图，最终的结果是要输出这条转换路径的过河过程，实际上就是与状态转换路径相对应的动作路径，或动作列表。当定义了动作的数学模型后，就可以根据状态图中状态转换路径找到对应的动作列表，依次输出这个路径上每个状态对应的动作就可以得到一个完整的过河过程。

#### 状态的数据模型

根据之前对状态的定义，状态的数据模型就是农夫、狼、羊和菜的位置，位置定义 LOCATION 就是两个状态，LOCATION::LEFT 表示对应的元素在河的左岸，LOCATION::RIGHT 表示对应元素在河的右岸（就是过河状态）。

```c++
struct ItemState
{
    ……
    LOCATION farmer,wolf,sheep,vegetable; // 四个元素的位置
    ACTION curAction; // 此状态对应的动作
}
```

curAction 是当前状态绑定的过河动作，即前一个状态通过这个过河动作转变成当前状态。

记录状态对应的过河动作的目的是能够在输出结果时，按照状态演变序列的顺序输出过河动作。



#### 过河动作的数据模型

两个静态的位置状态是通过过河动作建立关联的，分析这个题目，我们注意到，狼、羊和菜是不会自己过河的，因为只有农夫会划船。

农夫可以自己过河，也可以带一个物品过河，当然，从河对岸返回时也是一样的情况。由此可见，本问题的过河动作其实只有 8 个固定动作，分别是：

- (1)农夫自己过河
- (2)农夫带狼过河
- (3)农夫带羊过河
- (4)农夫带菜过河
- (5)农夫自己返回
- (6)农夫带狼返回
- (7)农夫带羊返回
- (8)农夫带菜返回

把一个状态与以上动作结合，就可以转化得到一个新状态，但是需要注意的是，并不是所有的动作都适用于对应的状态，比如对于农夫在河的左岸的状态，动作（5）~（8）代表的返回动作就都不适用。

同样，对于一个菜已经在河对岸的状态，动作（4）就不适用。

在搜索过程中对过河动作遍历的时候，要根据这些情况合理地剪掉一些分支。

根据以上描述，过河动作 ACTION 定义如下：

```c++
num class ACTION
{
    GO_SELF,
    GO_WITH_WOLF,
    GO_WITH_SHEEP,
    GO_WITH_VEGETABLE,
    BACK_SELF,
    BACK_WITH_WOLF,
    BACK_WITH_SHEEP,
    BACK_WITH_VEGETABLE,
};
```

##### 设计搜索算法

我们讨论的状态都是静止的，如果不是有过河动作作用到状态上，状态是不会发生变化的。

对状态树的搜索，其实就是把 8 个过河动作依次与状态结合，演变为新的状态的过程。

与“三个水桶等分 8 升水”问题一样，本题的搜索算法依然采用深度优先遍历，从初始状态节点开始，一直搜索到合法状态为止，在这个过程中，需要记录已经搜索过的状态，避免出现重复状态导致算法进入死循环。

```c++
struct ActionProcess
{
    ACTION  act_name;
    std::function<bool(const ItemState& current, ItemState& next)>  TakeAction;
};

ActionProcess actMap[] = 
{
    { ACTION::GO_SELF,                ProcessFarmerGo                },
    { ACTION::GO_WITH_WOLF,           ProcessFarmerGoTakeWolf        },
    { ACTION::GO_WITH_SHEEP,          ProcessFarmerGoTakeSheep       },
    { ACTION::GO_WITH_VEGETABLE,      ProcessFarmerGoTakeVegetable   },
    { ACTION::BACK_SELF,              ProcessFarmerBack              },
    { ACTION::BACK_WITH_WOLF,         ProcessFarmerBackTakeWolf      },
    { ACTION::BACK_WITH_SHEEP,        ProcessFarmerBackTakeSheep     },
    { ACTION::BACK_WITH_VEGETABLE,    ProcessFarmerBackTakeVegetable }
};
```

每个处理逻辑需要做三件事情，首先要判断当前状态是否适用于对应的动作，接着根据对状态进行相应的改变并将对应的动作记录到新状态中，最后判断转化后的状态是不是一个合法的状态。

仍然以`ACTION::GO_WITH_VEGETABLE`动作为例，其处理逻辑 ProcessFarmerGoTakeVegetable() 的实现如下：

```c++
bool ProcessFarmerGoTakeVegetable(const ItemState& current,ItemState& next)
{
    if((current.farmer != LOCATION::LEFT) || (current.vegetable != LOCATION::LEFT))
        return false;
    next = current;
    
    next.farmer = LOCATION::RIGHT;
    next.vegetable = LOCATION::RIGHT;
    next.curAction = ACTION::GO_WITH_VEGETABLE;
    
    return IsCurrentStateValid(next);
}
```

对 8 个动作循环一遍，即可完成对一个状态的遍历，并根据情况生成新的状态，所以，遍历的动作就是对 actMap 做一个循环，依次调用每个动作对应的 TakeAction 逻辑。

遍历代码的主体大致是这样的：

```c++
ItemState next;
for(auto& act : actMap)
{
    if(act.TakeAction(current,next))
    {
        .....
    }
}
```

#### 剪枝和优化（重复状态和非法状态判断）

根据图（2）显示的状态树，需要剪枝处理的情况有两种，一种是非法状态，另一种是重复的状态。

对非法状态的过滤，体现在过河动作对应的处理逻辑中，ProcessFarmerGoTakeVegetable() 函数中最后调用 IsCurrentStateValid() 判断这个状态是不是合法状态。

对于产生非法状态的情况，ProcessFarmerGoTakeVegetable() 函数返回 false，遍历循环就跳过这个动作，继续遍历下一个动作。

对重复状态的过滤，是在 TakeAction 逻辑返回 true 的情况下才进行的，如下代码所示，两个 if 判断就是对上述两种情况的剪枝处理。

```c++
if(act.TakeAction(current, next))
{
    if(!IsProcessedState(states, next))
    {
        ......
    }
}
```

#### 代码实现

#### 搜索算法代码

SearchState() 函数实现状态树的搜索遍历，整体结构和“三个水桶等分 8 升水”问题类似，由两部分内容组成：

第一部分的 IsFinalState() 函数判断当前状态序列中最后一个状态是不是最终结果状态，如果是就输出一组状态序列（以及对应的过河动作）；

如果当前状态序列中最后一个状态不是结果状态，则转入第二部分开始搜索新的状态。

```
void SearchStates(deque<ItemState>& states)
{
    ItemState current = states.back(); /*每次都从当前状态开始*/
    if(current.IsFinalState())
    {
        PrintResult(states);
        return;
    }

    ItemState next;
    for (auto& act : actMap)
    {
        if(act.TakeAction(current, next))
        {
            if(!IsProcessedState(states, next))
            {
              states.push_back(next);
              SearchStates(states);
              states.pop_back();
            }
        }
    }
}
```

#### 判断非法动作和重复状态

如果农夫不在场，狼会吃羊，羊会吃菜，根据这个描述，无法直接写出代码，把这句话换一种说法，则会更容易转化成代码实现：

- 如果狼和羊位置相同，并且农夫的位置与它们不同，则是非法状态；
- 如果羊和菜位置相同，并且农夫的位置与它们不同，则是非法状态；
- 其他情况均为合法状态。

这样一来，这个判断函数就比较容易用代码描述了：

```c++
bool IsCurrentStateValid(const ItemState& current)
{
    if ((current.wolf == current.sheep) && (current.sheep != current.farmer))
    {
        return false;
    }

    if ((current.vegetable == current.sheep) && (current.sheep != current.farmer))
    {
        return false;
    }

    return true;
}
```

重复状态的判断更简单，就是对状态队列进行一次查找操作：

```c++
bool IsProcessedState(deque<ItemState>& states, const ItemState& newState)
{
    auto it = find_if( states.begin(), states.end(),
        [&newState](ItemState& item) { return item.IsSameState(newState); });

    return (it != states.end());
}
```

### 3-4 24点计算器

24 点游戏是一个很有意思的数字游戏，也是一道常见的算法面试题。

题目是这样的：任给四个数（为了便于人们心算或口算，一般都是小于 10 的数），对四个数字用各种组合进行加、减、乘、除四则运算，看看结果是否能等于 24？

对于面试题来说，这是一个典型的穷举类型算法问题。

这个题目比较有意思的地方是它除了要对数字组合进行枚举，还要对四个运算符进行组合。

这一课我们要介绍的方法有点特殊，它没有简单地使用穷举遍历，而是采用穷举法和分治法相结合的方法来解决这个问题，这种方法比数字 + 运算符一起枚举的方法简单，容易理解，整个算法只有大约 40 行有效代码，其中主体部分有效代码只有不到 20 行，快来看看是怎么回事儿吧。

#### 问题分析与建模

这个算法问题的难点主要有两个，

一个是数字和运算符的穷举遍历，另一个是将四则运算表达式作为结果输出。

无论是运算符遍历还是表达式输出，都要考虑运算符的优先级，必要时要加括号。

当然，也可以采用后缀表达式的形式，避免在枚举遍历的过程中考虑括号的问题。一般我们书写和计算都采用中缀表达式，中缀表达式的特点是运算符始终位于两个操作数的中间，对于运算符的优先级采用括号的方式解决，比如以下四则运算采用的就是中缀表达式的形式：

7 + ( 3 + 2 ) × 4 − 8

后缀表达式又称为“逆波兰表达式”，上述中缀表达式转换成后缀表达式后就是这个样子：

732 + 4 × + 8 −

后缀表达式通过运算符的位置来决定计算顺序，避免使用括号，便于计算机计算处理。

后缀表达式的求解计算一般用栈比较方便，具体的方法就是从左向右扫描表达式，当遇到操作数时就将操作数入栈；

当遇到操作符时就从栈中弹出两个操作数，将操作数与这个运算符一起计算得到一个结果，并将这个结果入栈，然后继续扫描表达式，直到结束。

后缀表达式的计算以及将中缀表达式转变成后缀表达式也都是经典数据结构课程的算法，这一课我们就不具体介绍了。大家如果感兴趣可以在读者圈中留言，我们后面可以安排补充一篇关于后缀表达式的内容。

引言部分提到过，我们这个方法会用到分治法，分治法的主要特点之一就是通过分解子问题的方式减小问题的规模，怎么划分子问题呢？

复习一下前面讲过的内容，子问题和原始问题必须是同构的，所谓同构就是问题必须是一样的，问题的模式不能变，能变的只是问题的规模。

对于这个问题来说，原始问题的规模是 4 个数字计算 24 点，那么分解子问题可以从两个方向考虑：

一种是只考虑减少问题的规模，对于这个问题来说，减少规模不就是变成 3 个数字计算 24 点吗？然后再减少为两个数字计算 24 点，以此类推，直到问题能够直接求解为止；

另一种是在减少问题规模的同时，调整结果的范围，同样，对这个问题来说，假如说我将问题规模从 4 个变成 3 个，被排除的数字是 3，那么子问题就应该变成“3 个数字计算 21 点”。进一步将问题规模减少成两个数字时，假如被排除的数字是 7，则子问题就变成“2 个数字计算 14 点”，以此类推，直到问题能直接解决为止。

本课我们尝试采用第一种方法来分解子问题。我们的思路是每次从 4 个数字中任选两个，分别应用加、减、乘、除四种运算方法得到 4 个计算结果，每个计算结果与剩下的 2 个数字一起组成一个规模为 3 个数字的子问题，一共可以得到 4 个子问题，其变化过程如图（1）所示（图中第一行的数字为 4 个数字的索引位置，第二行的数字分别是 4 个待计算数字，第三行是计算过程），使用第一个数字和第二个数字组合计算，得到了一组 4 个子问题，然后用第一个数字和第三个数字组合计算，得到了另一组 4 个子问题：

![QQ截图20190602234202](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602234202.png?raw=true)

根据组合规则，从 4 个数字中选两个进行不能有重复的排列，可以得到 P_{4}^{2} = 12 个组合结果，也就是说总共有 12 × 4 = 48 个规模为 3 个数字的子问题，图（1）展示了其中的两组。

接下来，我们选择图（1）中紫色标识的那个子问题，再进一步应用上述思想减小问题的规模。

从 3 个数字中任选两个，然后应用加、减、乘、除四种运算方法得到 4 个计算结果，每个计算结果与剩下的 1 个数字组成一个规模为两个数字的子问题，又可以得到 4 个子问题。

从 3 个数字中任选两个进行不重复的排列，可以得到 P_{3}^{2} =6 个组合结果，也就是说总共有 6 × 4 = 24 个规模为两个数字的子问题，图（2）展示了其中一组，也就是第一个数 3/7 和第二个数 3 的组合情况：

![QQ截图20190602234530](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602234530.png?raw=true)

3/7 和 3 经过加、减、乘、除得到了 4 个结果，分别是 24/7、−18/7、9/7 和 1/7，将它们与剩下的数字 7 组合，得到了图（2）所示的 4 个子问题。

接下来，我们选择图（2）中黄色标识的子问题，再进一步应用上述思想减小问题的规模。

从两个数字中任选两个，然后应用加、减、乘、除四种运算方法得到 4 个计算结果，得到 4 个规模是 1 个数字的子问题，如图（3）所示：

![QQ截图20190602234623](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602234623.png?raw=true)

从两个数字中任选两个进行无重复的排列，可以得到 P_{2}^{2} =2 个组合结果，也就是说总共有 2 × 4 = 8 个规模为 1 个数字的子问题，图（3）展示了其中一组，即 24/7 与 7 分别进行加、减、乘、除计算。

此时问题的规模已经减小到可以直接得到结果的程度了，淡灰色标识的那个子问题结果是 24，就是我们要求解的结果。当然，从其他分支也能得到正确的结果，从图（1）到图（3）只展示了其中一个结果的生成过程。

以上就是我们介绍的穷举法 + 分治法解决 24 点计算问题的算法分析过程。

前面提到过，这个问题的难点有两个，上述分析过程解决了第一个，即数字和运算符的穷举遍历问题。

还有第二个问题，也就是将四则运算表达式作为结果输出的问题没有解决。

可能大家已经从几个图上看到了，图的第三行就是最后要输出的中缀表达式，这是怎么做到的呢？其实很简单，我们给每个数字都指定了一个“出身”，所谓的“出身”就是描述这个数字的来历，或者是计算过程。

每个数字的“出身”记录了这个数字的计算过程，当数字被带入到子问题的时候，这个计算过程也跟着被带入到子问题，并随着子问题的求解过程一步一步带到最后。

对于原问题来说，4 个数字的出身就是数字本身，当两个数字参与一次计算称为一个结果数字时，就将这两个数字的计算过程作为结果数字的“出身”。

为了简化算法实现，避免处理运算符的优先级，我们对每个运算过程都用了括号。

好了，根据上面的分析，我们已经明确了问题和子问题的定义，就是“用 m 个数排列组合计算 24 点（1⩽m⩽4）”。

所以我们的子问题的参数就是 m 个数，考虑用数组来组织这 m 个数。每个数除了数字本身，还有一个出身，用以下数据结构来描述这个“数”：

```c++
typedef struct
{
    double num;
    std::string num_str;
}Number;
```

num_str 是这个数的“出身”，用字符串描述没问题，num 是数字本身，但是数据类型用了 double，这也是实际计算过程的需要，毕竟从上图中也能看到，我们的计算方法是支持分数形式的，中间计算过程会出现浮点数，最终子问题定义就是 Calc24() 函数的参数：

```c++
void Calc24(const std::vector<Number>& nums)
{
    //求解子问题
}

//原始问题的定义
std::vector<Number> numbers = { { 3, "3" },{ 3, "3" },{ 7, "7" },{ 7, "7" } };
Calc24(numbers);
```

随着子问题规模的减小，nums 数组的长度由 4 减小到 3，再减小到 2，直至减到 1，numbers 就是子问题的初始状态，也就是原始问题。

考虑到一些读者不熟悉 C++，介绍一下上面的数组定义。首先 std::vector<…> 定义了一个向量 vector，vector 的行为实际上就是数组，其内存结构是连续的，并且提供下标运算符 []，可以像访问原生数组一样使用 vector（当然，也可以使用迭代器）。

`std::vector<Number>` 表示数组的每个元素是 Number 类型。Number 是个数据结构定义，它有两个成员，分别是 num 和 num_s。

#### 算法实现

算法实现要解决的问题是将上述分析过程落地实现，完成 Calc24() 函数。

本课程基础部分介绍分治法的时候，我提到过“递归作为一种算法的实现方式，与分治法是一对儿天然的好朋友”，这个问题我们也决定使用递归方式实现 Calc24() 函数。

这意味着 Calc24() 函数要在内部构造子问题的`std::vector<Number>`数组，并将其作为递归调用 Calc24() 函数时的参数，从而实现对子问题的求解。

Calc24() 函数对子问题进行处理的时候，要对子问题规模是 1 个数的情况做处理，这实际上也是递归函数的退出（递归终止）条件。

对于这个问题来说，当子问题的规模是 1 个数的时候，就要检查这个数是否是 24，如果是则输出一组结果，并退出递归处理；如果不是，说明这个穷举出来的结果是个无效结果，直接退出递归处理。这部分判断和处理的实现在第 4 行开始的 if (count == 1) 处理流程里，比较简单，就不多说了。对于子问题规模大于 1 的情况，就要选两个数进行计算，对于 P_{n}^{2} 问题，常用的代码实现模式就是两重循环。

下一课我会介绍另一种常见的方法，但是那种方法不适合用递归的方式处理不同规模的子问题，所以 Calc24() 函数使用两重循环实现对 P_{n}^{2}的处理。

代码的第 14 行和第 16 行的两个 for 循环就是处理 P_{n}^{2}的排列，因为不能有重复，所以当 (i == j) 的时候，要排除掉这种情况，就是 18 和 19 两行代码做的事情。

第 21 行的 for 循环是对加、减、乘、除四种运算的枚举，也就是将前面两重 for 循环选出来的两个数进行四种运算，得到四个结果。acops 是个函数数组，每一个 op 是一种运算方式，负责将 nums[i]、nums[j] 进行计算，并将结果存入到 new_num 中。

第 27 行定义的`sub_nums`数组是子问题的描述，首先将前面计算的`new_num`加入到`sub_nums`数组中，然后将 nums 数组中没有被选中的数字也加入到`sub_nums`数组中，组成新的子问题。

第 30 行的 for 循环就是将 nums 数组中没被选中的数加入到`sub_nums`数组中。子问题`sub_nums`数组准备好以后，

在第 37 行递归调用`Calc24(sub_nums)`求解子问题。

对于第 30 行的 for 循环来说，当 nums 的规模是 4 个数的时候，这个 for 循环排除掉已经选中的 i 和 j 后，将剩下的两个数加入到`sub_nums`数组中，形成 3 个数的子问题。

当 nums 的规模是 3 个数的时候，这个 for 循环将剩下的 1 个数加入到`sub_nums`数组中，形成两个数的子问题。

当 nums 的规模是两个数的时候，这个 for 循环实际上空转了两次排除掉已经选中的 i 和 j ，没有任何数被加入到`sub_nums`数组中，最后得到只有 1 个数的子问题。用递归方式求解子问题，最难的部分是如何用一致的代码处理不同规模和属性范围的子问题。

前面的两重 for 循环和对`sub_nums`数组的处理，都体现了这种思想。

```c++
void Calc24(std::vector<Number>& nums)
{
    std::size_t count = nums.size();
    if(count == 1) // 当只有一个数的时候，说明计算完成，可以判断结果了
    {
        if(nums[0].num == 24)
        {
            std::cout << nums[0].num_str << "=" << nums[0].num <<std::end;
        }
        return;
    }
    
    // 两重循环，从nums中找两个数的组合
    for(std::size_t i = 0; i<count;i++)
    {
        for(std::size_t j = 0; j<count; j++)
        {
            if(i == j) // 排除相同的情况
            {
                continue;
            }
            
            for(auto & op : acops)// 对四中运算进行枚举
            {
Number new_num;
                //运算可能失败，比如除数是 0 的情况，不再继续处理这个运算符，相当于剪枝效果
                if (op(nums[i], nums[j], new_num))
                {
                    std::vector<Number> sub_nums;//定义子问题
                    sub_nums.push_back(new_num);
                    //除了被选出来的两个数，将剩下的数加入子问题
                    for (std::size_t k = 0; k < count; k++) 
                    {
                        if ((k != i) && (k != j))
                        {
                            sub_nums.push_back(nums[k]);
                        }
                    }
                    Calc24(sub_nums); //解决子问题
                }
            }
        }
	}
}
```

现在说说 acops，它是一个计算函数的数组，定义了对两个操作数的加、减、乘、除四种运算。std::function<…> 是个可调用对象包装器，这里包装的是一个这样的调用接口：

```c++
bool (const Number&, const Number&, Number&)
```

这个接口有两个 const Number& 类型的入参，一个 Number& 类型的出参和一个 bool 类型的返回值，两个入参是参与计算的操作数，出参是计算的结果。

四个操作符对应的可调用对象是用 lamda 表达式定义的操作函数。

这些操作函数的的作用很简单，就是计算两个操作数，当然，还有很重要的一点，就是拼装计算结果的“出身”。

前面分析算法的时候提到过，一个数的“出身”很重要，即使数字本身算对了，如果“出身”拼装的不正确，输出的结果也不正确。

“出身”拼装很简单，就是将参与计算的两个数的“出身”用操作符连接在一起，然后两端加上一对儿括号，就得到结果数字的“出身”了。这里面只有除法比较特殊一点，因为被除数不能为 0，所以加了个判断。当其返回 false 的时候，相当于做了一次剪枝操作。

```c++
std::function<bool (const Number&, const Number&, Number&)> acops[] = 
{
    [](const Number& d1, const Number& d2, Number& dr) 
    { 
        dr.num = d1.num + d2.num; 
        dr.num_str = '(' + d1.num_str + '+' + d2.num_str + ')';
        return true; 
    },
    [](const Number& d1, const Number& d2, Number& dr) 
    { 
        dr.num = d1.num - d2.num;
        dr.num_str = '(' + d1.num_str + '-' + d2.num_str + ')';
        return true;
    },
    [](const Number& d1, const Number& d2, Number& dr) 
    {
        dr.num = d1.num * d2.num;
        dr.num_str = '(' + d1.num_str + '*' + d2.num_str + ')';
        return true;
    },
    [](const Number& d1, const Number& d2, Number& dr) 
    {
        if (d2.num == 0)
            return false;
        dr.num = d1.num / d2.num;
        dr.num_str = '(' + d1.num_str + '/' + d2.num_str + ')';
        return true;
    }
};
```

为什么不直接在 Calc24() 函数里用 switch…case 或 if…else 直接进行加、减、乘、除计算，反而弄个可调用对象数组，这不是把问题搞复杂了吗？

这正是我希望大家理解的地方，这种表结构的处理，也是一致性处理的常用技巧，你不觉得这样做 Calc24() 函数的实现很简洁吗？简洁的代码可以避免眼睛在无聊的琐碎代码上停留太长时间，有助于我们理解算法实现的重点。

#### 一个数字的排列组合的技巧

上一课的实现部分我们介绍了用两重循环实现从 n（n > 2）个数字中任选两个数字进行组合的操作，实际上，对于 n 是已知常数的情况，可以用事先安排好组合顺序的方式，直接用一重循环完成选取两个数字组合，减少编码实现的复杂度。

以本题为例，已知每次都是从 4 个数字中选择两个（不能有重复），计算 P_{4}^{2} 的结果是 12，可选数字的位置组合分别是 {1,2}、{1,3}、{1,4}、{2,1}、{2,3}、{2,4}、{3,1}、{3,2}、{3,4}、{4,1}、{4,2} 和 {4,3} 共 12 组，有且只有这 12 组，不会再有别的了。

每一组表示选择的两个数在数组结构中的位置索引，对数组来说，往往就是数组下标。{1,2} 表示数组中的第一个和第二个数字，对于编程实现来说，要考虑数组索引是从 0 开始的，以 C++ 为例，我们定义这个位置组合数组为

```c++
std::vector<std::pair<int, int>> posArray = 
{
    { 0, 1 }, { 0, 2 }, { 0, 3 }, 
    { 1, 0 }, { 1, 2 }, { 1, 3 }, 
    { 2, 0 }, { 2, 1 }, { 2, 3 }, 
    { 3, 0 }, { 3, 1 }, { 3, 2 }
};
```

std::vector<…> 定义了一个数组，前面已经介绍过了，这个数组的数据元素类型是`std::pair<int, int>`，从名字可以看出来，这是两个 int 型数据组成的一个数字对

前一个数字的访问用 first 代替，后一个数字的访问用 second 代替。

使用的时候就可以这样使用：

```c++
std::vector<int> numArray = { 3, 3, 7 ,7 };
    for (auto& pos : posArray)
    {
        //第一个操作数是 numArray[pos.first]
        //第二个操作数是 numArray[pos.second]
        int sum = numArray[pos.first] + numArray[pos.second];
    }
```

numArray 是一个由 int 型数据元素组成的数组，就是我们要枚举的对象数据，for 循环遍历 posArray 数组，对每一个 posArray 的元素（就是位置关系数字对），执行循环体内的操作。

类似这样的技巧有时也被称为“以空间换时间”的策略，

有很多这样的技巧，不仅算法设计中常用，软件开发中也常用，了解一下，有益于开阔思路。另外，上述方法用 Java 实现起来差不多是这个意思：

24 点游戏的算法总少不了对数字的枚举加上对运算符的枚举，我们这一课介绍的实现算法虽然简洁，但是也包含了这两个内容，Calc24() 函数中前两个 for 循环实现了对数字的穷举，

第三个 for 循环实现了对运算符的穷举。我们的算法还缺少一个很重要的内容，就是去除重复结果，去重的方法也很简单，只要再增加十行左右的代码就行了，这个就作为作业留给读者去实现了，我会在介绍课程后半部分的时候将答案上传到 GitHub 上。



### 3-5 爱因斯坦的思考题（上）

不同问题的穷举法算法实现最大的差异点就是搜索算法的不同

前几课介绍了线性空间的搜索、树状空间的搜索，这一课我们再介绍一种求解问题的搜索算法，其搜索的空间是一个**二维表**

对二维表中的每个元素进行枚举遍历，依次确定每个表格元素的值，当二维表中所有表格元素的值都确定后，检查其结果是否符合问题解的要求，如果满足要求，则输出一个结果，如果不满足要求，则按照一定的顺序继续遍历各个表格元素的值。

这也是一种典型的解空间搜索方式，通过对这个问题的理解，未来遇到类似的问题，或三维表空间的问题，都可以用类似的方法设计搜索算法。



#### 问题介绍

题目是这样的，据说有五个不同颜色的房间排成一排，每个房间里分别住着一个不同国籍的人，每个人都喝一种特定品牌的饮料，抽一种特定品牌的烟，养一种宠物，没有任意两个人抽相同品牌的香烟，或喝相同品牌的饮料，或养相同的宠物，问题是**谁在养鱼作为宠物？**

为了寻找答案，爱因斯坦给出了 15 条线索：

- （1）英国人住在红色的房子里
- （2）瑞典人养狗作为宠物
- （3）丹麦人喝茶
- （4）绿房子紧挨着白房子，在白房子的左边
- （5）绿房子的主人喝咖啡
- （6）抽 Pall Mall 牌香烟的人养鸟
- （7）黄色房子里的人抽 Dunhill 牌香烟
- （8）住在中间那个房子里的人喝牛奶
- （9）挪威人住在第一个房子里面
- （10）抽 Blends 牌香烟的人和养猫的人相邻
- （11）养马的人和抽 Dunhill 牌香烟的人相邻
- （12）抽 BlueMaster 牌香烟的人喝啤酒
- （13）德国人抽 Prince 牌香烟
- （14）挪威人和住在蓝房子的人相邻
- （15）抽 Blends 牌香烟的人和喝矿泉水的人相邻



一般人解决这种问题，会像做数独题目一样，用纸和笔画一些表格，写写画画，一步一步慢慢推理，必要时需要一些假设进行尝试，如果假设错误就从假设点推倒重来。

我不属于那 2%，我缺乏耐心去做这个事情，所以我一直解不出这个问题，直到有一天，我的一个聪明朋友告诉我一个答案，

我对比了一下前面提到的 15 条线索，发现这是一个正确答案。答案是住在绿色房子里的德国人养鱼做宠物，但是有个问题却难住了我，这是唯一的答案吗？

经验告诉我，对于这种自由度很大的问题，常常有多种可能性。我决定设计个算法，让计算机帮忙找出所有可能的解，这正是穷举法的用武之地。



#### 数据的状态与数据模型

这个题目问的是谁在养鱼作为宠物

但是很明显，单纯考虑谁养鱼不是一个可以独立求解的问题，也就是说，你无法在忽略其他问题的情况下，单独对这个问题进行穷举遍历。

这个问题和题目给出的 15 条线索一样，都是最终答案的一部分，这个最终答案就是下面表格所展示的内容，知道了谁养鱼，也就能同时知道这个人是德国人，住在绿色房子里，喜欢喝咖啡和抽 Prince 牌子的香烟。

通过对问题的理解，这里描述了 5 个人，有不同的国籍，住不同颜色的房子，养不同的宠物，抽不同的香烟，喝不同的饮料，显然这个二维表格描述的整体才是我们要求的解。

| 房子颜色 | 国籍 | 饮料 | 宠物 | 烟         |
| -------- | ---- | ---- | ---- | ---------- |
| 黄色     | 挪威 | 水   | 猫   | Dunhill    |
| 蓝色     | 丹麦 | 茶   | 马   | Blends     |
| 红色     | 英国 | 牛奶 | 鸟   | PallMall   |
| 绿色     | 德国 | 咖啡 | 鱼   | Prince     |
| 白色     | 瑞典 | 啤酒 | 狗   | BlueMaster |

确定了问题的解，那么问题的解空间和穷举过程中的状态也就确定了。

解空间就是所有这五类元素（房子颜色、国籍、饮料、宠物和烟）的枚举组合，每个组合的结果就是一个状态，状态是上述二维表格的一个实例，每个属性都通过枚举组合确定了

但是还不一定是问题的解，因为判断条件不一定满足。

确定了解的状态和解空间，接着要确定对状态的穷举遍历方法。

这个题目比之前介绍的三个问题都复杂，我们需要五重枚举，依次对这五类元素进行排列组合才能得到一个完整的状态（二维表）；

另外，对状态是不是正确的解的判断也比其他问题复杂，需要用给出的 15 条线索逐条检查组合得到的状态。

如果某个状态能够通过 15 条线索的检查，那么就认为找到了一个正确的答案，然后输出该答案。

理解问题和写出算法实现之间还有最后一步需要跨越，程序实现有自己的特点，如果数据模型设计不合理，会导致算法实现困难，这一步往往是很多人的瓶颈。

“一千个人眼里有一千个哈姆雷特”，所以，我们在设计这个问题的数据模型的时候，不仅要考虑是否能够实现对解空间的穷举遍历，还要考虑是否能简单高效地判断解的状态是不是正确的解。

接下来要介绍的数据模型设计只是能解决问题的各种数据模型中的一种，为了便于用代码实现算法，这种数据模型中体现了很多设计数据模型常用的技巧。

#### 基本模型的定义

这个问题定义的状态二维表共有 25 个属性，这些属性分为 5 个类别，每个类别都有 5 个不同的值可供选择。

如果任由这 25 个属性离散存在，会给设计算法带来困难，一般算法建模都会用各种数据结构将这些属性组织起来，仔细观察这些属性，会发现每个属性都可以用“类型+值（TLV）”二元组来描述。

举个例子，房子颜色是个类型，黄色就是值，组合成“黄色房子”就是一个属性；

再比如饮料是个类型，啤酒则是值，组合成一个属性就是某个人喝啤酒。

用 TLV 描述每个属性的好处是我们不需要将 25 个属性分成 5 类区别处理，在算法穷举的过程中，可以对这 25 个属性进行一致性处理。根据这个原则，我们把属性的数据结构定义如下：

```c++
typedef enum 
{
    type_house = 0;
    type_nation = 1,
    tye_drink = 2,
    type_pet = 3,
    type_cigaret = 4
}ITEM_TYPE;

typedef struct
{
    ITEM_TYPE type;
    int value;
}ITEM;
```

ITEM_TYPE 是个枚举类型的量，可以是房子颜色、国籍、饮料类型、宠物类型和香烟牌子五种类型之一，

value 是 type 对应的值，value 的取值范围是 0~4，

根据 type 的不同，0~4 代表的意义也不相同。

如果 type 对应的是房子颜色，则 value 取值 0~4 分别代表蓝色、红色、绿色、黄色和白色，如果 type 对应的是饮料类型，则 value 取值 0~4 分别代表茶、水、咖啡、啤酒和牛奶。

为了算法代码的可读性，每种类型都定义了与之对应的常量，以颜色类型为例：

```C++
const int COLOR_BLUE    = 0;
const int COLOR_RED     = 1;
const int COLOR_GREEN   = 2;
const int COLOR_YELLOW  = 3;
const int COLOR_WHITE   = 4;
```

有了属性和值的定义，如何将它们组织起来呢？

观察上面的二维表，我们发现这 25 个属性是个矩阵关系，在两个维度上都存在关系，可以按照类型组织，也可以按照同一推理之间的关系组织。

根据题目描述，每个人住在一种颜色的房子中，喝一种饮料、养一种宠物、抽一种牌子的香烟，这些关系是固定的，一个人不会同时养两种宠物或喝两种饮料。

我们把这种固定的关系称为组（GROUP），一个组中包含一种颜色的房子、一个国籍的人、一种饮料、一种宠物和一种牌子的香烟，他们之间的关系是固定的。既然是这样，是不是可以将 GROUP 数据结构设计成这个样子呢？

```c++
const int GROUPS_ITEMS = 5;
typedef struct tagGroup
{
    ITEM items[GROUPS_ITEMS];
}GROUP;
```

这样设计中规中矩，但是会给算法实现带来麻烦，访问每种属性都要遍历 items，通过每个 items 的 type 属性确定要访问的类型。

比如要查询房子的颜色是不是蓝色，就不得不这么做：

```c++
for(int i = 0, i < GROUPS_ITEMS;i++)
{
    if(items[i].type == type_house)
    {
        if(items[i].value == COLOR_BLUE)
        {
            ......
        }
    }
}
```

在本课程的基础部分，我们在介绍算法设计的常用技巧时提到，在设计数据结构和算法时利用数组下标的技巧，这里又是一个例子。

考虑到上面的麻烦，需要修改 GROUP 的设计，不妨将每种类型在 GROUP 中的位置固定，然后直接利用数据下标进行访问。

比如将房子颜色类型固定为数组第一个元素，将国籍固定为数组第二个元素，以此类推，这样 GROUP 定义中可以不需要属性的类型信息（类型信息已经由数组下标表达），只需要一个值信息即可：

```c++
typedef struct 
{
    int itemValue[GROUPS_ITEMS];
}GROUP;
```

使用这种定义数据结构的方式，不仅可以减少设计算法实现的麻烦，还可以提高算法执行效率。比如现在要查看一个 GROUP 绑定组中房子的颜色是否是蓝色，就可以这样编写代码：

```c++
if(group.itemValue[type_house] == COLOR_BLUE)
{
    ......
}
```

对比前一种的循环遍历方式，不仅效率高，代码实现也简单。



#### 线索模型定义

除了模型表达困难，这个题目比之前介绍的题目的困难之处还在于那 15 条线索的描述，如何将这些看起来毫无章法的描述信息化并用合适的数据模型来表达它们是个很大的挑战。

线索数据模型的意义在于判断一个枚举结果是否正确，如果某个枚举结果能够符合全部 15 条线索，那这个结果就是最终的正确结果。

因此，线索数据结构的定义非常关键，如果定义不好，不仅算法实现会遇到很大的麻烦，而且影响算法实现的效率。即使最后设计出了算法实现，也是到处都是长长的 if…else 分支，本课中多次强调，代码中长长的 if…else 分支结构意味着出现了不良设计的坏味道。

先分析一下这 15 条线索，大致可以分成三类：

第一类是描述某些属性之间具有固定绑定关系的线索，比如，“丹麦人喝茶”和“住绿房子的人喝咖啡”等，线索 1、2、3、5、6、7、12、13 可归为此类；

第二类是描述某些属性类型所在的“组”所具有的相邻关系的线索，比如，“养马的人和抽 Dunhill 牌香烟的人相邻”和“抽 Blends 牌香烟的人和养猫的人相邻”等，线索 10、11、14、15 可归为此类；

第三类就是不能描述属性之间固定关系或关系比较弱的线索，比如，“绿房子紧挨着白房子，在白房子的左边”和“住在中间那个房子里的人喝牛奶”等。

对于第一类具有绑定关系的线索，绑定关系描述中有两组 TLV 的信息。以线索3：“丹麦人喝茶”这条绑定线索为例，第一组 TLV 信息是“国籍-丹麦”，第二组 TLV 信息是“饮料类型-茶”。绑定关系的意义在于对于一个 group 关系来说，当其某个属性符合绑定描述的第一组条件时，则其与第二组 TLV 信息中指定的类型相同的另一个属性的值也必须与第二组 TLV 中要求的值匹配，否则的话就不符合这个绑定关系。

对于绑定类型的线索，其数学模型可以这样定义：

```c++
typedef struct
{
    ITEM_TYPE first_type;
    int first_value;
    ITEM_TYPE second_type;
    int second_value;
}BIND;
```

type 和 value 是某个 group 内某个属性的类型和值，`relation_type`和`relation_val`是与该属性所在的 group 相邻的 group 中与之有关系的属性的类型和值。

以线索10：“抽 Blends 牌香烟的人和养猫的人相邻”为例，type 就是`type_cigaret`，value 就是`CIGARET_BLENDS`（`CIGARET_BLENDS`是个整数型常量），`relation_type`是`type_pet`，`relation_value`是`PET_CAT`（`PET_CAT`是个整数型常量）。同样，线索 10、11、14、15 就可以存储在 relations 数组中：

```c++
const RELATION relations[] = 
{
    { type_cigaret, CIGARET_BLENDS, type_pet, PET_CAT },
    { type_pet, PET_HORSE, type_cigaret, CIGARET_DUNHILL },
    { type_nation, NATION_NORWAY, type_house, COLOR_BLUE },
    { type_cigaret, CIGARET_BLENDS, type_drink, DRINK_WATER }
};
```

对于第三类线索，无法建立统一的数学模型，只能在枚举算法进行过程中直接使用它们过滤掉一些不符合条件的组合结果。

比如线索8：“住在中间那个房子里的人喝牛奶”，就是对每个饮料类型组合结果直接判断 groups[2].itemValue[type_drink] 的值是否等于 `DRINK_MILK`，如果不满足这个线索就不再继续下一个元素类型的枚举。

再比如线索4：“绿房子紧挨着白房子，在白房子的左边”，就是在对房子类型进行组合排列时，将绿房子和白房子看成一个整体进行排列组合的枚举，得到的结果直接符合了线索4的要求。

到这里，问题的状态与数据模型就分析完了，下一课我们继续讲解搜索算法是如何实现的。



#### 搜索算法实现

与其他穷举类算法一样，本问题的穷举法的实现也包含两个典型过程

一个是对所有状态的穷举过程，另一个是对状态的正确判定过程。

本问题的穷举搜索过程明显比之前的几个题目复杂，因为每个状态有 5 个类型，每个类型都要对 5 个值进行排列组合。

#### 枚举所有状态

前几课介绍了几个线性空间的搜索和树状空间的搜索的例子，这些例子中的状态都比较简单，可以边遍历边生成新状态，并且状态的合法性判断也比较简单。

本题则有些特殊，需要对不同类型的元素分别用穷举法进行枚举遍历，然后再将枚举遍历的结果按照组的关系组合起来才能得到一个状态（完整的二维表），并且组合的方法不是线性关系的组合，而是类似阶乘的几何关系的组合。

状态遍历算法的具体思路就是按照 group 中的元素顺序，依次确定状态二维表中各个元素的值。

首先对房子根据颜色组合进行穷举，每得到一组房子颜色组合后，记录到状态二维表的第一列，然后在此基础上对住在房子里的人的国籍进行穷举，将国籍的穷举结果记录到二维状态表的第二列，同时将国籍穷举得到的集合与房子颜色的结果做排列组合，并在这个组合结果的基础上，继续对饮料类型进行穷举和排列组合。

以此类推，直到穷举完最后一种类型得到完整的状态二维表。其遍历组合的过程如图（1）所示，在这么多组合的结果中，只有蓝色的那一个组合结果才完全符合题目的要求，是一个正确的结果。

![穷举](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\穷举.png)

现在考虑算法实现，首先从房子颜色开始枚举。5 间房子、5 种颜色，全排列共有 P55=120 种排列方式。

像这种 n 个属性进行全排列常用的算法实现方式有两种，一种是用 n 重循环方式，另一种是用递归方式。

《算法的乐趣》一书中为了使代码看起来简练一点，使用了递归的方式，本课程准备的时候，为了使读者更容易看懂算法实现，就改成了 5 重循环方式。

有兴趣的读者可以到图灵社区下载那本书的随书代码，比较一下两种方法的差异。

ArrangeHouseColors() 函数中的 5 重 for 循环可以看作是 n 重循环方式的一个模板，因为全排列不能有重复，也就是说不能有类似`{ COLOR_BLUE,COLOR_GREEN,COLOR_WHITE,COLOR_GREEN,COLOR_YELLOW }`这样的组合结果，因为 COLOR_GREEN 有重复，所以从第二重循环开始，增加了对循环变量是否重复的判断，分别是第 8 行、第 12 行、第 16 行和第 21 行的 if 条件判断。当发生重复的时候，continue 语句的作用就是跳过这个值，继续下一个值（continue 语句只影响当前循环）。5 重循环、5 个循环变量：i、j、k、p 和 q，分别代表 5 间房子的颜色。

对房子颜色枚举的时候，要对“绿房子紧挨着白房子，在白房子的左边”这样的特殊情况做特殊处理，这个处理体现在第 30 行还是 for 循环。

这个 for 循环遍历了所有当前排列得到的房子颜色，当发现绿色房子的时候，就判断它右边相邻的房子是否是白色，如果是，说明当前枚举的结果符合这个要求，可以调用 ArrangeHouseNations() 函数继续对国籍进行枚举处理。

如果它右边相邻的房子不是白色，则不做处理，继续循环排列下一个结果。

```
/* 遍历房子颜色*/
void ArrangeHouseColors(GROUP *groups)
{
    for (int i = COLOR_BLUE; i <= COLOR_WHITE; i++)
    {
        for (int j = COLOR_BLUE; j <= COLOR_WHITE; j++)
        {
            if (j == i)
                continue;
            for (int k = COLOR_BLUE; k <= COLOR_WHITE; k++)
            {
                if ((k == i) || (k == j))
                    continue;
                for (int p = COLOR_BLUE; p <= COLOR_WHITE; p++)
                {
                    if ((p == i) || (p == j) || (p == k))
                        continue;

                    for (int q = COLOR_BLUE; q <= COLOR_WHITE; q++)
                    {
                        if ((q == i) || (q == j) || (q == k) || (q == p))
                            continue;

                        groups[0].itemValue[type_house] = i;
                        groups[1].itemValue[type_house] = j;
                        groups[2].itemValue[type_house] = k;
                        groups[3].itemValue[type_house] = p;
                        groups[4].itemValue[type_house] = q;

                        for (int groupIdx = 0; groupIdx < (GROUPS_COUNT - 1); groupIdx++)
                        {
                            if ((groups[groupIdx].itemValue[type_house] == COLOR_GREEN)
                                && (groups[groupIdx + 1].itemValue[type_house] == COLOR_WHITE))
                            {
                                ArrangeHouseNations(groups);
                            }
                        }
                    }
                }
            }
        }
    }
}
```

ArrangePeopleDrinks() 函数对 5 种饮料进行全排列枚举，对饮料的排列也有一个特殊规则，即“住在中间房子里的人喝牛奶”。和国籍的枚举处理方式一样，这里也是先固定中间房子的饮料类型为 `DRINK_MILK`，然后对剩下的四个房子和四种饮料进行全排列，得到 P44=24 种排列结果。每得到一组结果，就调用 ArrangePeoplePet() 函数继续对宠物进行枚举。

```c++
void ArrangePeopleDrinks(GROUP *groups)
{
    /*应用规则(8)：住在中间那个房子里的人喝牛奶；*/
    groups[2].itemValue[type_drink] = DRINK_MILK;

    for (int i = DRINK_TEA; i <= DRINK_BEER; i++)
    {
        for (int j = DRINK_TEA; j <= DRINK_BEER; j++)
        {
            if (j == i)
                continue;
            for (int k = DRINK_TEA; k <= DRINK_BEER; k++)
            {
                if ((k == i) || (k == j))
                    continue;
                for (int p = DRINK_TEA; p <= DRINK_BEER; p++)
                {
                    if ((p == i) || (p == j) || (p == k))
                        continue;

                    groups[0].itemValue[type_drink] = i;
                    groups[1].itemValue[type_drink] = j;
                    groups[3].itemValue[type_drink] = k;
                    groups[4].itemValue[type_drink] = p;

                    ArrangePeoplePet(groups);
                }
            }
        }
    }
}
```

对宠物和对香烟品牌的枚举没有特殊规则需要处理，都是直接 5 重循环，最后枚举完香烟品牌后，就得到了一个完整的二维状态表，接下来就是调用 DoGroupsfinalCheck() 函数对结果做最后的检查。

#### 状态的正确性判断

通过前面“线索模型定义”的分析，将 15 条解题信息分为三类，其中第三类线索已经融入到枚举过程中了，因此判断结果的正确性只需要用第一类线索和第二类线索进行过滤即可。DoGroupsfinalCheck() 函数就是依次检查全部第二类线索和第三类线索，如果检查结果符合题目要求，则输出当前结果。

```
void DoGroupsfinalCheck(GROUP *groups)
{ 
    if(CheckAllGroupsBind(groups, binds) && CheckAllGroupsRelation(groups, relations))
    {
        PrintAllGroupsResult(groups, GROUPS_COUNT);
    }
}
```

第一类线索是同一 GROUP 内的属性之间的绑定关系，用来描述的是一个 group 内两种属性之间的固定关系。对这类线索的判断的方法就是遍历全部的“组（groups）”，找到与 BIND 数据中的 `first_type` 和 `first_value` 标识相匹配的那个 group 组，然后检查 group 组中类型为 `second_type` 的属性的值是否等于 BIND 数据中的 `second_value`。如果 group 中类型为 `second_type` 对应属性的值与 `second_value` 的值不一致就直接返回检查失败，否则就说明当前的组合结果满足此 BIND 数据对应的线索，然后对下一个 BIND 数据重复上述检查过程，直到检查完 binds 数组中所有线索对应的 BIND 数据。

CheckAllGroupsBind() 函数负责对绑定关系进行检查，for 循环遍历所有的绑定关系，只要 FindGroupIdxByItem() 发现某个组里有符合 `first_type` 和 `first_val` 的属性，就立即检查其 `second_type` 对应属性的值是否与绑定关系中要求的 `second_val` 一致。以第一条绑定规则为例（英国人住在红色的房子里）：

```c++
{ type_house, COLOR_RED, type_nation, NATION_ENGLAND }
```

只要 FindGroupIdxByItem() 发现某个组匹配了第一个类型和值，即：

```
group[x].itemValue[type_nation] == NATION_ENGLAND ？？？
```

```c++
bool CheckGroupBind(GROUP *groups, int groupIdx, ITEM_TYPE type, int value)
{
    if(GetGroupItemValue(&groups[groupIdx], type) != value)
    {
        return false;
    }

    return true;
}

bool CheckAllGroupsBind(GROUP *groups, const BIND *binds)
{
    for(int i = 0; i < BINDS_COUNT; i++)
    {
        int grpIdx = FindGroupIdxByItem(groups, binds[i].first_type, binds[i].first_val);
        if(grpIdx != -1)
        {
            if(!CheckGroupBind(groups, grpIdx, binds[i].second_type, binds[i].second_val))
            {
                return false;
            }
        }
    }

    return true;
}
```

第二类线索是 group 之间的相邻关系线索，描述的是相邻的两个 group 之间的属性的固定关系，判断的方法就是遍历全部的 group，找到 RELATION 数据中的 type 和 value 标识的元素所匹配的 group 组，然后分别检查与 group 相邻的两个组（第一个组和最后一个组只有一个相邻的组）中类型为 relation_type 的元素对应的值是否等于 `relation_value`，如果相邻的组中没有一个能满足 RELATION 数据就表示当前组合结果不满足线索，直接返回检查失败。相邻的组中只要一个组中的元素满足 RELATION 数据描述的关系就表示当前组合结果符合 RELATION 数据对应的线索，需要对下一个 RELATION 数据重复上述检查过程，直到检查完 relations 数组中的全部线索对应的 RELATION 数据。

CheckAllGroupsRelation() 函数负责对关联关系进行检查，for 循环遍历所有的关联关系，只要 FindGroupIdxByItem() 函数发现某个组中有关联关系匹配的类型和值（类型和值必须都匹配），就检查这个组的前一个组和后一个组是否有匹配第二个类型和值的情况，如果有则满足关联关系，否则不满足关联关系。代码中为了避免越界，CheckGroupRelation() 函数对第一个组和最后一个组的情况做了特殊处理，当 groupIdx == 0 的时候，只检查后面的一组，当 groupIdx == (GROUPS_COUNT - 1) 的时候，只检查前面的一组。

```c++
bool CheckGroupRelation(GROUP *groups, int groupIdx, ITEM_TYPE type, int value)
{
    if(groupIdx == 0)
    {    //只检查后一个组
        if(GetGroupItemValue(&groups[groupIdx + 1], type) != value)
        {
            return false;
        }
    }
    else if(groupIdx == (GROUPS_COUNT - 1))
    {    //只检查前一个组
        if(GetGroupItemValue(&groups[groupIdx - 1], type) != value)
        {
            return false;
        }
    }
    else
    {    //检查前后两个组
        if( (GetGroupItemValue(&groups[groupIdx - 1], type) != value)
            && (GetGroupItemValue(&groups[groupIdx + 1], type) != value) )
        {
            return false;
        }
    }

    return true;
}

bool CheckAllGroupsRelation(GROUP *groups, const RELATION *relations)
{
    for(int i = 0; i < RELATIONS_COUNT; i++)
    {
        int grpIdx = FindGroupIdxByItem(groups, relations[i].type, relations[i].val);
        if(grpIdx != -1)
        {
            if(!CheckGroupRelation(groups, grpIdx, relations[i].relation_type, relations[i].relation_val))
            {
                return false;
            }
        }
    }

    return true;
}
```

同样以第一条关联规则为例（抽 Blends 牌香烟的人和养猫的人相邻）：

```c++
{ type_cigaret, CIGARET_BLENDS, type_pet, PET_CAT }
```

首先由只要 FindGroupIdxByItem() 发现某个组匹配了抽牌子香烟的人：

```c++
if(group[groupIdx].itemValue[type_cigaret] == CIGARET_BLENDS)
{
    //...
}
```

就会检查其相邻的 group 是否匹配关联关系中要求的类型和值，即检查：

```c++
group[groupIdx-1].itemValue[type_pet] ？= PET_CAT
group[groupIdx+1].itemValue[type_pet] ？= PET_CAT
```

得益于线索模型定义的技巧，CheckAllGroupsBind() 函数和 CheckAllGroupsRelation() 函数的实现非常简单，检查算法只需要遍历 binds 数组和 relations 数组即可，避免了写很多 if…else 分支。

#### 总结

一共有多少种这样的组合结果呢？我们来简单计算一下。首先是对房子颜色进行穷举，因为是 5 种颜色的不重复组合，因此应该有 5！= 120 个颜色组合结果，但是根据线索4 “绿房子紧挨着白房子，在白房子的左边”，相当于绿房子和白房子有稳定的绑定关系，实际就只有 4！= 24 个颜色组合结果。接下来对 24 个房子颜色组合结果中的每一个结果再进行住户国籍的穷举，理论上国籍也有 5！= 120 个结果，但是根据线索9 “挪威人住在第一个房子里面”，相当于固定第一个房子住的人始终是挪威人，因此就只有 4！= 24 个国籍组合结果。穷举完房子颜色和国籍后就已经有 24 x 24 = 576 个组合结果了，接下来需要对这 576 个组合结果中的每一个结果再进行饮料类型的穷举，理论上饮料类型也有 5！= 120 个结果，但是根据线索8 “住在中间那个房子里的人喝牛奶”，相当于固定了一个饮料类型，因此也只有 4！= 24 个饮料组合类型。穷举完饮料类型后就得到了 576 x 24 = 13824 个组合结果，接下来对 13824 个组合结果中的每一个结果再进行宠物种类的穷举，这一步没有线索可用，共有 5！= 120 个结果。穷举完宠物种类后就得到了 13824 x 120 = 1658880 个组合结果，最后对 1658880 个组合结果中的每一个结果再进行香烟品牌的穷举，这一步依然没有线索可用，共有 5！= 120 个结果。穷举完香烟品牌后就得到了全部组合共 1658880 x 120 = 199065600 个结果。有将近两亿个组合结果，看来出现多个正确答案的可能性很大哟。但是，令人惊讶的是竟然只有一组结果能通过所有的线索检查，就是前面给出的答案。这个结果有点出乎预料，但是也从侧面说明了这个问题的难度。另外，对大约两亿个状态的穷举和检查需要耗时约 5s，这也体现了穷举法应用的一些局限性，就是当问题规模比较大时，穷举法是一个低效的方法。对于更大规模的问题，应尽量避免使用穷举法。

这个题目需要总结一下，这个题目比我们前几课的例子都复杂，无论是穷举所有状态的方法还是对结果的正确性判断，都需要一些特殊的技巧。我们精心设计了数据模型，将 15 条信息中的大多数抽象成绑定和关联两种关系，用静态数据提前设计好检查条件，简化了结果检查代码，避免了在一个大循环结构中各种复杂的 if 判断条件，也在某种程度上提高了代码的可读性。