### 训练营学习笔记1

### 3-3 狼、羊、菜和农夫过河问题

农夫需要把狼、羊、菜和自己运到河对岸去（不知道为啥要运狼，别问我），只有农夫能够划船，而且船比较小，除农夫之外每次只能运一种东西，还有一个棘手的问题，就是如果没有农夫看着，羊会偷吃菜，狼会吃羊。请考虑一种方法，让农夫能够安全地安排这些东西和他自己过河。

#### 算法设计思路

这是一个很简单的问题，在狼、羊和菜这个食物链上，关键是中间的羊，因为狼不吃菜，所以要安全过河，农夫的第一件事就是带羊走，拆开这个食物链。

但是计算机无法理解这个关键的羊，所以我们仍然采用穷举法来解决这个问题，同时借助于穷举搜索找出所有过河的方法。

这个题目的解决思路和“三个水桶倒水”问题的解决思路类似，就是对状态进行穷举搜索，从初始状态开始穷举所有的状态变化，直到某一次变化后得到问题解决的最终状态，就输出一个结果。

前面的几课中已经多次提到穷举法的两个关键步骤，这里不再列出。接下来就直接从这两个步骤入手，介绍如何设计这个问题的穷举算法。

#### 定义问题的状态

在确定以何种方法对解空间进行穷举搜索之前，首先要定义问题的解。

虽然这个题目的要求是给出农夫带着他的小伙伴过河的动作，但是单纯考虑对动作的穷举是没有意义的，因为问题最后的解决状态是农夫、狼、羊和菜过到河对岸，能最终产生这种状态的动作才有意义，为了判断动作的有效性，需要定义一个合适的状态来描述这个游戏在某个时刻的局面。

考虑一下这个题目涉及的所有元素：农夫、狼、羊、菜、船和河，河是固定的，没有状态变化，因为只有农夫可以划船，所以船可以看作和农夫是一体的，简化后其实有 4 个元素需要考虑，分别是农夫、狼、羊和菜。

如图（1）所示的一种过河的过程，状态的定义只要能表达农夫、狼、羊和菜的位置关系即可。在确定以何种方法对解空间进行穷举搜索之前，首先要定义问题的解。虽然这个题目的要求是给出农夫带着他的小伙伴过河的动作，但是单纯考虑对动作的穷举是没有意义的，因为问题最后的解决状态是农夫、狼、羊和菜过到河对岸，能最终产生这种状态的动作才有意义，为了判断动作的有效性，需要定义一个合适的状态来描述这个游戏在某个时刻的局面。考虑一下这个题目涉及的所有元素：农夫、狼、羊、菜、船和河，河是固定的，没有状态变化，因为只有农夫可以划船，所以船可以看作和农夫是一体的，简化后其实有 4 个元素需要考虑，分别是农夫、狼、羊和菜。如图（1）所示的一种过河的过程，状态的定义只要能表达农夫、狼、羊和菜的位置关系即可。

![avatar](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602224622.png?raw=true)

从图（1）可以看出来，状态(a)到(h)变化的其实就是这 4 个元素的位置，每个元素的位置只有两个状态，即在河的左岸和在河的右岸；

问题的初始状态是农夫、狼、羊和菜都在河的左岸，得到解的终止状态是农夫、狼、羊和菜都在河的右岸。

我们用一个四元组来表示四个元素的位置状态，那么初始状态为 [Left,Left,Left,Left]，最终的结果状态为 [Right,Right,Right,Right]。

#### 状态树和解空间

和“三个水桶等分 8 升水”问题一样，对所有状态穷举搜索的结果也是一棵状态树，根节点是初始状态，叶子节点就是解决问题的状态。

这个题目由于限制条件比较特殊，只有农夫可以划船，一次只能带一个小伙伴，同时狼、羊和菜又不能愉快地在一起玩耍，所以状态树上很多状态都是非法状态，客观上起到了很好的剪枝效果。

如图（2）所示的状态树中，蓝色的状态表示此状态已经和之前的状态重复，红色的状态表示这是一个非法状态，不是出现狼吃羊的情况，就是出现羊吃菜的情况。绿色状态是搜索到了结果状态，这是状态树的叶子节点。

![QQ截图20190602225418](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602225418.png?raw=true)

状态树上绿色的节点是要搜索的结果状态，从结果状态到根节点之间的状态序列，就是问题解决的过程，有多个绿色的节点表示有多个解决问题的过程。

根据题目的意图，最终的结果是要输出这条转换路径的过河过程，实际上就是与状态转换路径相对应的动作路径，或动作列表。当定义了动作的数学模型后，就可以根据状态图中状态转换路径找到对应的动作列表，依次输出这个路径上每个状态对应的动作就可以得到一个完整的过河过程。

#### 状态的数据模型

根据之前对状态的定义，状态的数据模型就是农夫、狼、羊和菜的位置，位置定义 LOCATION 就是两个状态，LOCATION::LEFT 表示对应的元素在河的左岸，LOCATION::RIGHT 表示对应元素在河的右岸（就是过河状态）。

```c++
struct ItemState
{
    ……
    LOCATION farmer,wolf,sheep,vegetable; // 四个元素的位置
    ACTION curAction; // 此状态对应的动作
}
```

curAction 是当前状态绑定的过河动作，即前一个状态通过这个过河动作转变成当前状态。

记录状态对应的过河动作的目的是能够在输出结果时，按照状态演变序列的顺序输出过河动作。



#### 过河动作的数据模型

两个静态的位置状态是通过过河动作建立关联的，分析这个题目，我们注意到，狼、羊和菜是不会自己过河的，因为只有农夫会划船。

农夫可以自己过河，也可以带一个物品过河，当然，从河对岸返回时也是一样的情况。由此可见，本问题的过河动作其实只有 8 个固定动作，分别是：

- (1)农夫自己过河
- (2)农夫带狼过河
- (3)农夫带羊过河
- (4)农夫带菜过河
- (5)农夫自己返回
- (6)农夫带狼返回
- (7)农夫带羊返回
- (8)农夫带菜返回

把一个状态与以上动作结合，就可以转化得到一个新状态，但是需要注意的是，并不是所有的动作都适用于对应的状态，比如对于农夫在河的左岸的状态，动作（5）~（8）代表的返回动作就都不适用。

同样，对于一个菜已经在河对岸的状态，动作（4）就不适用。

在搜索过程中对过河动作遍历的时候，要根据这些情况合理地剪掉一些分支。

根据以上描述，过河动作 ACTION 定义如下：

```c++
num class ACTION
{
    GO_SELF,
    GO_WITH_WOLF,
    GO_WITH_SHEEP,
    GO_WITH_VEGETABLE,
    BACK_SELF,
    BACK_WITH_WOLF,
    BACK_WITH_SHEEP,
    BACK_WITH_VEGETABLE,
};
```

##### 设计搜索算法

我们讨论的状态都是静止的，如果不是有过河动作作用到状态上，状态是不会发生变化的。

对状态树的搜索，其实就是把 8 个过河动作依次与状态结合，演变为新的状态的过程。

与“三个水桶等分 8 升水”问题一样，本题的搜索算法依然采用深度优先遍历，从初始状态节点开始，一直搜索到合法状态为止，在这个过程中，需要记录已经搜索过的状态，避免出现重复状态导致算法进入死循环。

```c++
struct ActionProcess
{
    ACTION  act_name;
    std::function<bool(const ItemState& current, ItemState& next)>  TakeAction;
};

ActionProcess actMap[] = 
{
    { ACTION::GO_SELF,                ProcessFarmerGo                },
    { ACTION::GO_WITH_WOLF,           ProcessFarmerGoTakeWolf        },
    { ACTION::GO_WITH_SHEEP,          ProcessFarmerGoTakeSheep       },
    { ACTION::GO_WITH_VEGETABLE,      ProcessFarmerGoTakeVegetable   },
    { ACTION::BACK_SELF,              ProcessFarmerBack              },
    { ACTION::BACK_WITH_WOLF,         ProcessFarmerBackTakeWolf      },
    { ACTION::BACK_WITH_SHEEP,        ProcessFarmerBackTakeSheep     },
    { ACTION::BACK_WITH_VEGETABLE,    ProcessFarmerBackTakeVegetable }
};
```

每个处理逻辑需要做三件事情，首先要判断当前状态是否适用于对应的动作，接着根据对状态进行相应的改变并将对应的动作记录到新状态中，最后判断转化后的状态是不是一个合法的状态。

仍然以`ACTION::GO_WITH_VEGETABLE`动作为例，其处理逻辑 ProcessFarmerGoTakeVegetable() 的实现如下：

```c++
bool ProcessFarmerGoTakeVegetable(const ItemState& current,ItemState& next)
{
    if((current.farmer != LOCATION::LEFT) || (current.vegetable != LOCATION::LEFT))
        return false;
    next = current;
    
    next.farmer = LOCATION::RIGHT;
    next.vegetable = LOCATION::RIGHT;
    next.curAction = ACTION::GO_WITH_VEGETABLE;
    
    return IsCurrentStateValid(next);
}
```

对 8 个动作循环一遍，即可完成对一个状态的遍历，并根据情况生成新的状态，所以，遍历的动作就是对 actMap 做一个循环，依次调用每个动作对应的 TakeAction 逻辑。

遍历代码的主体大致是这样的：

```c++
ItemState next;
for(auto& act : actMap)
{
    if(act.TakeAction(current,next))
    {
        .....
    }
}
```

#### 剪枝和优化（重复状态和非法状态判断）

根据图（2）显示的状态树，需要剪枝处理的情况有两种，一种是非法状态，另一种是重复的状态。

对非法状态的过滤，体现在过河动作对应的处理逻辑中，ProcessFarmerGoTakeVegetable() 函数中最后调用 IsCurrentStateValid() 判断这个状态是不是合法状态。

对于产生非法状态的情况，ProcessFarmerGoTakeVegetable() 函数返回 false，遍历循环就跳过这个动作，继续遍历下一个动作。

对重复状态的过滤，是在 TakeAction 逻辑返回 true 的情况下才进行的，如下代码所示，两个 if 判断就是对上述两种情况的剪枝处理。

```c++
if(act.TakeAction(current, next))
{
    if(!IsProcessedState(states, next))
    {
        ......
    }
}
```

#### 代码实现

#### 搜索算法代码

SearchState() 函数实现状态树的搜索遍历，整体结构和“三个水桶等分 8 升水”问题类似，由两部分内容组成：

第一部分的 IsFinalState() 函数判断当前状态序列中最后一个状态是不是最终结果状态，如果是就输出一组状态序列（以及对应的过河动作）；

如果当前状态序列中最后一个状态不是结果状态，则转入第二部分开始搜索新的状态。

```
void SearchStates(deque<ItemState>& states)
{
    ItemState current = states.back(); /*每次都从当前状态开始*/
    if(current.IsFinalState())
    {
        PrintResult(states);
        return;
    }

    ItemState next;
    for (auto& act : actMap)
    {
        if(act.TakeAction(current, next))
        {
            if(!IsProcessedState(states, next))
            {
              states.push_back(next);
              SearchStates(states);
              states.pop_back();
            }
        }
    }
}
```

#### 判断非法动作和重复状态

如果农夫不在场，狼会吃羊，羊会吃菜，根据这个描述，无法直接写出代码，把这句话换一种说法，则会更容易转化成代码实现：

- 如果狼和羊位置相同，并且农夫的位置与它们不同，则是非法状态；
- 如果羊和菜位置相同，并且农夫的位置与它们不同，则是非法状态；
- 其他情况均为合法状态。

这样一来，这个判断函数就比较容易用代码描述了：

```c++
bool IsCurrentStateValid(const ItemState& current)
{
    if ((current.wolf == current.sheep) && (current.sheep != current.farmer))
    {
        return false;
    }

    if ((current.vegetable == current.sheep) && (current.sheep != current.farmer))
    {
        return false;
    }

    return true;
}
```

重复状态的判断更简单，就是对状态队列进行一次查找操作：

```c++
bool IsProcessedState(deque<ItemState>& states, const ItemState& newState)
{
    auto it = find_if( states.begin(), states.end(),
        [&newState](ItemState& item) { return item.IsSameState(newState); });

    return (it != states.end());
}
```

### 3-4 24点计算器

24 点游戏是一个很有意思的数字游戏，也是一道常见的算法面试题。

题目是这样的：任给四个数（为了便于人们心算或口算，一般都是小于 10 的数），对四个数字用各种组合进行加、减、乘、除四则运算，看看结果是否能等于 24？

对于面试题来说，这是一个典型的穷举类型算法问题。

这个题目比较有意思的地方是它除了要对数字组合进行枚举，还要对四个运算符进行组合。

这一课我们要介绍的方法有点特殊，它没有简单地使用穷举遍历，而是采用穷举法和分治法相结合的方法来解决这个问题，这种方法比数字 + 运算符一起枚举的方法简单，容易理解，整个算法只有大约 40 行有效代码，其中主体部分有效代码只有不到 20 行，快来看看是怎么回事儿吧。

#### 问题分析与建模

这个算法问题的难点主要有两个，

一个是数字和运算符的穷举遍历，另一个是将四则运算表达式作为结果输出。

无论是运算符遍历还是表达式输出，都要考虑运算符的优先级，必要时要加括号。

当然，也可以采用后缀表达式的形式，避免在枚举遍历的过程中考虑括号的问题。一般我们书写和计算都采用中缀表达式，中缀表达式的特点是运算符始终位于两个操作数的中间，对于运算符的优先级采用括号的方式解决，比如以下四则运算采用的就是中缀表达式的形式：

7 + ( 3 + 2 ) × 4 − 8

后缀表达式又称为“逆波兰表达式”，上述中缀表达式转换成后缀表达式后就是这个样子：

732 + 4 × + 8 −

后缀表达式通过运算符的位置来决定计算顺序，避免使用括号，便于计算机计算处理。

后缀表达式的求解计算一般用栈比较方便，具体的方法就是从左向右扫描表达式，当遇到操作数时就将操作数入栈；

当遇到操作符时就从栈中弹出两个操作数，将操作数与这个运算符一起计算得到一个结果，并将这个结果入栈，然后继续扫描表达式，直到结束。

后缀表达式的计算以及将中缀表达式转变成后缀表达式也都是经典数据结构课程的算法，这一课我们就不具体介绍了。大家如果感兴趣可以在读者圈中留言，我们后面可以安排补充一篇关于后缀表达式的内容。

引言部分提到过，我们这个方法会用到分治法，分治法的主要特点之一就是通过分解子问题的方式减小问题的规模，怎么划分子问题呢？

复习一下前面讲过的内容，子问题和原始问题必须是同构的，所谓同构就是问题必须是一样的，问题的模式不能变，能变的只是问题的规模。

对于这个问题来说，原始问题的规模是 4 个数字计算 24 点，那么分解子问题可以从两个方向考虑：

一种是只考虑减少问题的规模，对于这个问题来说，减少规模不就是变成 3 个数字计算 24 点吗？然后再减少为两个数字计算 24 点，以此类推，直到问题能够直接求解为止；

另一种是在减少问题规模的同时，调整结果的范围，同样，对这个问题来说，假如说我将问题规模从 4 个变成 3 个，被排除的数字是 3，那么子问题就应该变成“3 个数字计算 21 点”。进一步将问题规模减少成两个数字时，假如被排除的数字是 7，则子问题就变成“2 个数字计算 14 点”，以此类推，直到问题能直接解决为止。

本课我们尝试采用第一种方法来分解子问题。我们的思路是每次从 4 个数字中任选两个，分别应用加、减、乘、除四种运算方法得到 4 个计算结果，每个计算结果与剩下的 2 个数字一起组成一个规模为 3 个数字的子问题，一共可以得到 4 个子问题，其变化过程如图（1）所示（图中第一行的数字为 4 个数字的索引位置，第二行的数字分别是 4 个待计算数字，第三行是计算过程），使用第一个数字和第二个数字组合计算，得到了一组 4 个子问题，然后用第一个数字和第三个数字组合计算，得到了另一组 4 个子问题：

![QQ截图20190602234202](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602234202.png?raw=true)

根据组合规则，从 4 个数字中选两个进行不能有重复的排列，可以得到 P_{4}^{2} = 12 个组合结果，也就是说总共有 12 × 4 = 48 个规模为 3 个数字的子问题，图（1）展示了其中的两组。

接下来，我们选择图（1）中紫色标识的那个子问题，再进一步应用上述思想减小问题的规模。

从 3 个数字中任选两个，然后应用加、减、乘、除四种运算方法得到 4 个计算结果，每个计算结果与剩下的 1 个数字组成一个规模为两个数字的子问题，又可以得到 4 个子问题。

从 3 个数字中任选两个进行不重复的排列，可以得到 P_{3}^{2} =6 个组合结果，也就是说总共有 6 × 4 = 24 个规模为两个数字的子问题，图（2）展示了其中一组，也就是第一个数 3/7 和第二个数 3 的组合情况：

![QQ截图20190602234530](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602234530.png?raw=true)

3/7 和 3 经过加、减、乘、除得到了 4 个结果，分别是 24/7、−18/7、9/7 和 1/7，将它们与剩下的数字 7 组合，得到了图（2）所示的 4 个子问题。

接下来，我们选择图（2）中黄色标识的子问题，再进一步应用上述思想减小问题的规模。

从两个数字中任选两个，然后应用加、减、乘、除四种运算方法得到 4 个计算结果，得到 4 个规模是 1 个数字的子问题，如图（3）所示：

![QQ截图20190602234623](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602234623.png?raw=true)

从两个数字中任选两个进行无重复的排列，可以得到 P_{2}^{2} =2 个组合结果，也就是说总共有 2 × 4 = 8 个规模为 1 个数字的子问题，图（3）展示了其中一组，即 24/7 与 7 分别进行加、减、乘、除计算。

此时问题的规模已经减小到可以直接得到结果的程度了，淡灰色标识的那个子问题结果是 24，就是我们要求解的结果。当然，从其他分支也能得到正确的结果，从图（1）到图（3）只展示了其中一个结果的生成过程。

以上就是我们介绍的穷举法 + 分治法解决 24 点计算问题的算法分析过程。

前面提到过，这个问题的难点有两个，上述分析过程解决了第一个，即数字和运算符的穷举遍历问题。

还有第二个问题，也就是将四则运算表达式作为结果输出的问题没有解决。

可能大家已经从几个图上看到了，图的第三行就是最后要输出的中缀表达式，这是怎么做到的呢？其实很简单，我们给每个数字都指定了一个“出身”，所谓的“出身”就是描述这个数字的来历，或者是计算过程。

每个数字的“出身”记录了这个数字的计算过程，当数字被带入到子问题的时候，这个计算过程也跟着被带入到子问题，并随着子问题的求解过程一步一步带到最后。

对于原问题来说，4 个数字的出身就是数字本身，当两个数字参与一次计算称为一个结果数字时，就将这两个数字的计算过程作为结果数字的“出身”。

为了简化算法实现，避免处理运算符的优先级，我们对每个运算过程都用了括号。

好了，根据上面的分析，我们已经明确了问题和子问题的定义，就是“用 m 个数排列组合计算 24 点（1⩽m⩽4）”。

所以我们的子问题的参数就是 m 个数，考虑用数组来组织这 m 个数。每个数除了数字本身，还有一个出身，用以下数据结构来描述这个“数”：

```c++
typedef struct
{
    double num;
    std::string num_str;
}Number;
```

num_str 是这个数的“出身”，用字符串描述没问题，num 是数字本身，但是数据类型用了 double，这也是实际计算过程的需要，毕竟从上图中也能看到，我们的计算方法是支持分数形式的，中间计算过程会出现浮点数，最终子问题定义就是 Calc24() 函数的参数：

```c++
void Calc24(const std::vector<Number>& nums)
{
    //求解子问题
}

//原始问题的定义
std::vector<Number> numbers = { { 3, "3" },{ 3, "3" },{ 7, "7" },{ 7, "7" } };
Calc24(numbers);
```

随着子问题规模的减小，nums 数组的长度由 4 减小到 3，再减小到 2，直至减到 1，numbers 就是子问题的初始状态，也就是原始问题。

考虑到一些读者不熟悉 C++，介绍一下上面的数组定义。首先 std::vector<…> 定义了一个向量 vector，vector 的行为实际上就是数组，其内存结构是连续的，并且提供下标运算符 []，可以像访问原生数组一样使用 vector（当然，也可以使用迭代器）。

`std::vector<Number>` 表示数组的每个元素是 Number 类型。Number 是个数据结构定义，它有两个成员，分别是 num 和 num_s。

#### 算法实现

算法实现要解决的问题是将上述分析过程落地实现，完成 Calc24() 函数。

本课程基础部分介绍分治法的时候，我提到过“递归作为一种算法的实现方式，与分治法是一对儿天然的好朋友”，这个问题我们也决定使用递归方式实现 Calc24() 函数。

这意味着 Calc24() 函数要在内部构造子问题的`std::vector<Number>`数组，并将其作为递归调用 Calc24() 函数时的参数，从而实现对子问题的求解。

Calc24() 函数对子问题进行处理的时候，要对子问题规模是 1 个数的情况做处理，这实际上也是递归函数的退出（递归终止）条件。

对于这个问题来说，当子问题的规模是 1 个数的时候，就要检查这个数是否是 24，如果是则输出一组结果，并退出递归处理；如果不是，说明这个穷举出来的结果是个无效结果，直接退出递归处理。这部分判断和处理的实现在第 4 行开始的 if (count == 1) 处理流程里，比较简单，就不多说了。对于子问题规模大于 1 的情况，就要选两个数进行计算，对于 P_{n}^{2} 问题，常用的代码实现模式就是两重循环。

下一课我会介绍另一种常见的方法，但是那种方法不适合用递归的方式处理不同规模的子问题，所以 Calc24() 函数使用两重循环实现对 P_{n}^{2}的处理。

代码的第 14 行和第 16 行的两个 for 循环就是处理 P_{n}^{2}的排列，因为不能有重复，所以当 (i == j) 的时候，要排除掉这种情况，就是 18 和 19 两行代码做的事情。

第 21 行的 for 循环是对加、减、乘、除四种运算的枚举，也就是将前面两重 for 循环选出来的两个数进行四种运算，得到四个结果。acops 是个函数数组，每一个 op 是一种运算方式，负责将 nums[i]、nums[j] 进行计算，并将结果存入到 new_num 中。

第 27 行定义的`sub_nums`数组是子问题的描述，首先将前面计算的`new_num`加入到`sub_nums`数组中，然后将 nums 数组中没有被选中的数字也加入到`sub_nums`数组中，组成新的子问题。

第 30 行的 for 循环就是将 nums 数组中没被选中的数加入到`sub_nums`数组中。子问题`sub_nums`数组准备好以后，

在第 37 行递归调用`Calc24(sub_nums)`求解子问题。

对于第 30 行的 for 循环来说，当 nums 的规模是 4 个数的时候，这个 for 循环排除掉已经选中的 i 和 j 后，将剩下的两个数加入到`sub_nums`数组中，形成 3 个数的子问题。

当 nums 的规模是 3 个数的时候，这个 for 循环将剩下的 1 个数加入到`sub_nums`数组中，形成两个数的子问题。

当 nums 的规模是两个数的时候，这个 for 循环实际上空转了两次排除掉已经选中的 i 和 j ，没有任何数被加入到`sub_nums`数组中，最后得到只有 1 个数的子问题。用递归方式求解子问题，最难的部分是如何用一致的代码处理不同规模和属性范围的子问题。

前面的两重 for 循环和对`sub_nums`数组的处理，都体现了这种思想。

```c++
void Calc24(std::vector<Number>& nums)
{
    std::size_t count = nums.size();
    if(count == 1) // 当只有一个数的时候，说明计算完成，可以判断结果了
    {
        if(nums[0].num == 24)
        {
            std::cout << nums[0].num_str << "=" << nums[0].num <<std::end;
        }
        return;
    }
    
    // 两重循环，从nums中找两个数的组合
    for(std::size_t i = 0; i<count;i++)
    {
        for(std::size_t j = 0; j<count; j++)
        {
            if(i == j) // 排除相同的情况
            {
                continue;
            }
            
            for(auto & op : acops)// 对四中运算进行枚举
            {
Number new_num;
                //运算可能失败，比如除数是 0 的情况，不再继续处理这个运算符，相当于剪枝效果
                if (op(nums[i], nums[j], new_num))
                {
                    std::vector<Number> sub_nums;//定义子问题
                    sub_nums.push_back(new_num);
                    //除了被选出来的两个数，将剩下的数加入子问题
                    for (std::size_t k = 0; k < count; k++) 
                    {
                        if ((k != i) && (k != j))
                        {
                            sub_nums.push_back(nums[k]);
                        }
                    }
                    Calc24(sub_nums); //解决子问题
                }
            }
        }
	}
}
```

现在说说 acops，它是一个计算函数的数组，定义了对两个操作数的加、减、乘、除四种运算。std::function<…> 是个可调用对象包装器，这里包装的是一个这样的调用接口：

```c++
bool (const Number&, const Number&, Number&)
```

这个接口有两个 const Number& 类型的入参，一个 Number& 类型的出参和一个 bool 类型的返回值，两个入参是参与计算的操作数，出参是计算的结果。

四个操作符对应的可调用对象是用 lamda 表达式定义的操作函数。

这些操作函数的的作用很简单，就是计算两个操作数，当然，还有很重要的一点，就是拼装计算结果的“出身”。

前面分析算法的时候提到过，一个数的“出身”很重要，即使数字本身算对了，如果“出身”拼装的不正确，输出的结果也不正确。

“出身”拼装很简单，就是将参与计算的两个数的“出身”用操作符连接在一起，然后两端加上一对儿括号，就得到结果数字的“出身”了。这里面只有除法比较特殊一点，因为被除数不能为 0，所以加了个判断。当其返回 false 的时候，相当于做了一次剪枝操作。

```c++
std::function<bool (const Number&, const Number&, Number&)> acops[] = 
{
    [](const Number& d1, const Number& d2, Number& dr) 
    { 
        dr.num = d1.num + d2.num; 
        dr.num_str = '(' + d1.num_str + '+' + d2.num_str + ')';
        return true; 
    },
    [](const Number& d1, const Number& d2, Number& dr) 
    { 
        dr.num = d1.num - d2.num;
        dr.num_str = '(' + d1.num_str + '-' + d2.num_str + ')';
        return true;
    },
    [](const Number& d1, const Number& d2, Number& dr) 
    {
        dr.num = d1.num * d2.num;
        dr.num_str = '(' + d1.num_str + '*' + d2.num_str + ')';
        return true;
    },
    [](const Number& d1, const Number& d2, Number& dr) 
    {
        if (d2.num == 0)
            return false;
        dr.num = d1.num / d2.num;
        dr.num_str = '(' + d1.num_str + '/' + d2.num_str + ')';
        return true;
    }
};
```

为什么不直接在 Calc24() 函数里用 switch…case 或 if…else 直接进行加、减、乘、除计算，反而弄个可调用对象数组，这不是把问题搞复杂了吗？

这正是我希望大家理解的地方，这种表结构的处理，也是一致性处理的常用技巧，你不觉得这样做 Calc24() 函数的实现很简洁吗？简洁的代码可以避免眼睛在无聊的琐碎代码上停留太长时间，有助于我们理解算法实现的重点。

#### 一个数字的排列组合的技巧

上一课的实现部分我们介绍了用两重循环实现从 n（n > 2）个数字中任选两个数字进行组合的操作，实际上，对于 n 是已知常数的情况，可以用事先安排好组合顺序的方式，直接用一重循环完成选取两个数字组合，减少编码实现的复杂度。

以本题为例，已知每次都是从 4 个数字中选择两个（不能有重复），计算 P_{4}^{2} 的结果是 12，可选数字的位置组合分别是 {1,2}、{1,3}、{1,4}、{2,1}、{2,3}、{2,4}、{3,1}、{3,2}、{3,4}、{4,1}、{4,2} 和 {4,3} 共 12 组，有且只有这 12 组，不会再有别的了。

每一组表示选择的两个数在数组结构中的位置索引，对数组来说，往往就是数组下标。{1,2} 表示数组中的第一个和第二个数字，对于编程实现来说，要考虑数组索引是从 0 开始的，以 C++ 为例，我们定义这个位置组合数组为

```c++
std::vector<std::pair<int, int>> posArray = 
{
    { 0, 1 }, { 0, 2 }, { 0, 3 }, 
    { 1, 0 }, { 1, 2 }, { 1, 3 }, 
    { 2, 0 }, { 2, 1 }, { 2, 3 }, 
    { 3, 0 }, { 3, 1 }, { 3, 2 }
};
```

std::vector<…> 定义了一个数组，前面已经介绍过了，这个数组的数据元素类型是`std::pair<int, int>`，从名字可以看出来，这是两个 int 型数据组成的一个数字对

前一个数字的访问用 first 代替，后一个数字的访问用 second 代替。

使用的时候就可以这样使用：

```c++
std::vector<int> numArray = { 3, 3, 7 ,7 };
    for (auto& pos : posArray)
    {
        //第一个操作数是 numArray[pos.first]
        //第二个操作数是 numArray[pos.second]
        int sum = numArray[pos.first] + numArray[pos.second];
    }
```

numArray 是一个由 int 型数据元素组成的数组，就是我们要枚举的对象数据，for 循环遍历 posArray 数组，对每一个 posArray 的元素（就是位置关系数字对），执行循环体内的操作。

类似这样的技巧有时也被称为“以空间换时间”的策略，

有很多这样的技巧，不仅算法设计中常用，软件开发中也常用，了解一下，有益于开阔思路。另外，上述方法用 Java 实现起来差不多是这个意思：

24 点游戏的算法总少不了对数字的枚举加上对运算符的枚举，我们这一课介绍的实现算法虽然简洁，但是也包含了这两个内容，Calc24() 函数中前两个 for 循环实现了对数字的穷举，

第三个 for 循环实现了对运算符的穷举。我们的算法还缺少一个很重要的内容，就是去除重复结果，去重的方法也很简单，只要再增加十行左右的代码就行了，这个就作为作业留给读者去实现了，我会在介绍课程后半部分的时候将答案上传到 GitHub 上。



### 3-5 爱因斯坦的思考题（上）

不同问题的穷举法算法实现最大的差异点就是搜索算法的不同

前几课介绍了线性空间的搜索、树状空间的搜索，这一课我们再介绍一种求解问题的搜索算法，其搜索的空间是一个**二维表**

对二维表中的每个元素进行枚举遍历，依次确定每个表格元素的值，当二维表中所有表格元素的值都确定后，检查其结果是否符合问题解的要求，如果满足要求，则输出一个结果，如果不满足要求，则按照一定的顺序继续遍历各个表格元素的值。

这也是一种典型的解空间搜索方式，通过对这个问题的理解，未来遇到类似的问题，或三维表空间的问题，都可以用类似的方法设计搜索算法。



#### 问题介绍

题目是这样的，据说有五个不同颜色的房间排成一排，每个房间里分别住着一个不同国籍的人，每个人都喝一种特定品牌的饮料，抽一种特定品牌的烟，养一种宠物，没有任意两个人抽相同品牌的香烟，或喝相同品牌的饮料，或养相同的宠物，问题是**谁在养鱼作为宠物？**

为了寻找答案，爱因斯坦给出了 15 条线索：

- （1）英国人住在红色的房子里
- （2）瑞典人养狗作为宠物
- （3）丹麦人喝茶
- （4）绿房子紧挨着白房子，在白房子的左边
- （5）绿房子的主人喝咖啡
- （6）抽 Pall Mall 牌香烟的人养鸟
- （7）黄色房子里的人抽 Dunhill 牌香烟
- （8）住在中间那个房子里的人喝牛奶
- （9）挪威人住在第一个房子里面
- （10）抽 Blends 牌香烟的人和养猫的人相邻
- （11）养马的人和抽 Dunhill 牌香烟的人相邻
- （12）抽 BlueMaster 牌香烟的人喝啤酒
- （13）德国人抽 Prince 牌香烟
- （14）挪威人和住在蓝房子的人相邻
- （15）抽 Blends 牌香烟的人和喝矿泉水的人相邻



一般人解决这种问题，会像做数独题目一样，用纸和笔画一些表格，写写画画，一步一步慢慢推理，必要时需要一些假设进行尝试，如果假设错误就从假设点推倒重来。

我不属于那 2%，我缺乏耐心去做这个事情，所以我一直解不出这个问题，直到有一天，我的一个聪明朋友告诉我一个答案，

我对比了一下前面提到的 15 条线索，发现这是一个正确答案。答案是住在绿色房子里的德国人养鱼做宠物，但是有个问题却难住了我，这是唯一的答案吗？

经验告诉我，对于这种自由度很大的问题，常常有多种可能性。我决定设计个算法，让计算机帮忙找出所有可能的解，这正是穷举法的用武之地。



#### 数据的状态与数据模型

这个题目问的是谁在养鱼作为宠物

但是很明显，单纯考虑谁养鱼不是一个可以独立求解的问题，也就是说，你无法在忽略其他问题的情况下，单独对这个问题进行穷举遍历。

这个问题和题目给出的 15 条线索一样，都是最终答案的一部分，这个最终答案就是下面表格所展示的内容，知道了谁养鱼，也就能同时知道这个人是德国人，住在绿色房子里，喜欢喝咖啡和抽 Prince 牌子的香烟。

通过对问题的理解，这里描述了 5 个人，有不同的国籍，住不同颜色的房子，养不同的宠物，抽不同的香烟，喝不同的饮料，显然这个二维表格描述的整体才是我们要求的解。

| 房子颜色 | 国籍 | 饮料 | 宠物 | 烟         |
| -------- | ---- | ---- | ---- | ---------- |
| 黄色     | 挪威 | 水   | 猫   | Dunhill    |
| 蓝色     | 丹麦 | 茶   | 马   | Blends     |
| 红色     | 英国 | 牛奶 | 鸟   | PallMall   |
| 绿色     | 德国 | 咖啡 | 鱼   | Prince     |
| 白色     | 瑞典 | 啤酒 | 狗   | BlueMaster |

确定了问题的解，那么问题的解空间和穷举过程中的状态也就确定了。

解空间就是所有这五类元素（房子颜色、国籍、饮料、宠物和烟）的枚举组合，每个组合的结果就是一个状态，状态是上述二维表格的一个实例，每个属性都通过枚举组合确定了

但是还不一定是问题的解，因为判断条件不一定满足。

确定了解的状态和解空间，接着要确定对状态的穷举遍历方法。

这个题目比之前介绍的三个问题都复杂，我们需要五重枚举，依次对这五类元素进行排列组合才能得到一个完整的状态（二维表）；

另外，对状态是不是正确的解的判断也比其他问题复杂，需要用给出的 15 条线索逐条检查组合得到的状态。

如果某个状态能够通过 15 条线索的检查，那么就认为找到了一个正确的答案，然后输出该答案。

理解问题和写出算法实现之间还有最后一步需要跨越，程序实现有自己的特点，如果数据模型设计不合理，会导致算法实现困难，这一步往往是很多人的瓶颈。

“一千个人眼里有一千个哈姆雷特”，所以，我们在设计这个问题的数据模型的时候，不仅要考虑是否能够实现对解空间的穷举遍历，还要考虑是否能简单高效地判断解的状态是不是正确的解。

接下来要介绍的数据模型设计只是能解决问题的各种数据模型中的一种，为了便于用代码实现算法，这种数据模型中体现了很多设计数据模型常用的技巧。

#### 基本模型的定义

这个问题定义的状态二维表共有 25 个属性，这些属性分为 5 个类别，每个类别都有 5 个不同的值可供选择。

如果任由这 25 个属性离散存在，会给设计算法带来困难，一般算法建模都会用各种数据结构将这些属性组织起来，仔细观察这些属性，会发现每个属性都可以用“类型+值（TLV）”二元组来描述。

举个例子，房子颜色是个类型，黄色就是值，组合成“黄色房子”就是一个属性；

再比如饮料是个类型，啤酒则是值，组合成一个属性就是某个人喝啤酒。

用 TLV 描述每个属性的好处是我们不需要将 25 个属性分成 5 类区别处理，在算法穷举的过程中，可以对这 25 个属性进行一致性处理。根据这个原则，我们把属性的数据结构定义如下：

```c++
typedef enum 
{
    type_house = 0;
    type_nation = 1,
    tye_drink = 2,
    type_pet = 3,
    type_cigaret = 4
}ITEM_TYPE;

typedef struct
{
    ITEM_TYPE type;
    int value;
}ITEM;
```

ITEM_TYPE 是个枚举类型的量，可以是房子颜色、国籍、饮料类型、宠物类型和香烟牌子五种类型之一，

value 是 type 对应的值，value 的取值范围是 0~4，

根据 type 的不同，0~4 代表的意义也不相同。

如果 type 对应的是房子颜色，则 value 取值 0~4 分别代表蓝色、红色、绿色、黄色和白色，如果 type 对应的是饮料类型，则 value 取值 0~4 分别代表茶、水、咖啡、啤酒和牛奶。

为了算法代码的可读性，每种类型都定义了与之对应的常量，以颜色类型为例：

```C++
const int COLOR_BLUE    = 0;
const int COLOR_RED     = 1;
const int COLOR_GREEN   = 2;
const int COLOR_YELLOW  = 3;
const int COLOR_WHITE   = 4;
```

有了属性和值的定义，如何将它们组织起来呢？

观察上面的二维表，我们发现这 25 个属性是个矩阵关系，在两个维度上都存在关系，可以按照类型组织，也可以按照同一推理之间的关系组织。

根据题目描述，每个人住在一种颜色的房子中，喝一种饮料、养一种宠物、抽一种牌子的香烟，这些关系是固定的，一个人不会同时养两种宠物或喝两种饮料。

我们把这种固定的关系称为组（GROUP），一个组中包含一种颜色的房子、一个国籍的人、一种饮料、一种宠物和一种牌子的香烟，他们之间的关系是固定的。既然是这样，是不是可以将 GROUP 数据结构设计成这个样子呢？

```c++
const int GROUPS_ITEMS = 5;
typedef struct tagGroup
{
    ITEM items[GROUPS_ITEMS];
}GROUP;
```

这样设计中规中矩，但是会给算法实现带来麻烦，访问每种属性都要遍历 items，通过每个 items 的 type 属性确定要访问的类型。

比如要查询房子的颜色是不是蓝色，就不得不这么做：

```c++
for(int i = 0, i < GROUPS_ITEMS;i++)
{
    if(items[i].type == type_house)
    {
        if(items[i].value == COLOR_BLUE)
        {
            ......
        }
    }
}
```

在本课程的基础部分，我们在介绍算法设计的常用技巧时提到，在设计数据结构和算法时利用数组下标的技巧，这里又是一个例子。

考虑到上面的麻烦，需要修改 GROUP 的设计，不妨将每种类型在 GROUP 中的位置固定，然后直接利用数据下标进行访问。

比如将房子颜色类型固定为数组第一个元素，将国籍固定为数组第二个元素，以此类推，这样 GROUP 定义中可以不需要属性的类型信息（类型信息已经由数组下标表达），只需要一个值信息即可：

```c++
typedef struct 
{
    int itemValue[GROUPS_ITEMS];
}GROUP;
```

使用这种定义数据结构的方式，不仅可以减少设计算法实现的麻烦，还可以提高算法执行效率。比如现在要查看一个 GROUP 绑定组中房子的颜色是否是蓝色，就可以这样编写代码：

```c++
if(group.itemValue[type_house] == COLOR_BLUE)
{
    ......
}
```

对比前一种的循环遍历方式，不仅效率高，代码实现也简单。



#### 线索模型定义

除了模型表达困难，这个题目比之前介绍的题目的困难之处还在于那 15 条线索的描述，如何将这些看起来毫无章法的描述信息化并用合适的数据模型来表达它们是个很大的挑战。

线索数据模型的意义在于判断一个枚举结果是否正确，如果某个枚举结果能够符合全部 15 条线索，那这个结果就是最终的正确结果。

因此，线索数据结构的定义非常关键，如果定义不好，不仅算法实现会遇到很大的麻烦，而且影响算法实现的效率。即使最后设计出了算法实现，也是到处都是长长的 if…else 分支，本课中多次强调，代码中长长的 if…else 分支结构意味着出现了不良设计的坏味道。

先分析一下这 15 条线索，大致可以分成三类：

第一类是描述某些属性之间具有固定绑定关系的线索，比如，“丹麦人喝茶”和“住绿房子的人喝咖啡”等，线索 1、2、3、5、6、7、12、13 可归为此类；

第二类是描述某些属性类型所在的“组”所具有的相邻关系的线索，比如，“养马的人和抽 Dunhill 牌香烟的人相邻”和“抽 Blends 牌香烟的人和养猫的人相邻”等，线索 10、11、14、15 可归为此类；

第三类就是不能描述属性之间固定关系或关系比较弱的线索，比如，“绿房子紧挨着白房子，在白房子的左边”和“住在中间那个房子里的人喝牛奶”等。

对于第一类具有绑定关系的线索，绑定关系描述中有两组 TLV 的信息。以线索3：“丹麦人喝茶”这条绑定线索为例，第一组 TLV 信息是“国籍-丹麦”，第二组 TLV 信息是“饮料类型-茶”。绑定关系的意义在于对于一个 group 关系来说，当其某个属性符合绑定描述的第一组条件时，则其与第二组 TLV 信息中指定的类型相同的另一个属性的值也必须与第二组 TLV 中要求的值匹配，否则的话就不符合这个绑定关系。

对于绑定类型的线索，其数学模型可以这样定义：

```c++
typedef struct
{
    ITEM_TYPE first_type;
    int first_value;
    ITEM_TYPE second_type;
    int second_value;
}BIND;
```

type 和 value 是某个 group 内某个属性的类型和值，`relation_type`和`relation_val`是与该属性所在的 group 相邻的 group 中与之有关系的属性的类型和值。

以线索10：“抽 Blends 牌香烟的人和养猫的人相邻”为例，type 就是`type_cigaret`，value 就是`CIGARET_BLENDS`（`CIGARET_BLENDS`是个整数型常量），`relation_type`是`type_pet`，`relation_value`是`PET_CAT`（`PET_CAT`是个整数型常量）。同样，线索 10、11、14、15 就可以存储在 relations 数组中：

```c++
const RELATION relations[] = 
{
    { type_cigaret, CIGARET_BLENDS, type_pet, PET_CAT },
    { type_pet, PET_HORSE, type_cigaret, CIGARET_DUNHILL },
    { type_nation, NATION_NORWAY, type_house, COLOR_BLUE },
    { type_cigaret, CIGARET_BLENDS, type_drink, DRINK_WATER }
};
```

对于第三类线索，无法建立统一的数学模型，只能在枚举算法进行过程中直接使用它们过滤掉一些不符合条件的组合结果。

比如线索8：“住在中间那个房子里的人喝牛奶”，就是对每个饮料类型组合结果直接判断 groups[2].itemValue[type_drink] 的值是否等于 `DRINK_MILK`，如果不满足这个线索就不再继续下一个元素类型的枚举。

再比如线索4：“绿房子紧挨着白房子，在白房子的左边”，就是在对房子类型进行组合排列时，将绿房子和白房子看成一个整体进行排列组合的枚举，得到的结果直接符合了线索4的要求。

到这里，问题的状态与数据模型就分析完了，下一课我们继续讲解搜索算法是如何实现的。



#### 搜索算法实现

与其他穷举类算法一样，本问题的穷举法的实现也包含两个典型过程

一个是对所有状态的穷举过程，另一个是对状态的正确判定过程。

本问题的穷举搜索过程明显比之前的几个题目复杂，因为每个状态有 5 个类型，每个类型都要对 5 个值进行排列组合。

#### 枚举所有状态

前几课介绍了几个线性空间的搜索和树状空间的搜索的例子，这些例子中的状态都比较简单，可以边遍历边生成新状态，并且状态的合法性判断也比较简单。

本题则有些特殊，需要对不同类型的元素分别用穷举法进行枚举遍历，然后再将枚举遍历的结果按照组的关系组合起来才能得到一个状态（完整的二维表），并且组合的方法不是线性关系的组合，而是类似阶乘的几何关系的组合。

状态遍历算法的具体思路就是按照 group 中的元素顺序，依次确定状态二维表中各个元素的值。

首先对房子根据颜色组合进行穷举，每得到一组房子颜色组合后，记录到状态二维表的第一列，然后在此基础上对住在房子里的人的国籍进行穷举，将国籍的穷举结果记录到二维状态表的第二列，同时将国籍穷举得到的集合与房子颜色的结果做排列组合，并在这个组合结果的基础上，继续对饮料类型进行穷举和排列组合。

以此类推，直到穷举完最后一种类型得到完整的状态二维表。其遍历组合的过程如图（1）所示，在这么多组合的结果中，只有蓝色的那一个组合结果才完全符合题目的要求，是一个正确的结果。

![穷举](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\穷举.png)

现在考虑算法实现，首先从房子颜色开始枚举。5 间房子、5 种颜色，全排列共有 P55=120 种排列方式。

像这种 n 个属性进行全排列常用的算法实现方式有两种，一种是用 n 重循环方式，另一种是用递归方式。

《算法的乐趣》一书中为了使代码看起来简练一点，使用了递归的方式，本课程准备的时候，为了使读者更容易看懂算法实现，就改成了 5 重循环方式。

有兴趣的读者可以到图灵社区下载那本书的随书代码，比较一下两种方法的差异。

ArrangeHouseColors() 函数中的 5 重 for 循环可以看作是 n 重循环方式的一个模板，因为全排列不能有重复，也就是说不能有类似`{ COLOR_BLUE,COLOR_GREEN,COLOR_WHITE,COLOR_GREEN,COLOR_YELLOW }`这样的组合结果，因为 COLOR_GREEN 有重复，所以从第二重循环开始，增加了对循环变量是否重复的判断，分别是第 8 行、第 12 行、第 16 行和第 21 行的 if 条件判断。当发生重复的时候，continue 语句的作用就是跳过这个值，继续下一个值（continue 语句只影响当前循环）。5 重循环、5 个循环变量：i、j、k、p 和 q，分别代表 5 间房子的颜色。

对房子颜色枚举的时候，要对“绿房子紧挨着白房子，在白房子的左边”这样的特殊情况做特殊处理，这个处理体现在第 30 行还是 for 循环。

这个 for 循环遍历了所有当前排列得到的房子颜色，当发现绿色房子的时候，就判断它右边相邻的房子是否是白色，如果是，说明当前枚举的结果符合这个要求，可以调用 ArrangeHouseNations() 函数继续对国籍进行枚举处理。

如果它右边相邻的房子不是白色，则不做处理，继续循环排列下一个结果。

```
/* 遍历房子颜色*/
void ArrangeHouseColors(GROUP *groups)
{
    for (int i = COLOR_BLUE; i <= COLOR_WHITE; i++)
    {
        for (int j = COLOR_BLUE; j <= COLOR_WHITE; j++)
        {
            if (j == i)
                continue;
            for (int k = COLOR_BLUE; k <= COLOR_WHITE; k++)
            {
                if ((k == i) || (k == j))
                    continue;
                for (int p = COLOR_BLUE; p <= COLOR_WHITE; p++)
                {
                    if ((p == i) || (p == j) || (p == k))
                        continue;

                    for (int q = COLOR_BLUE; q <= COLOR_WHITE; q++)
                    {
                        if ((q == i) || (q == j) || (q == k) || (q == p))
                            continue;

                        groups[0].itemValue[type_house] = i;
                        groups[1].itemValue[type_house] = j;
                        groups[2].itemValue[type_house] = k;
                        groups[3].itemValue[type_house] = p;
                        groups[4].itemValue[type_house] = q;

                        for (int groupIdx = 0; groupIdx < (GROUPS_COUNT - 1); groupIdx++)
                        {
                            if ((groups[groupIdx].itemValue[type_house] == COLOR_GREEN)
                                && (groups[groupIdx + 1].itemValue[type_house] == COLOR_WHITE))
                            {
                                ArrangeHouseNations(groups);
                            }
                        }
                    }
                }
            }
        }
    }
}
```

ArrangePeopleDrinks() 函数对 5 种饮料进行全排列枚举，对饮料的排列也有一个特殊规则，即“住在中间房子里的人喝牛奶”。和国籍的枚举处理方式一样，这里也是先固定中间房子的饮料类型为 `DRINK_MILK`，然后对剩下的四个房子和四种饮料进行全排列，得到 P44=24 种排列结果。每得到一组结果，就调用 ArrangePeoplePet() 函数继续对宠物进行枚举。

```c++
void ArrangePeopleDrinks(GROUP *groups)
{
    /*应用规则(8)：住在中间那个房子里的人喝牛奶；*/
    groups[2].itemValue[type_drink] = DRINK_MILK;

    for (int i = DRINK_TEA; i <= DRINK_BEER; i++)
    {
        for (int j = DRINK_TEA; j <= DRINK_BEER; j++)
        {
            if (j == i)
                continue;
            for (int k = DRINK_TEA; k <= DRINK_BEER; k++)
            {
                if ((k == i) || (k == j))
                    continue;
                for (int p = DRINK_TEA; p <= DRINK_BEER; p++)
                {
                    if ((p == i) || (p == j) || (p == k))
                        continue;

                    groups[0].itemValue[type_drink] = i;
                    groups[1].itemValue[type_drink] = j;
                    groups[3].itemValue[type_drink] = k;
                    groups[4].itemValue[type_drink] = p;

                    ArrangePeoplePet(groups);
                }
            }
        }
    }
}
```

对宠物和对香烟品牌的枚举没有特殊规则需要处理，都是直接 5 重循环，最后枚举完香烟品牌后，就得到了一个完整的二维状态表，接下来就是调用 DoGroupsfinalCheck() 函数对结果做最后的检查。

#### 状态的正确性判断

通过前面“线索模型定义”的分析，将 15 条解题信息分为三类，其中第三类线索已经融入到枚举过程中了，因此判断结果的正确性只需要用第一类线索和第二类线索进行过滤即可。DoGroupsfinalCheck() 函数就是依次检查全部第二类线索和第三类线索，如果检查结果符合题目要求，则输出当前结果。

```
void DoGroupsfinalCheck(GROUP *groups)
{ 
    if(CheckAllGroupsBind(groups, binds) && CheckAllGroupsRelation(groups, relations))
    {
        PrintAllGroupsResult(groups, GROUPS_COUNT);
    }
}
```

第一类线索是同一 GROUP 内的属性之间的绑定关系，用来描述的是一个 group 内两种属性之间的固定关系。对这类线索的判断的方法就是遍历全部的“组（groups）”，找到与 BIND 数据中的 `first_type` 和 `first_value` 标识相匹配的那个 group 组，然后检查 group 组中类型为 `second_type` 的属性的值是否等于 BIND 数据中的 `second_value`。如果 group 中类型为 `second_type` 对应属性的值与 `second_value` 的值不一致就直接返回检查失败，否则就说明当前的组合结果满足此 BIND 数据对应的线索，然后对下一个 BIND 数据重复上述检查过程，直到检查完 binds 数组中所有线索对应的 BIND 数据。

CheckAllGroupsBind() 函数负责对绑定关系进行检查，for 循环遍历所有的绑定关系，只要 FindGroupIdxByItem() 发现某个组里有符合 `first_type` 和 `first_val` 的属性，就立即检查其 `second_type` 对应属性的值是否与绑定关系中要求的 `second_val` 一致。以第一条绑定规则为例（英国人住在红色的房子里）：

```c++
{ type_house, COLOR_RED, type_nation, NATION_ENGLAND }
```

只要 FindGroupIdxByItem() 发现某个组匹配了第一个类型和值，即：

```
group[x].itemValue[type_nation] == NATION_ENGLAND ？？？
```

```c++
bool CheckGroupBind(GROUP *groups, int groupIdx, ITEM_TYPE type, int value)
{
    if(GetGroupItemValue(&groups[groupIdx], type) != value)
    {
        return false;
    }

    return true;
}

bool CheckAllGroupsBind(GROUP *groups, const BIND *binds)
{
    for(int i = 0; i < BINDS_COUNT; i++)
    {
        int grpIdx = FindGroupIdxByItem(groups, binds[i].first_type, binds[i].first_val);
        if(grpIdx != -1)
        {
            if(!CheckGroupBind(groups, grpIdx, binds[i].second_type, binds[i].second_val))
            {
                return false;
            }
        }
    }

    return true;
}
```

第二类线索是 group 之间的相邻关系线索，描述的是相邻的两个 group 之间的属性的固定关系，判断的方法就是遍历全部的 group，找到 RELATION 数据中的 type 和 value 标识的元素所匹配的 group 组，然后分别检查与 group 相邻的两个组（第一个组和最后一个组只有一个相邻的组）中类型为 relation_type 的元素对应的值是否等于 `relation_value`，如果相邻的组中没有一个能满足 RELATION 数据就表示当前组合结果不满足线索，直接返回检查失败。相邻的组中只要一个组中的元素满足 RELATION 数据描述的关系就表示当前组合结果符合 RELATION 数据对应的线索，需要对下一个 RELATION 数据重复上述检查过程，直到检查完 relations 数组中的全部线索对应的 RELATION 数据。

CheckAllGroupsRelation() 函数负责对关联关系进行检查，for 循环遍历所有的关联关系，只要 FindGroupIdxByItem() 函数发现某个组中有关联关系匹配的类型和值（类型和值必须都匹配），就检查这个组的前一个组和后一个组是否有匹配第二个类型和值的情况，如果有则满足关联关系，否则不满足关联关系。代码中为了避免越界，CheckGroupRelation() 函数对第一个组和最后一个组的情况做了特殊处理，当 groupIdx == 0 的时候，只检查后面的一组，当 groupIdx == (GROUPS_COUNT - 1) 的时候，只检查前面的一组。

```c++
bool CheckGroupRelation(GROUP *groups, int groupIdx, ITEM_TYPE type, int value)
{
    if(groupIdx == 0)
    {    //只检查后一个组
        if(GetGroupItemValue(&groups[groupIdx + 1], type) != value)
        {
            return false;
        }
    }
    else if(groupIdx == (GROUPS_COUNT - 1))
    {    //只检查前一个组
        if(GetGroupItemValue(&groups[groupIdx - 1], type) != value)
        {
            return false;
        }
    }
    else
    {    //检查前后两个组
        if( (GetGroupItemValue(&groups[groupIdx - 1], type) != value)
            && (GetGroupItemValue(&groups[groupIdx + 1], type) != value) )
        {
            return false;
        }
    }

    return true;
}

bool CheckAllGroupsRelation(GROUP *groups, const RELATION *relations)
{
    for(int i = 0; i < RELATIONS_COUNT; i++)
    {
        int grpIdx = FindGroupIdxByItem(groups, relations[i].type, relations[i].val);
        if(grpIdx != -1)
        {
            if(!CheckGroupRelation(groups, grpIdx, relations[i].relation_type, relations[i].relation_val))
            {
                return false;
            }
        }
    }

    return true;
}
```

同样以第一条关联规则为例（抽 Blends 牌香烟的人和养猫的人相邻）：

```c++
{ type_cigaret, CIGARET_BLENDS, type_pet, PET_CAT }
```

首先由只要 FindGroupIdxByItem() 发现某个组匹配了抽牌子香烟的人：

```c++
if(group[groupIdx].itemValue[type_cigaret] == CIGARET_BLENDS)
{
    //...
}
```

就会检查其相邻的 group 是否匹配关联关系中要求的类型和值，即检查：

```c++
group[groupIdx-1].itemValue[type_pet] ？= PET_CAT
group[groupIdx+1].itemValue[type_pet] ？= PET_CAT
```

得益于线索模型定义的技巧，CheckAllGroupsBind() 函数和 CheckAllGroupsRelation() 函数的实现非常简单，检查算法只需要遍历 binds 数组和 relations 数组即可，避免了写很多 if…else 分支。

#### 总结

一共有多少种这样的组合结果呢？我们来简单计算一下。首先是对房子颜色进行穷举，因为是 5 种颜色的不重复组合，因此应该有 5！= 120 个颜色组合结果，但是根据线索4 “绿房子紧挨着白房子，在白房子的左边”，相当于绿房子和白房子有稳定的绑定关系，实际就只有 4！= 24 个颜色组合结果。接下来对 24 个房子颜色组合结果中的每一个结果再进行住户国籍的穷举，理论上国籍也有 5！= 120 个结果，但是根据线索9 “挪威人住在第一个房子里面”，相当于固定第一个房子住的人始终是挪威人，因此就只有 4！= 24 个国籍组合结果。穷举完房子颜色和国籍后就已经有 24 x 24 = 576 个组合结果了，接下来需要对这 576 个组合结果中的每一个结果再进行饮料类型的穷举，理论上饮料类型也有 5！= 120 个结果，但是根据线索8 “住在中间那个房子里的人喝牛奶”，相当于固定了一个饮料类型，因此也只有 4！= 24 个饮料组合类型。穷举完饮料类型后就得到了 576 x 24 = 13824 个组合结果，接下来对 13824 个组合结果中的每一个结果再进行宠物种类的穷举，这一步没有线索可用，共有 5！= 120 个结果。穷举完宠物种类后就得到了 13824 x 120 = 1658880 个组合结果，最后对 1658880 个组合结果中的每一个结果再进行香烟品牌的穷举，这一步依然没有线索可用，共有 5！= 120 个结果。穷举完香烟品牌后就得到了全部组合共 1658880 x 120 = 199065600 个结果。有将近两亿个组合结果，看来出现多个正确答案的可能性很大哟。但是，令人惊讶的是竟然只有一组结果能通过所有的线索检查，就是前面给出的答案。这个结果有点出乎预料，但是也从侧面说明了这个问题的难度。另外，对大约两亿个状态的穷举和检查需要耗时约 5s，这也体现了穷举法应用的一些局限性，就是当问题规模比较大时，穷举法是一个低效的方法。对于更大规模的问题，应尽量避免使用穷举法。

这个题目需要总结一下，这个题目比我们前几课的例子都复杂，无论是穷举所有状态的方法还是对结果的正确性判断，都需要一些特殊的技巧。我们精心设计了数据模型，将 15 条信息中的大多数抽象成绑定和关联两种关系，用静态数据提前设计好检查条件，简化了结果检查代码，避免了在一个大循环结构中各种复杂的 if 判断条件，也在某种程度上提高了代码的可读性。



### 3-7 多点同线问题

这一课我们介绍一个计算几何方面的穷举类算法问题。

计算几何类的问题也是算法问题中一个大的分类，并且在很多其他算法中都会用到一些几何公式。

比如三角形剖分问题中如果是按照三角形的面积做最优剖分，则需要用到根据三角形的边长求面积的海伦公式。

这一课我们用到的几何内容不多，只用到了求直线斜率的公式，主要还是为了演示穷举法的应用；同时还会介绍到一个用一遍扫描统计出有序序列中哪个值出现次数最多的代码技巧，以及快速排序在实际问题中的应用方法。

#### 问题描述

一个几何平面上有 N 个点，根据欧氏（欧几里得）几何原理，每两个点可以连成一条直线，N 个点可以连成很多条直线。

当然，也会有多个点共线的情况出现，现在我们的问题是，在这 N 个点中，找出哪两个点组成的直线上包含最多的点，也就是找出含有最多点的那条直线。

![QQ截图20190604224534](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190604224534.png)

如图（1）所示，在这么多直线中，绿色标识的那条直线包含了四个点，是包含最多点的直线。

算法比赛中这个题目给出所有点的坐标，要求算法只输出包含最多点的那条直线上所包含的点的个数即可，所以最后的结果只是算法实现上复杂一点，数据模型其实非常简单。

我们课程的主要目的是演示算法的分析、数据模型构建和编程实现算法的过程，以及在这个过程中分析和思考问题的方法，所以，我们修改一下题目要求。

首先为每个点增加一个编号，然后要求在输出信息时，输出最多共线点的个数以及这些点的信息，包括点的编号信息和坐标值。

增加的这些要求意味着什么？意味着我们需要在算法实现的过程中，小心地维护一组最多点的信息列表，以便最后输出结果时输出题目要求的内容。

不仅如此，算法过程中的各种处理，比如按照直线斜率的排序，都比原题目复杂一点。

#### 问题分析

现在开始分析这个问题。题目要求的结果是共线的点，但是题目给的信息只有点，所以要先想办法弄出直线才行。

根据几何知识，任意两个点可以组成一条直线，所以只需要将这 N 个点两两组合，就可以得到 N * (N − 1) 条直线。直线有了，剩下的事情就是判断其他的点是否在这条直线上。

所以，总结起来，这个算法的实现方法就是：

- 从 N 个点中选择两个点 (x1,y1) 和 (x2,y2)，构成一个两点式直线方程：y−y2/y1−y2=x−x2/x1−x2；
- 对剩下的 N − 2 个点，依次带入直线方程，确定是否在直线上，得到一个共线的点的记录；
- 重复上面步骤，直到所有点的组合都穷举一遍；
- 比较所有共线点的记录，输出最多点的那个记录。

这个算法需要处理 N * (N − 1) * (N − 2) 次点与直线关系的判断，整体的算法时间复杂度是 O(N^{3})O(N3)。如果点的数量不多，这个算法实现方案还能应付，但是在 OJ（Online Judge）上提交这个实现方案，基本都会超时。

现在换个思路再分析这个问题。是否一定要先有直线才能判断多点共线问题？肯定不是，因为直线还有一个特性，就是直线的斜率。

根据直线的公理，斜率相等的直线是平行线，那么，**如果这些斜率相等的直线都经过同一个点呢？那当然就是共线了**。

所以思路来了，我们以点为对象进行穷举，计算每个点与其他点组成的直线的斜率，斜率相等的那些点肯定就是共线的点了。

以图（2）为例，我们选择 K 点，然后计算 K 点与其他各点组成的直线的斜率，可能有很多个斜率，只要相等的，肯定是共线的（因为它们都经过 K 点）。

![QQ截图20190604225559](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190604225559.png)

从图（2）上看到，经过 K 点的共线情况最多是 3 点共线，有三种情况都是 3 点共线。

是否这个题目的最终结果就是最多 3 点共线呢？不一定，还要继续看看其他点的情况。比如图（3）所示，选择 A 点作为原点，计算 A 点与其他点的斜率，可以看出来，有一个 B、A、F 和 H 四个点共线的结果，这肯定由于 K 点的情况。至于最终的结果，要穷举完所有的点才能下结论。

![QQ截图20190604225702](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190604225702.png)

根据以上分析，新的算法实现方法可以总结为：

- 从 N 个点中选择一个点作为原点 (x0,y0)；
- 计算其他 N - 1 个点与原点的斜率k=yi−y0/xi−x0
- 统计上一个操作得到的 N -1 个斜率值中相同斜率的个数，记录相同斜率最多的那一组结果；
- 重复前面的操作，直到处理完所有的点，比较每个点得到的记录，取最多的那一组作为最终的结果。

其中第 3 步的描述可能有点难以理解，它的大致意思是这样的：假如有 10 个点，对于第 1 个点，计算其余 9 个点与这个点组成的直线斜率，得到 9 个斜率值：

![QQ截图20190604225830](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190604225830.png)

统计这 9 个斜率值，我们发现 9.82 出现了 2 次，15.21 出现了 3 次，72.12 出现了 2 次，其他的值都只出现了 1 次。所以编号为 2、5 和 9 的 3 个点斜率值都是 15.21，加上作为原点的第 1 个点，得到的最高记录是 4 个点共线。我们将这四个点的信息作为第 1 个点的最高记录保存起来，准备与其他点统计到的最高记录比较，最后选择最多的那个结果作为最终的结果。

#### 数据模型设计

数据模型是结合问题来考虑怎么设计的，这个问题给我们的信息是点的个数和每个点的坐标，所以，我们首先要考虑的事情就是如何设计数据结构存储这些信息，并且在算法计算的过程中，能够方便地引用这些信息。

平面上的点由横坐标 x 和纵坐标 y 组成，通常会用一个数据结构来描述点：

```c++
typedef struct
{
    double x;
    double y;
}Point;
```

平面坐标是实数系，所以这两个坐标值都用浮点数表示。

进一步考虑，用何种数据结构存储所有点的信息呢？这些点是离散的，表示离散信息常用的数据结构有数组、链表、集合和哈希表。

对于这个问题，最好使用线性数据结构，并且使用集合和哈希表开销有点儿大，所以先排除**集合和哈希表**。

记得我们给这个问题增加的一点难度吗？就是我们要输出最多共线点的那些点的信息，这个信息中就包括点的编号。

基础部分提到过的数组下标的技巧大家没有忘记吧，这里又要用了。如果我们给每个点用数字编号，那么可以利用数组下标以 O(1) 时间复杂度直接根据编号得到其对应的点的坐标信息，所以，我们用数组。

上面“问题分析”中介绍算法过程的第 3 步，需要计算每个点与原点所组成的直线的斜率，以便找出斜率相同的那些点。

这里就需要能够在计算的过程中，存储每个斜率值所对应的点。我们用数字编号表示点，定义 Scope 数据结构表示斜率值和点的关系：

```c++
typedef struct
{
    double k;
    int p_idx;
}Slope;
```

基本上，这个题目的数据模型还是非常简单的，两个数据结构的设计也都是算法设计中的常用考量，就是把一组相同的属性组织在一起，便于整体维护和访问。

比如点的坐标，用 Point 对象来组织，要比用两个数组分开存储横坐标和纵坐标要好。



#### 算法实现

这个问题的模型很简单，算法实现也不复杂，但是算法实现的过程中还是有很多需要考虑的地方。

之所以选这个题目作为例子，是因为设计算法实现的过程中常遇到的情况，这个例子就有好几个，包括浮点数的处理和用一遍扫描统计出有序序列中哪个值出现次数最多的代码技巧。

#### 浮点数的处理

又遇到浮点数了，基础部分我们讲过浮点数处理需要注意的地方，这里再强调一次：**不要对两个浮点数直接判等（或判不相等），除非你明确知道你想做什么**。

简单来说，就是不要用 == 运算符直接判断两个浮点数是否相等（或者用 != 运算符直接判断两个浮点数是否不相等）。

很多读者不明白为什么不能直接判等，这里再啰嗦一下，计算机存储浮点数用的是二进制形式，它和逻辑上理解的十进制小数存在表达误差，也就是说有的十进制小数无法用二进制小数精确表达。

本来应该相等的两个浮点数由于计算机内部表示的原因可能略有微小的误差，这时用 == 判断，计算机会认为它们不相等，所以，你所希望的“等于”可能永远都不可能发生。

有人会说，我一直用 == 判断浮点数，也没什么问题啊？一般包括 0 在内的整数，0.2、0.65 这样的小数，计算机还是能精确表达的，这种情况下判等也不会出错，这就是我说“除非你明确知道你想做什么”这句话的原因。常在河边走，哪能不湿鞋？你总会遇到无法用二进制小数精确表达的浮点数的情况的，所以，**不要对两个浮点数直接判等，除非你明确知道你想做什么**。

另外，计算机表示的浮点数有效数位比较多，在某些条件下，直接判等的要求非常苛刻，比如迭代法中的迭代收敛条件，如果用判断最近两次迭代值相等作为迭代精度要求的退出条件，对于一些收敛比较慢的迭代算法来说，基本上就相当于死循环了。你会发现经过漫长的迭代之后，小数点后面 XX 位还是不相同的。

一般情况下，对于浮点数，只要在精度要求的误差范围内，就可以认为是相等了。常用的判断浮点数相等的方法就是：

```c++
const double EPS = 1e-8;
bool IsEqualFloat(double v1,double v2)
{
    if(std::fabs(v1-v2) < EPS)
    {
        return true;
    }
    return false;
}
```

精度值 EPS 可以根据问题的要求做调整，对于本问题，我们认为小数点后面 8 位有效数字相同，就满足等于的条件了。

#### 斜率计算

```c++
//#define DBL_MAX         1.7976931348623158e+308 /* max value */  

double CalcSlope(const Point& p0, const Point& p1)
{
    if (IsEqualFloat(p0.x, p1.x)) //点的 x 坐标相等，斜率为无穷大
    {
        return DBL_MAX; //用浮点数的最大值代表无穷大
    }

    return (p1.y - p0.y) / (p1.x - p0.x);
}
```

#### 算法分析第三步处理

算法分析的第三步，我们需要对计算出来的 N − 1 个斜率值进行统计，看看哪个斜率值出现的次数最多。一般的处理方法是：

1. 准备一张表记录各个斜率值出现的次数，初始化时这张表是空表；
2. 对每一个斜率值做 3 或 4 的处理；
3. 如果这个斜率值已经存在表中，则直接修改表中对应项的计数值 +1，并记录这个斜率值对应的点的信息；
4. 如果这个斜率值不存在，则将其增加到表中，将计数值置为 1，并记录这个斜率值对应的点的信息；
5. 遍历这 N − 1 个斜率值，重复第 2 ~ 4 步，直到每个斜率值都统计过一遍；
6. 最后遍历统计表，找出计数值最高的斜率值和其对应的所有点的信息（也可使用排序）。

上述方法的问题是需要额外的存储空间存储这张表，并且最终还是要对表中的数据做一次遍历。

对于这种统计哪个值出现次数最多的问题，这里介绍一种直接排序，然后一次遍历得到结果的技巧，这个技巧所采用的方法不需要额外的存储空间，并且这个方法是个惯用方法，我在很多算法题目中都看到过，读者可以将其作为一种实现模式记下来，以后遇到此类问题可以直接拿来用。这个技巧的处理方法如下。

1. 首先对这 N − 1 个斜率值进行排序（升序或降序都可以）。
2. 准备好四个标志变量，分别是：`max_len` 表示已经找到的最多斜率值相同个数，`max_start_pos` 表示已经找到的最多相同斜率值的第一项在排序后列表中的位置，len 表示当前正在处理的斜率值的相同个数，`start_pos` 表示当前正在处理的相同斜率值的第一项在排序后列表中的位置。这四个标志变量的初始值分别是 `max_len=0`、`max_start_pos=0`、len=1、`start_pos=0`。
3. 从排序后斜率值中的第 2 项开始，依次与前一项比较，做 4 或 5。
4. 如果某项的值与前一项相同，则 len 值加 1。
5. 如果某项的值与前一项不相同，则判断 len 是否大于 `max_len`，如果是，则用当前的 len 和 `start_pos` 值更新
   `max_len` 和 `max_start_pos`，即 `max_len = len`，`max_start_pos = start_pos`；如果 len 小于 `max_len`，则不做更新，但是要重置当前扫描状态，即`start_pos`赋值为当前扫描的位置，同时 len 赋值为 1。
6. 如果斜率值都处理完，返回 `max_len` 和 `max_start_pos` 作为结果，如果没有处理完，则重复步骤 3-5。

我们接着用“问题分析”给的那个斜率表中的例子，对其按照升序排序后，得到的结果如下。

![QQ截图20190604231139](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190604231139.png)

1. 初始值：`max_len=0`、`max_start_pos=1`、len=1、`start_pos=1`。
2. 处理第 2 项，其值为 9.82，与前一项（第 1 项）相同，则 len 值 +1，此时 len=2。
3. 处理第 3 项，其值为 15.21，与前一项（第 2 项）不相同，此时 len（2）值大于 max_len（0），执行替换，替换后`max_len=2`，`max_start_pos=0`（因为`start_pos = 0`），然后将 `start_pos` 赋值为当前位置 3，将 len 赋值为 1。
4. 处理第 4 项，其值为 15.21，与前一项（第 3 项）相同，则 len 值 +1，此时 len=2。
5. 处理第 5 项，其值为 15.21，与前一项（第 4 项）相同，则 len 值 +1，此时 len=3。
6. 处理第 6 项，其值为 36.34，与前一项（第 5 项）不相同，此时 len（3）值大于 `max_len（2）`，执行替换，替换后 `max_len=3`，`max_start_pos=3`（因为 `start_pos = 3`），然后将 `start_pos` 赋值为当前位置 6，将 len 赋值为 1。
7. 处理第 7 项，其值为 72.12，与前一项（第 6 项）不相同，此时 len（1）小于 max_len（3），不执行替换，然后将 start_pos 赋值为当前位置 7，将 len 赋值为 1。
8. 处理第 8 项，其值为 72.12，与前一项（第 7 项）相同，则 len 值 +1，此时 len=2。
9. 处理第 9 项，其值为 124.54，与前一项（第 8 项）不相同，此时 len（2）小于 max_len（3），不执行替换，然后将 start_pos 赋值为当前位置 9，将 len 赋值为 1。
10. 结束处理，此时 `max_len=3`，`max_start_pos=3`，即最相同的斜率值是从（排序后列表的）第 3 项开始的那个斜率，长度为 3 项。

结合之前的处理方法来说明上述例子的展示，这个技巧的算法实现应该不难理解：

```c++
typedef struct
{
    int start_idx;
    int count;
}Slope_Rec;

Slope_Rec GetMaxPointList(const std::vector<Slope>& slopes)
{
    int max_len = 0;
    int max_start_pos = 0;

    int len = 1;
    int start_pos = 0;
    for (int s = 1; s < slopes.size(); s++) //从第2项开始
    {
        if (!IsEqualFloat(slopes[s].k, slopes[s - 1].k)) //是否相同
        {
            if (len > max_len) //是否需要更新 max_len 和 max_start_pos
            {
                max_len = len;
                max_start_pos = start_pos;
            }
            start_pos = s; //赋值当前位置统计下一个
            len = 1;
        }
        else
        {
            len++;
        }
    }

    return { max_start_pos, max_len };
}
```

#### 对快速排序的演示代码进行改造

```c++
std::sort(slopes.begin(), slopes.end(), 
          [](const Slope & s1, const Slope & s2) { return s1.k < s2.k; });
```

但是很多读者希望我多介绍一些基础的内容，所以这里我将基础部分介绍过的快速排序算法改造一下，使之适合本问题的数据模型，用于替换标准库的排序算法。

基础部分介绍分治法我给出了一个快速排序的例子算法实现，那个实现和数据结构书中的实现别无二致，弄个数组，然后排排序，用于演示算法原理。

但是现实中的大部分问题都不是简单的整数数组，而是数据表，表中的每一项都是一个数据集合，对整个数据表进行排序和对数据排序有稍微的差别，好在基本排序的原理是不变的，变的只是对数据结构的处理差异。

排序都是基于关键字进行的，集合中关键字之外的属性都是跟随属性，随着记录的移动来移动它们就行，所以要先确定关键字。

关键字就是要做数据比较的那个属性，对于 Slope 集合的排序，关键字就是斜率 k

这里要说明一下，更一般的考虑，是将排序设计成抽象接口，就像上面给出的 std::sort() 算法一样，但那不是本课程考虑的内容，读者可自行发挥。这里我们考虑的是如何改造数据接口定义，将理论上的通用算法应用到解决具体的问题上。

首先改造用于交换数据元素的 exchange() 函数，这里要交换的就不是两个整数了，而是两个 Slope 数据集合。其实，也很简单：

```c++
void exchange(std::vector<Slope>& slopes, int m, int n)
{
    Slope tmp = slopes[m];
    slopes[m] = slopes[n];
    slopes[n] = tmp;
}
```

然后是 partion() 函数，需要修改的地方不多，只是比较部分强调是对关键字 k 进行比较：

```c++
int partion(std::vector<Slope>& slopes, int p, int r)
{
    Slope x = slopes[r];
    int i = p;
    for (int j = p; j < r; j++)
    {
        if (slopes[j].k < x.k) //只比较关键字
        {
            if (i != j)
            {
                exchange(slopes, i, j);
            }
            i++;
        }
    }
    exchange(slopes, i, r);
    return i;
}
```

最后的函数，貌似只需要改 slopes 就可以了：

```c++
void quick_sort(std::vector<Slope>& slopes, int p, int r)
{
    if (p < r)
    {
        int mid = partion(slopes, p, r);
        quick_sort(slopes, p, mid - 1);
        quick_sort(slopes, mid + 1, r);
    }
}
```

使用改造后的快速排序算法代替前面使用 STL 算法库的例子：

```c++
std::vector<Slope> slopes;

quick_sort(slopes, 0, slopes.size() - 1);
```

#### 算法主体

StraightLine() 函数的第 3 行和第 6 行又看到了熟悉的两重循环结构，还有第 8 行的 if (i == j) 的跳过处理，这是典型的从 N 个目标中任选 2 个（不能重复）的处理模式，要记下来啊。第 6 行的内层循环计算编号 i 的点与其他点组成的直线斜率，并存储在 slopes 数组中。第 15 行排序，不解释了，第 17 行求 slopes 中的最大相同点信息，前面解释过原理了，这里也不再啰嗦。返回值 pts 中存放算法最终要返回的结果，pts 只记录点的编号，外层在循环过程中，这里的结果会被不断地更新，直到算法完成，pts 里面的值才是最终的结果。

第 18 到 28 行的代码，就是对 pts 进行更新处理，如果 posi 返回的结果优于 pts 中已经存的结果，则进行依次更新。更新的步骤是先清除之前的记录，然后将当前处理的点加入记录（ i 对应编号的点），毕竟这个点也是共线的点嘛。接着从 slopes 数组中逐项添加斜率相同的点，slopes 已经排序，并且 posi 返回的是其中最好的一组结果的开始位置和长度，直接复制数据就可以了。

```c++
void StraightLine(const std::vector<Point>& points, int n, std::vector<int>& pts)
{
    for (int i = 0; i < n; i++)
    {
        std::vector<Slope> slopes;
        for (int j = 0; j < n; j++)
        {
            if (i == j)
                continue;

            double k = CalcSlope(points[i], points[j]);
            slopes.push_back({ k, j });
        }

        quick_sort(slopes, 0, slopes.size() - 1); //排序

        Slope_Rec posi = GetMaxPointList(slopes);// 取当前最大记录
        if (posi.count > pts.size()) //与已经保存的其他点的最大记录比较
        {
            //需要更新最大记录
            pts.clear();
            pts.push_back(i); //先将原点加入
            //再将斜率表中的其他点加入（都是斜率相同的点，p_idx 记录的是点的编号）
            for (int p = posi.start_idx; p < (posi.start_idx + posi.count); p++)
            {
                pts.push_back(slopes[p].p_idx);
            }
        }
    }
}
```

通过这一课的题目，读者应该学到几点，首先，判断点是否在直线上，不是一定要先弄出直线方程，然后再将点的坐标带入方程计算，还可以用共点且斜率相等的方法判断；其次是浮点数处理的一般原则；还有就是如何改造你在数据结构课上学到的快速排序算法，使其与实际问题的数据模型相结合，解决实际的排序问题；最后，是一个用一遍扫描统计出有序序列中哪个值出现次数最多的代码技巧。



### 3-8 如何设计递归函数

#### 如何分析递归程序

递归不是“先有鸡还是先有蛋的问题”，也不是“从前有座山，山里有座庙……”，严格来说，递归应该不是算法设计，而是算法实现范畴的内容，因为它并不属于任何一种算法模式。

作为算法实现的一种常用形式，递归程序常常让新手望而却步。

难在两点，其一是相对于顺序执行的线性代码或重复执行的循环代码，递归程序不是很容易在脑子里形成代码流程，分析代码的时候，常常在几层递归调用之后，就记不得各层递归调用的上下文环境了；其二是递归程序设计比较困难，新手常常感觉无从下手。

这一课，我就从递归程序的分析方面分享一些我的经验。

分析递归程序，不要像分析循环或线性程序代码那样，直接带入上下文环境进行死算，因为这样很容易迷失在代码细节中，只见树木、不见森林，最后都记不得哪一层参数是哪一层的上下文环境了。

递归体现的是类似与“以此（方法）类推”或“以同样的操作模式（步骤）重复……”这样的思想（有点类似于数学归纳法）。

因此，我的经验是先总体上分析一下代码，看看这个递归程序的整体结构是什么，各种类型的递归算法实现虽然在形式上有很大的差异，但是总体上其实都可以划分成三个主要组成部分：

- 第一个组成部分就是递归子结构（或递归主体），所谓递归子结构就是递归程序中可重入的主体部分；
- 第二个组成部分是递归的退出条件和退出处理，很显然，如果没有退出条件，就会无穷递归下去，直到栈溢出，但需要注意的是，递归退出条件可不仅仅是控制递归退出，很多情况下都会在满足退出条件时做一些处理，比如直接解决最小子问题 （这一句不理解没关系，后面看例子）；
- 第三个组成部分是递归算法的自我再触发机制，如果没有再触发的机制，自然就没有递归过程了，一般情况下，递归的再触发机制常常包含在递归子结构的处理过程中，很多情况下区分不是很明显，读者只要记得，再触发机制就发生在递归函数自我调用的地方，分析这部分的代码就可以找到再触发机制，至于是否一定要和递归子结构区分开来，倒也未必一定需要这么做。



#### 二叉树遍历的简单例子

下面来看一个经典的二叉树前序遍历算法，这是个数据结构课的“Hello World”算法。按照我们的思路，首先找到递归的退出条件，就是从上一级递归触发机制传递进来的节点指针是 NULL 的时候，表示已经遍历到二叉树叶子节点的子树了（叶子节点的子树指针是 NULL），不需要对其进行递归子结构主体部分的操作了。

一个设计良好的递归函数，一般都会在函数入口位置进行退出条件的判断，我们在设计递归函数实现的时候，最好也在显眼位置放置退出的代码。

接下来的 std::cout 是打印数据，算是对数据的操作，后面分别对左子树和右子树的递归调用就是我们说的再触发机制。这个遍历算法的再触发机制非常简单，就是先对左子树来一波操作，再对右子树来一波操作，然后结束。

递归程序中的再触发机制只是按照问题的解决方案触发递归调用，至于递归调用做什么操作，再触发机制是不关心的，它只知道现阶段无法解决这个问题，需要把问题用递归的方式委托给“自身”，通过函数参数通知“自身”这次递归调用要处理什么数据，希望“自身”在条件具备的时候解决委托给它的问题。至于这次递归调用做什么操作，那是递归子结构关心的事情。

```c++
struct TreeNode
{
    int data;
    TreeNode *left;
    TreeNode *right;
};

void PreOrderPrint(TreeNode *node)
{
    if (node == NULL)
        return;

    /*对节点的操作，本函数只是输出节点数值*/
    std::cout << node->data << std::endl;

    PreOrderPrint(node->left); //继续遍历左子树
    PreOrderPrint(node->right); //继续遍历右子树
}
```





### 3-9 推箱子游戏

推箱子游戏也是一个很经典的益智类小游戏，很多推箱子游戏软件都提供过程演示的功能，当玩家走投无路的时候，可以看看游戏给出的解答过程，这个过程其实就是游戏自己推算出来的最佳推箱子路线。

这一课我们就来试试用**穷举法**求解推箱子游戏。

#### 游戏介绍

图（1）展示了一个典型的推箱子游戏的截图，左边是游戏的初始状态，右边是游戏成功结束的状态。

游戏在一个二维平面“地图”上操作，游戏开始时有若干只箱子和与之数量相同的目的位置，玩家控制一个小人推动箱子到指定的位置，当全部箱子都被推到指定位置时，游戏就结束。箱子有四个面，玩家每次只能从一个面推动箱子向相反的方向移动。为了增加难度和趣味儿性，地图上一般都会布置一些障碍物阻挡箱子，使其不能被顺利地推到目的地。

![QQ截图20190605212607](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190605212607.png)

游戏中的地图实际上可以看作是由一个个小格子组成的，每个格子可以是墙、箱子或小人。

为了将重点放在算法上，我们对这个游戏做一个简化处理，用各种字符表示地图上的各种元素，比如用空格字符表示空地，用大写字母 'B' 表示箱子，用大写字母 'X' 表示障碍物和墙壁，用 '#' 表示箱子的目的地，用 '@' 表示小人，用 'O' 表示游戏区域之外的空间，这样图（1）例子中的地图就可以表示为如下形式：

![QQ截图20190605213708](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190605213708.png)

用这个简化模型，我们的演示程序就可以聚焦于算法本身，用简单的控制台字符界面展示算法的结果，不用考虑冗杂的图形界面处理。

根据我目前了解的资料，这个游戏的解算方法基本上都是基于穷举算法基础上的各种变形算法。

我们这一课介绍的算法也是基于穷举的思想，但是我们引入了 A* 寻路算法。

小人在移动的过程中，直接通过 A* 算法找出最短移动路径，避免了普通的穷举算法一个格子一个格子搜索造成大量没有意义的状态的问题，提高了搜索的效率。

同时，A* 算法还隐含了路径联通性判断，对于某一个箱子和小人之间不可到达的情况，自然地避免了无效的搜索。

关于 A* 算法我们将在本课程的第 6 部分详细介绍，这一课的重点还是穷举算法设计过程中的各种考量，比如数据模型怎么设计、代码实现的细节以及怎么能用人可以理解的方式输出结果。

顺便说一下，在穷举的过程中引入各种最短路径算法来提高穷举的效率并不是我的首创，我看很多论文里都提到了这种方法，但是没看到谁公开了类似的实现代码。

不过咱们国家那个论文也就是那样，我的感觉是每个写论文的人都只是想让你知道他很牛，他做出来了，但是其他人想通过论文也学会基本上是不可能的，毕竟篇幅啊、版面费什么的都是钱啊；老外的论文明显就是风格不一样，一点小事儿都会写得很清楚，一篇论文二三十页都是很正常的，总之，就是保证你看懂。嗯，我这算吐槽吗？算吧

#### 算法模型分析

为了标识每个物体（小人、箱子、障碍物等）在地图上的位置，需要为每个物体设置一个坐标，这也是地图类游戏惯用的方法。推箱子游戏是在一个二维平面中进行，小人和箱子一次只能移动一个小格子的距离，因此，只要以小格子为单位设置坐标系即可。我们将坐标系设置为 (row, col)，即用行和列来标识坐标。大多数人习惯将左上角标定为坐标原点 (0,0)，我也是。以图（1）和其对应的简化模型为例，如果左上角位置是坐标 (0,0)，则小人所在位置的坐标就是 (8,11)。确定了地图坐标的表示方式，我们就可以在此基础上继续其他数据模型的分析和设计了。

#### 地图的数据模型

分析一下游戏中的各种元素，其中的障碍物、目标点和空地的位置是不变的，箱子和小人的位置是变化的，**不变的部分我们将其设计为地图，变化的部分设计为游戏的状态**。

观察图（1）展示的地图元素，每个小格子需要用一个属性标识这个小格子的类型，比如是墙还是空地，或者是游戏区域之外的地方。空地类型的单元格表示箱子和小人可以通过，不会被阻挡。空地类型的格子还需要一个属性标识这个位置是否是目标位置，判断游戏是否成功结束的条件就是所有箱子所在位置的小格子是否具有目标位置属性。

玩过这个游戏的人都知道，地图上有一些位置是死亡点，绝对不能把箱子推到这些死亡点上。在死亡点上的箱子无法再被推动，或只能在有限的范围内移动，无法被推到正确的目标位置。推箱子游戏在检测到玩家把任何一个箱子推到死亡点上后，都会提示玩家已经无解了，需要结束游戏。

不同的地图死亡点也不一样，关于死亡点的判断我们后面再介绍，这里只需要知道，每个小格子还需要一个属性标识这个位置是不是死亡点。

我们定义数据结构 MapNode 来表达每个小格子对应的地图元素，它有三个属性，对应我们上面的描述内容。

对于地图的数据模型，如 CBoxGameMap 所示，为了便于理解算法，我们仍然用二维数组来表示地图（这不是最高效的方法，请大家了解，前面多次提到，这类问题通用的做法是用一个特殊构造的一维表来存储地图元素）。

```c++
struct MapNode
{
    char value; // X O ' '
    bool isDead; // 是否是死亡点
    bool isDest; // 是否是目标点
}；

class CBoxGameMap
{
    ......
    int m_rowCount;   //地图的实际行数
    int m_colCount;   //地图的实际行数
    MapNode m_map[MAX_MAP_ROW][MAX_MAP_COL];   //简化数据模型，使用定长的二维数组
    ......
};
```

#### 动作—为了输出结果考虑

推箱子游戏，当然重点是推的动作，但问题是如何对推这个动作建模？

这里就要用到信息数字化的技巧，将动作转化为能用数据结构描述的数字。

想一想推的动作，其实最终的结果是产生小人和箱子的位置变化，我们可以用位置变化来表达推的动作；

再进一步思考，位置的变化实际上就是坐标的变化，也就是坐标在两个方向上的变化量。

提到坐标的变化量是否想到了**“方向数组”**？

本课程的第一部分基础篇介绍过，迷宫类游戏在向四个方向搜索遍历时，常常会用“方向数组”。“方向数组”实际上就是用坐标的变化差值（位置偏移）来表示上、下、左、右四个方向，我们的动作也是四个方向，也可以用坐标差值来表示相应的动作。

比如偏移量 {-1,0} 表示在行坐标方向上移动 -1，在列坐标方向上移动 0，就可以表示这是一个向上移动的动作。偏移量数组 { { -1,0 }、{ 0,1 }、{ 1,0 }、{ 0,-1 } } 分别表示“上”、“右”、“下”和“左”四个方向的偏移，对这个数组遍历一遍，即可完成对某个位置四周的四个小格子的遍历。

小人必须在箱子边上的时候才能推箱子，所以小人先要移动自己到适当的位置，然后才能从一个方向推箱子。

在结果输出的时候，除了输出推动箱子的情况，还要加上小人的移动路线，这样才能使得演示程序更有趣味。

怎么用数据模型描述移动动作呢？直接建模很难，但是我们可以将移动动作转化成位置变化的过程，用小人在地图上位置变化的过程来表示它移动的动作。

位置变化的过程可以用一系列有序的地图坐标位置来表示，比如 { {8,11}、{8,10}、{8,9}、{7,9} } 这一系列坐标就表示小人从 {8,11} 位置开始向左移动两个格子，然后向上移动了一个格子，到达 {7,9} 这个位置。

最终，我们对动作的建模，包含了移动和动作两部分的数据结构定义：

```c++
struct Action
{
    std::vector<MapPos> path; //移动的过程
    int push_x;  //推的动作
    int push_y;  
};
```

#### 状态的数据模型

所有动态的数据都由状态数据来管理，包括小人的位置和所有箱子的位置。

为了增加结果输出的趣味性（便于人理解输出的结果），我们将产生当前状态的动作也记录为状态数据，除此之外，还需要记录前一个状态和当前状态的关系，即前一个状态经过 Action 动作产生了当前状态。

```c++
class GameState
{
    ......
    MapPos m_man;
    std::vector<MapPos> m_boxes;
    Action m_action;
    GameState *m_parent;
    ......
};
```

#### 无效状态和死点

穷举算法在搜索过程中产生的状态，很大一部分是不可能产生正确结果的无效状态，对这些无效状态的搜索降低了算法的效率。

如果能识别出无效状态，在搜索过程中及时做剪枝处理，则能有效地提升搜索的效率。对于推箱子游戏来说，地图上有一些位置被称为死点，一旦箱子被推到在这些位置上，要么不能再被推动，要么是永远也离不开某些位置。

死点位置的确定对自动求解游戏的算法而言，也是一个非常重要的信息，凭借死点的判断，可以在状态搜索的过程中，进行有效的剪枝处理，过滤掉很多无效状态。

图（2）中红色小方块和黄色小方块标记的位置就是死亡点，如何判定一个地图上的位置是不是死亡点呢？首先，如果一个位置相邻的两面都是墙，并且这个位置不是目标位置，则这个位置是一个死亡点。图（2）黄色小方块标记的位置，就是这种类型的死亡点。箱子被推到这些位置后，就无法再从其他方向推动了。

![QQ截图20190605215851](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190605215851.png)

除了位于角落里的死点，图（2）中红色小方块标记的点也是死点，这些点的一边是墙，箱子只能沿着墙推动，如果墙的边上没有目标位置，箱子无论如何也不可能被推到目标位置。根据以上分析，地图上符合以下两个特征的位置，就是死点：

1. 地图上相邻两边都是障碍物的死角位置，且该位置不是目标位置；
2. 位于墙边的点，并且这道墙边上所有位置都不是目标位置。

那么什么样的障碍物才算“墙”呢？首先，墙必须是连续的障碍物，其次，连续障碍物的两端必须是封闭的。第一条描述比较容易理解，那么第二条描述是什么意思呢？我们再来看看图（2），虽然图（2）所示的地图中间位置有很多连续的障碍物，但是其两端是开放的空位置，所以不能算是墙。只有红色小方块边上的连续障碍物，其两端要么是障碍物，要么是边界外，即两端都没有能将障碍物移动到远离墙的位置的空间，这就是所谓的两端都是封闭的意思所在。



#### 设计搜索算法

有了地图、动作和状态的数据模型定义之后，就可以根据数据模型确定搜索算法。

这个问题的状态空间仍然是树状的，搜索算法我们可以沿用广度优先搜索算法，对状态树进行遍历。

很多算法爱好者在实现这个游戏的算法时，都是从小人的位置开始，分别从上、下、左、右四个方向开始移动，如果移动方向上有箱子，则带着箱子一起移动；每移动一次就产生一个新的状态，记录这个状态，并在未来的某个时刻从这个新状态的位置继续搜索。

这种直接穷举方法的算法实现简单，但是小人在移动的过程中，有很多位置是对结果没有作用的无意义移动，类似于搜遍了整个地图才移动到箱子边上。

前面提到过，很多资料都介绍了利用 Dijkstra 算法或 A* 算法这样的寻找最短路径的算法辅助进行搜索，提高算法搜索的效率。

但是我并没有发现有谁公开了这样的实现方法，于是本课就来实现一个用 A* 算法辅助进行状态穷举搜索的算法实现。

本课程所强调的学习算法的目的之一就是能够设计适用于问题的数据模型，让经典的算法落地为能解决实际问题的具体的算法代码实现。这里就是一个应用经典的 A* 算法的例子，大家可以体会一下 A* 算法与实际应用结合的一个例子。

#### A* 算法的引入

不同于 Dijkstra 算法的静态搜索，A* 算法是一种启发式搜索算法，所谓的“启发”体现在搜索过程中使用一个计算目标和当前位置关系的启发函数帮助决策。

关于 A* 算法的原理我们将在图论部分详细介绍，这里先给出 A* 算法的一个应用实例。A* 算法的核心是 open 表和 close 表，open 表记录已经发现（出现在搜索视野中）但是还没有搜索的节点，close 表记录已经完成搜索的节点。这里的“节点”很抽象，我们要根据定义的地图数据模型，将“节点”落到实处。

在定义的地图模型中，每个小格子就是一个要搜索的节点，因此，对于这个问题来说，A* 算法所说的节点，就是地图上的一个小格子，根据我们的地图模型，用行和列的坐标来标识节点，相应地，这个算法的节点定义应该是：

```c++
struct ANODE
{
    ......
    int row;   //节点的行坐标
    int col;   //节点的列坐标
    double g;   //启发函数 g(x) 的值
    double h;   //启发函数 h(x) 的值
    int prev_row;  //搜索过程中前一个路径点的行坐标
    int prev_col;   //搜索过程中前一个路径点的列坐标
    ......
};
```

AStar 类就是根据本问题的数学模型落地实现的 A* 算法，如果从地图上的 from 位置到 to 位置之间没有被障碍物阻断，则 FindPath() 函数会返回从 from 到 to 之间的所有路径点，这个路径点的集合正是我们的动作 Action 数据模型中的 path，衔接得非常好。

这里的 FindPath() 函数固定使用了曼哈顿距离（ManhattanDistance()）作为启发函数中的 h(x) 函数，实际上 h(x) 函数是可以替换的。

```c++
class AStar
{
public:
    AStar(BoxGameMap *map, GameState *state);
    ~AStar();

    bool FindPath(const MapPos& from, const MapPos& to, std::vector<MapPos>& path);
protected:
    bool ExtractMiniFromOpen(ANODE& node);
    bool IsNodeExistInClose(int row, int col);
    bool IsEmpty(int row, int col);
    void GetPath(std::vector<MapPos>& path);

protected:
    BoxGameMap *m_map;
    GameState *m_state;
    std::multiset<ANODE, compare> m_open;
    std::vector<ANODE> m_close;
};
```

#### 死点的判断算法

对死点判断的算法实现，是这个游戏算法中最有意思的一个地方，当然，也是我在具体实现的时候花费时间最多的地方，超过了设计递归搜索主题代码的时间。

判断算法的主体仍然是判断死角位置和墙边位置，下面我们结合代码实现来介绍算法的实现。IsDeadPos() 函数判断坐标位置 [row,col] 所在的地方是不是一个死点，具体方法就是搜索 [row,col] 所在位置的上、下、左、右四个方向，看看它们是不是障碍物，如果是就继续判断它们是否和其他障碍物组成了死角或组成了墙。dirs 是方向数组，老技巧了，这里不说了。

因为我们要判断连续的两个方向上是不是障碍物，所以用变量 isCorner 辅助判断 [row,col] 是不是死角位置。isCorner 的意义就是表示前一个位置是不是障碍物，当 [row,col] 位置的一面是障碍物的时候，就设置这个标志的值为 true，如果转一个角度（90°）的位置还是障碍物，则说明这是个死角位置，只要这个位置不是目标位置，IsDeadPos() 函数直接返回 true 表示这是个死点；如果转一个角度（90°）的位置是自由空间，则清除这个标志的值。当 dir.col_offset 的值是 0 的时候，说明方向偏移是在上和下两个方向，需要判断行（水平）方向上是不是墙；反之，则说明方向偏移是在左和右两个方向，需要判断列（垂直）方向上是不是墙。

```c++
bool BoxGameMap::IsDeadPos(int row, int col)
{
    Direction dirs[] = { { -1, 0 },{ 0, 1 },{ 1, 0 },{ 0, -1 } };
    bool isCorner = false;
    for (auto& dir : dirs)
    {
        MapPos newPos = { row + dir.row_offset, col + dir.col_offset };

        if (m_map[newPos.row][newPos.col].value == MAP_V_BOARD)
        {
            if (isCorner)
            {
                return true; //已经连续两个方向是墙了，说明是个 corner
            }

            isCorner = true;
            if (dir.col_offset == 0) //沿行方向找墙
            {
                int col_s, col_e;
                if (GetRowWall(newPos.row, newPos.col, col_s, col_e))
                {
                    if (!IsRowHasDestPos(row, col_s, col_e))
                        return true;
                }
            }
            else //否则沿着列方向找墙
            {
                int row_s, row_e;
                if (GetColWall(newPos.row, newPos.col, row_s, row_e))
                {
                    if (!IsColHasDestPos(col, row_s, row_e))
                        return true;
                }
            }

        }
        else
        {
            isCorner = false; //这个方向不是墙，将标记清除
        }
    }

    return false;
}
```

对墙的判断就是从当前位置，沿着行或列的方向向前和向后搜索，看看是否能找到开放位置，如果找不到开放位置，就返回 true，证明从这个位置开始的行或列存在墙。我们以水平方向的判断实现代码为例，看看是如何沿着水平方向搜索开放点的。首先从 col 位置开始，向前搜索墙的起点 cs，一直找到地图中这一行的最左边位置，如果在这个过程中找到开放位置，就直接返回 false；如果向前搜索没有找到开放位置，那么就继续向后搜索墙的终点 ce，同样，如果找到了开放点，也是直接返回 false，说明这不是一道墙。如果向前和向后都没有找到开放位置，则说明这是一段封闭的墙，返回 cs 和 ce 作为墙的起点位置和终点位置。

```c++
bool BoxGameMap::GetRowWall(int row, int col, int& cs, int& ce)
{
    cs = col;
    while (m_map[row][cs].value == MAP_V_BOARD)
    {
        if (cs == 0)
            break;

        cs--;
    }
    if ((cs > 0) && (m_map[row][cs].value != MAP_V_OUT))
        return false;

    ce = col;
    while (m_map[row][cs].value == MAP_V_BOARD)
    {
        if (ce == (m_colCount - 1))
            break;

        ce++;
    }

    if ((ce < (m_colCount - 1)) && (m_map[row][cs].value != MAP_V_OUT))
        return false;

    return true;
}
```

接下来就是沿着刚才找到的墙的起始位置，在墙的边上看看从 cs 开始到 ce 为止的位置是否有目标位置，如果没有目标位置，则说明这就是个死点了：

```
bool BoxGameMap::IsRowHasDestPos(int row, int cs, int ce)
{
    for (int col = cs; col <= ce; col++)
    {
        if (m_map[row][col].isDest)
            return true;
    }

    return false;
}
```

#### 目标状态的判断

显然，当所有的目标点上都有箱子的状态时就是我们穷举的目标状态，每次出现目标状态，就应该输出一个结果。

判断的算法实现就是遍历当前 GameState 对象实例中所有的箱子位置，然后看看对应箱子位置在地图对象中的位置是否具有目标点属性：

```c++
bool BoxGame::IsFinalState(const GameState *state)
{
    for (int i = 0; i < state->GetBoxCount(); i++)
    {
        MapPos box = state->GetBox(i);
        MapNode node = m_map->Get(box.row, box.col);
        if (!node.isDest) //只要有一个箱子不在目标位置上，就返回 false
            return false;
    }

    return true;
}
```

#### 搜索算法主体实现

搜索算法采用广度优先搜索算法，搜索过的所有状态都是按照搜索的顺序保存在 `m_states` 数组中，状态之间通过 `m_parent` 属性建立父子关系，当找到一个目标状态时，通过其 `m_parent` 可以找到它的父状态，递归遍历，可以一直追溯到其初始状态。`m_states` 数组的存储状态如图（3）所示：

![QQ截图20190605220752](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190605220752.png)

搜索开始时，只有一个初始状态，随着搜索算法的展开，这个数组逐渐增加状态。我们用 index 变量标识当前正在搜索的状态，index 之前的状态都是已经搜索过的状态。ResolveGame() 函数中的 while 循环实现对状态数组的遍历，index 表示从前向后搜索的位置；IsFinalState() 判断当前状态是否是结果状态，如果是结果状态，则开始输出一个结果，否则就调用 SearchNewGameStates() 函数对这个状态进行搜索。

```c++
bool BoxGame::ResolveGame()
{
    int index = 0;
    while (index < static_cast<int>(m_states.size()))
    {
        GameState *state = m_states[index];
        if (IsFinalState(state))
        {
            m_result++;
            PrintMoveRecords(state);
        }
        else
        {
            SearchNewGameStates(state);
        }

        index++;
    }

    return (m_result > 0);
}
```

推箱子首先要让小人移动到箱子边上，所以先要找到每个箱子，然后检查箱子周围是否有空位置，如果有就用 A* 算法找出移动到这里的最短路径，如果没有路径，说明小人不能直接移动到这个位置，那么这个位置也就不用处理了。

最外层的 for 循环遍历每一个箱子，内层 for 循环是方向数组循环，遍历箱子周围的四个位置。找到一个符合条件的位置，就调用 MoveToNewState() 函数尝试推动箱子，并产生新的状态。

```c++
void BoxGame::SearchNewGameStates(GameState *state)
{
    Direction dirs[] = { { -1, 0 },{ 0, 1 },{ 1, 0 },{ 0, -1 } };

    for (int i = 0; i < state->GetBoxCount(); i++)
    {
        //检查每一个箱子周围四个方向是否有空位置，可以将小人移动过来
        MapPos box = state->GetBox(i);
        for (auto& dir : dirs)
        {
            MapPos newMan = { box.row + dir.row_offset, box.col + dir.col_offset };
            //只要不是墙或箱子，就尝试能否将小人移动到箱子边上
            if (!m_map->IsWall(newMan.row, newMan.col) && !state->IsBox(newMan.row, newMan.col))
            {
                AStar astar(m_map, state);
                std::vector<MapPos> path;
                if (astar.FindPath(state->GetMan(), newMan, path)) //有路径可以到这个地方
                {
                    //推的方向是小人的与箱子位置的反方向
                    Direction push = { -dir.row_offset, -dir.col_offset };
                    MoveToNewState(state, newMan, path, push);//尝试在这个位置推箱子
                }
            }
        }
    }
}
```

MoveToNewState() 首先判断能否推动箱子，如果能推动箱子的话就生成一个新状态，记录推动箱子后的情况，并判断这个状态是否是状态数组 `m_states` 中已经存在的状态，如果此状态为 `m_states`数组中不存在的新状态，就将这个新状态添加到 `m_states` 数组中。CanPushBox() 和 AddNewState() 的实现很简单，这里就不列举代码了，读者可以在完整的代码中找到它们。

以上就是推箱子游戏的穷举搜索算法的主体部分，看起来神秘的推箱子游戏其实很简单吧。这一课的重点还是数据模型的设计，我们使用了平面地图类游戏惯用的小格子和二维坐标来建模，并利用这个模型改编了一个 A* 算法的实现。对 A* 算法的使用大家关注一下我们是如何改造这个算法的，使其与推箱子游戏的数据模型愉快地玩耍的方法即可，以后还会重点介绍这个算法的原理的。

#### 总结

这一课我们介绍了穷举法解决推箱子游戏的问题，搜索的策略是广度优先搜索策略，算法还结合了 A* 算法判断小人每次移动的最短路径。总体上，对于地图规模小于 10 X 10 格子的游戏，都能在 5 秒内给出结果，但是对于超过这个规模的游戏，穷举法的劣势就很明显了，比如图（1）所示的游戏地图（11 X 13），我们的算法搜索到大约 380000 个状态的时候才输出了第一组解。

好了，我们的作业题来了，目前给出的算法代码只是实现了穷举搜索，每找到一个解就输出一个解，我们的课后作业就是请你在算法的基础上实现最优解的输出，即只输出最优的一个解就可以了。我们对最优解的定义很简单，即整个动作序列的状态数最少的那个就是最优解。



### 3-10 浮点数和大数

#### 整数的范围

“玩”算法，对各种类型的“数”能表达的数据范围要心里有数。

- 8 位有符号整数能表示的范围是 −128 到 127，无符号时能表示的范围是 0 ~ 255。
- 16 位的有符号整数能表示的范围是 −32768 到 32767，无符号时能表示的范围是 0 ~ 65535。
- 32 位的有符号整数能表示的范围是 −2,147,483,648 到 2,147,483,647，无符号时能表示的范围是 0 ~ 4,294,967,295。
- 64 位的有符号整数能表示的范围是 −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807，无符号时能表示的范围是 0 ~ 18,446,744,073,709,551,615。

什么叫心里有数？32 位整数最大能表示大概 42 亿多一点，如果算法要表示某地的人口数，设计数据模型时用 32 位整数也就够了，但是要表示全球人数就不行了。

一光年大约 9,460,730,472,580,800 米，从地球到仙女座星系的距离是 254 万光年，已经超出了 64 位整数能表达的范围。我们在设计数据结构的时候，要对问题的规模做到心中有“数”，不要用错数据类型。

#### 大整数库

超过 64 位的超级大数怎么办？如果你要解决的问题需要这么大范围的数，可以考虑使用**大整数**。

Python、Lisp 等语言都内建了大数计算机制，Java 也有 BigInteger 和 BigDecimal 分别用于大整数和大实数的计算。

然而，C/C++ 没有内建的机制或类型支持大数计算，但是 C/C++ 有很多高性能的第三方大数库可供选择。

GMP 开源大数库是一个任意精度的大整数运算库，它包括了任意精度的整数、浮点数的各种基本运算操作。它是一个 C 语言的库，但是官方提供了 C++ 的包装类，根据其官方的资料宣称，GMP 是目前地球上速度最快的大数库。

Miracl 库是 Shamus Software Ltd 开发的一个大数库，它的使用许可针对教育科学研究或者非商业目的应用是免费的。

它是一个 C 语言的库，同时提供了几个较为简单的 C++ 包装类。在功能上它不但提供了高精度的大整数和分数的各种数学运算操作，而且还提供了很多密码学算法中的功能模块，如 SHA、AES、DSA 等中的一些底层操作，据说局部算法使用了汇编代码实现，所以速度应该还是不错的。

除了专用的大数库，很多密码学软件中也会包含大数计算相关的内容，比如开源的密码学计算库 Crypto++ 中就包含了整套的大数计算库，OpenSSL 中也有对大整数计算的支持。



#### 自己设计大整数

OJ 上我遇到过这类题目，还好只是要实现一个大数加法。

设计大整数常用两种数据存储方式，一种是字符串方式，如 46744073709551615，每一个字符就是十进制数字的一个位；字符串方式的优点是简单、直观，缺点当然是计算时的效率不高，特别是乘法和除法的计算，另外，字符串方式的另一个缺点是占用存储空间比较大，四个字节的字符串最大只能表示到 9999。

设计大整数的另一种存储方式是采用 “2^n 进制数”的形式表示大数，对于不支持 64 位整数的系统，可采用 2^16 进制，用一个 16 位整数表示大数的一个位，这样每个位的有效数字是 0 ~ 0xFFFF，可以对比十进制整数一个位的有效数字 0 ~ 9 来理解，超过了 0xFFFF 就需要进位。

在数据结构存储时，可以采用 16 位无符号整数的数组来存储大数的每个位，假如某个用 2^16 进制表示的大数数组末两个元素是：

```c++
0xFFFF     0xFFFF
```

可以理解为是 2^16进制数的“99”，如果给它再加 1，就会产生进位，得到 2^16 进大数“100”：

```c++
              FFFF        FFFF
+                            1
--------------------------------
=       1        0           0
```

为什么选用 2^16进制，而不是直接用 2^32进制呢？是因为计算会溢出，用 32 位整数临时存储两个 2^16 进制数位的计算不会溢出（乘法最终也是转化成加法实现的）。如果系统支持 64 位整数，就可以直接用 2^32 进制表示大数。

大整数的加法是最简单的算法，下面我们用 2^32 进制大数为例，演示一下大数加法算法实现（只考虑同号相加，异号相加可以调整为减法实现），我们的大数数据模型定义为：

```c++
#define MAX_BI_LEN 256

typedef struct
{
    unsigned int length; // 大数在2^32进制下的数字位数
    unsigned int value[MAX_BI_LEN]; // 大数每一位的值
}BigInt;
```

这个数据结构定义没啥好说的，看注释就好了。

加法算法实现首先将其中一个加数赋值给 result，并将 result 的位数先调整为两个加数中位数最长的那个值，然后开始按位加，并用 carry 记录进位。

两个 32 位整数相加，存入 64 位的中间数 sum，sum 的低 32 位是两个加数位的和，高 32 位中如果有溢出就是进位。carry 初始时是 0，保证第一次加法计算时不会多加。

最后循环完成各位相加后，如果 carry 不是 0，说明当前最高为相加又产生进位了，需要将结果也调整增加一位。

```c++
void BigIntAdd(const BigInt& value1, const BigInt& value2, BigInt& result)
{
    BigInt result = value1;
    
    unsigned int carry = 0;
    
    // 先调整位数对齐
    if(result.length < value2.length)
    {
        result.length = value2.length;
    }
    
    for(unsigned int i = 0;i<result.length;i++)
    {
        unsigned __int64 sum = value2.value[i];
        sum = sum + result.value[i] + carry;
        result.value[i] = (unsigned long)sum;
        carry = (unsigned)(sum >> 32);
    }
    
    // 处理最高位，如果当前最高位进位 carry!=0，则需要增加大数的位数
    if(carry!=0)
    {
        result.value[result.length] = carry;
        result.length += 1;
    }
}
```

是不是很简单？ play_with_algo 中有一个 CBigInt 类，用的就是 2^32 进制大数的形式，支持简单的加、减、乘、除运算，加、减、乘、除运算都是参考《编译原理》书中介绍的加法器、减法器、乘法器和除法器的原理实现的，效率不是很高，但是还可以一用。用于高性能计算就算了，通过其实现代码了解一下大数计算的原理还是可以的。



#### 浮点数的精度

IEEE 定义了多种浮点数的二进制表示形式，

以 IEEE 754 标准为例，单精度浮点数（float）用 32 位二进制位表示，其中 31 位是符号位，23 ~ 30 共 8 个比特位表示指数，0 ~ 22 共 23 个比特位表示有效数字。

双精度浮点数（double）用 64 位二进制表示，其中最高为 63 位是符号位，52 ~ 62 共 11 个比特位表示指数位，0~ 51 共 52 个比特位表示有效数字。

IEEE 还定义了用 80 个比特位表示的扩展双精度类型，不过大家用的机会不多，这里就不介绍了。

根据双精度浮点数的定义，其能表示的数的正数范围大概是 1.7E−308 〜 1.7E + 308（负数范围类似），既然这么大，那表示 254 万光年是否绰绰有余？当然，从数的范围来讲，确实是绰绰有余，但是考虑到精度，用双精度浮点数承载天文计算就还差点儿火候。双精度浮点数有 52 个比特位表示有效数字，换算成十进制的话也就是大约 16 个十进制位的有效数字，这个精度用作科学计算显然有点尴尬，科学计算，还得靠大数库。

为什么很多数都强调用 double，尽量不用 float？也是这个原因，float 类型的浮点数有效数字只有 23 个比特，换算成十进制差不多 7~8 个有效数位，精度实在是太低了。



#### 浮点数的误差

浮点数的误差其实也是由精度引起的，以双精度浮点数为例，按照十进制方式其有效数字大约 16 位，换句话说，超过 16 位的小数用双精度数是区分不出来的。所以你要知道，这两个数计算机是区分不出来的，在计算机来看，它们两个是相等的：

```c++
    double aaaa = 0.1234567890123456789;
    double bbbb = 0.123456789012345678;
```

除了超出精度范围的数之外，在精度范围内的数也会存在误差，这个误差的主要原因是用二进制小数表示十进制小数时存在转换误差，看看下面的代码，你以为它们在内存中的值是什么？

```c++
	double first = 0.3;
    double second = 0.4;

    double sum = first + second;
```

![QQ截图20190605232715](D:\usegit\github\algorithmcompetition\28训练营学习笔记\picture\QQ截图20190605232715.png)

是不是和想象中的不一样？我们来看看 0.3 怎么转化为二进制，转化方法就是不停地乘 2，有进位到 1 了就去掉 1，并将对应的位设置为 1，如果没有进位，就将对应的位设置为 0。来看看这个过程：

```c++
0.3 X 2 = 0.6                              0

0.6 X 2 = 1.2                              1

0.2 X 2 = 0.4                              0

0.4 X 2 = 0.8                              0

0.8 X 2 = 1.6                              1        //0.6 又出现了
```

可以看到 1001 会重复出现，无限循环，最后的结果是 0.0100110011001…，直到超出浮点数的有效位数。这就是我说的二进制小数不能精确表达十进制小数的原因。并不是所有的十进制小数都不能用二进制小数精确表达，那么什么样的值能精确表达呢，就是那些能用 1/2、1/4、1/8、1/16……准确累加的值，比如 0.5、0.75（1/2 + 1/4）或 0.625（1/2 + 1/8）这类的小数。

再来看看下面的代码，你以为结果如何：

```c++
double r1 = 16.1 * 100 + 0.9 * 100;
    double r2 = 17.0 * 100;
    if (r1 == r2)
    {
        std::cout << "16.1 * 100 + 0.9 * 100 == 17.0 * 100" << std::endl;
    }
```

实际上我们期望的那个输出打印并没有出现，因为 r1 不等于 r2 ！真实情况是 r1 = 1700.0000000000002、r2 = 1700.0000000000000。还是同样的道理，这就是我在课程中一直强调不要用浮点数判断相等的原因，大多数情况浮点数比较都没有太大问题，但是总有你想不到的那个情况出现，为了不给自己找麻烦，最好不要直接用浮点数直接判等，当然，直接判断不等于也尽量避免。那怎么判断两个浮点数相等呢？基础部分内容中有答案。

只要涉及用计算机表示数，都不要想当然，了解一点整数和浮点数与二进制存储方式之间的原理，有助于减少困惑和对着代码排除错误的时间，最后：

“世界上有 10 种人，一种是懂二进制的，一种是不懂二进制的。”



