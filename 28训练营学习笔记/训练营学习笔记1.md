### 训练营学习笔记1

### 3-3 狼、羊、菜和农夫过河问题

农夫需要把狼、羊、菜和自己运到河对岸去（不知道为啥要运狼，别问我），只有农夫能够划船，而且船比较小，除农夫之外每次只能运一种东西，还有一个棘手的问题，就是如果没有农夫看着，羊会偷吃菜，狼会吃羊。请考虑一种方法，让农夫能够安全地安排这些东西和他自己过河。

#### 算法设计思路

这是一个很简单的问题，在狼、羊和菜这个食物链上，关键是中间的羊，因为狼不吃菜，所以要安全过河，农夫的第一件事就是带羊走，拆开这个食物链。

但是计算机无法理解这个关键的羊，所以我们仍然采用穷举法来解决这个问题，同时借助于穷举搜索找出所有过河的方法。

这个题目的解决思路和“三个水桶倒水”问题的解决思路类似，就是对状态进行穷举搜索，从初始状态开始穷举所有的状态变化，直到某一次变化后得到问题解决的最终状态，就输出一个结果。

前面的几课中已经多次提到穷举法的两个关键步骤，这里不再列出。接下来就直接从这两个步骤入手，介绍如何设计这个问题的穷举算法。

#### 定义问题的状态

在确定以何种方法对解空间进行穷举搜索之前，首先要定义问题的解。

虽然这个题目的要求是给出农夫带着他的小伙伴过河的动作，但是单纯考虑对动作的穷举是没有意义的，因为问题最后的解决状态是农夫、狼、羊和菜过到河对岸，能最终产生这种状态的动作才有意义，为了判断动作的有效性，需要定义一个合适的状态来描述这个游戏在某个时刻的局面。

考虑一下这个题目涉及的所有元素：农夫、狼、羊、菜、船和河，河是固定的，没有状态变化，因为只有农夫可以划船，所以船可以看作和农夫是一体的，简化后其实有 4 个元素需要考虑，分别是农夫、狼、羊和菜。

如图（1）所示的一种过河的过程，状态的定义只要能表达农夫、狼、羊和菜的位置关系即可。在确定以何种方法对解空间进行穷举搜索之前，首先要定义问题的解。虽然这个题目的要求是给出农夫带着他的小伙伴过河的动作，但是单纯考虑对动作的穷举是没有意义的，因为问题最后的解决状态是农夫、狼、羊和菜过到河对岸，能最终产生这种状态的动作才有意义，为了判断动作的有效性，需要定义一个合适的状态来描述这个游戏在某个时刻的局面。考虑一下这个题目涉及的所有元素：农夫、狼、羊、菜、船和河，河是固定的，没有状态变化，因为只有农夫可以划船，所以船可以看作和农夫是一体的，简化后其实有 4 个元素需要考虑，分别是农夫、狼、羊和菜。如图（1）所示的一种过河的过程，状态的定义只要能表达农夫、狼、羊和菜的位置关系即可。

![avatar](https://github.com/lihuaweishiyigehaoren/algorithmcompetition/blob/master/28%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/picture/QQ%E6%88%AA%E5%9B%BE20190602224622.png?raw=true)

从图（1）可以看出来，状态(a)到(h)变化的其实就是这 4 个元素的位置，每个元素的位置只有两个状态，即在河的左岸和在河的右岸；

问题的初始状态是农夫、狼、羊和菜都在河的左岸，得到解的终止状态是农夫、狼、羊和菜都在河的右岸。

我们用一个四元组来表示四个元素的位置状态，那么初始状态为 [Left,Left,Left,Left]，最终的结果状态为 [Right,Right,Right,Right]。

#### 状态树和解空间

和“三个水桶等分 8 升水”问题一样，对所有状态穷举搜索的结果也是一棵状态树，根节点是初始状态，叶子节点就是解决问题的状态。

这个题目由于限制条件比较特殊，只有农夫可以划船，一次只能带一个小伙伴，同时狼、羊和菜又不能愉快地在一起玩耍，所以状态树上很多状态都是非法状态，客观上起到了很好的剪枝效果。

如图（2）所示的状态树中，蓝色的状态表示此状态已经和之前的状态重复，红色的状态表示这是一个非法状态，不是出现狼吃羊的情况，就是出现羊吃菜的情况。绿色状态是搜索到了结果状态，这是状态树的叶子节点。

![QQ截图20190602225418](.\QQ截图20190602225418.png)

状态树上绿色的节点是要搜索的结果状态，从结果状态到根节点之间的状态序列，就是问题解决的过程，有多个绿色的节点表示有多个解决问题的过程。

根据题目的意图，最终的结果是要输出这条转换路径的过河过程，实际上就是与状态转换路径相对应的动作路径，或动作列表。当定义了动作的数学模型后，就可以根据状态图中状态转换路径找到对应的动作列表，依次输出这个路径上每个状态对应的动作就可以得到一个完整的过河过程。

#### 状态的数据模型

根据之前对状态的定义，状态的数据模型就是农夫、狼、羊和菜的位置，位置定义 LOCATION 就是两个状态，LOCATION::LEFT 表示对应的元素在河的左岸，LOCATION::RIGHT 表示对应元素在河的右岸（就是过河状态）。

```c++
struct ItemState
{
    ……
    LOCATION farmer,wolf,sheep,vegetable; // 四个元素的位置
    ACTION curAction; // 此状态对应的动作
}
```

curAction 是当前状态绑定的过河动作，即前一个状态通过这个过河动作转变成当前状态。

记录状态对应的过河动作的目的是能够在输出结果时，按照状态演变序列的顺序输出过河动作。



#### 过河动作的数据模型

两个静态的位置状态是通过过河动作建立关联的，分析这个题目，我们注意到，狼、羊和菜是不会自己过河的，因为只有农夫会划船。

农夫可以自己过河，也可以带一个物品过河，当然，从河对岸返回时也是一样的情况。由此可见，本问题的过河动作其实只有 8 个固定动作，分别是：

- (1)农夫自己过河
- (2)农夫带狼过河
- (3)农夫带羊过河
- (4)农夫带菜过河
- (5)农夫自己返回
- (6)农夫带狼返回
- (7)农夫带羊返回
- (8)农夫带菜返回

把一个状态与以上动作结合，就可以转化得到一个新状态，但是需要注意的是，并不是所有的动作都适用于对应的状态，比如对于农夫在河的左岸的状态，动作（5）~（8）代表的返回动作就都不适用。

同样，对于一个菜已经在河对岸的状态，动作（4）就不适用。

在搜索过程中对过河动作遍历的时候，要根据这些情况合理地剪掉一些分支。

根据以上描述，过河动作 ACTION 定义如下：

```c++
num class ACTION
{
    GO_SELF,
    GO_WITH_WOLF,
    GO_WITH_SHEEP,
    GO_WITH_VEGETABLE,
    BACK_SELF,
    BACK_WITH_WOLF,
    BACK_WITH_SHEEP,
    BACK_WITH_VEGETABLE,
};
```

##### 设计搜索算法

我们讨论的状态都是静止的，如果不是有过河动作作用到状态上，状态是不会发生变化的。

对状态树的搜索，其实就是把 8 个过河动作依次与状态结合，演变为新的状态的过程。

与“三个水桶等分 8 升水”问题一样，本题的搜索算法依然采用深度优先遍历，从初始状态节点开始，一直搜索到合法状态为止，在这个过程中，需要记录已经搜索过的状态，避免出现重复状态导致算法进入死循环。

```c++
struct ActionProcess
{
    ACTION  act_name;
    std::function<bool(const ItemState& current, ItemState& next)>  TakeAction;
};

ActionProcess actMap[] = 
{
    { ACTION::GO_SELF,                ProcessFarmerGo                },
    { ACTION::GO_WITH_WOLF,           ProcessFarmerGoTakeWolf        },
    { ACTION::GO_WITH_SHEEP,          ProcessFarmerGoTakeSheep       },
    { ACTION::GO_WITH_VEGETABLE,      ProcessFarmerGoTakeVegetable   },
    { ACTION::BACK_SELF,              ProcessFarmerBack              },
    { ACTION::BACK_WITH_WOLF,         ProcessFarmerBackTakeWolf      },
    { ACTION::BACK_WITH_SHEEP,        ProcessFarmerBackTakeSheep     },
    { ACTION::BACK_WITH_VEGETABLE,    ProcessFarmerBackTakeVegetable }
};
```

每个处理逻辑需要做三件事情，首先要判断当前状态是否适用于对应的动作，接着根据对状态进行相应的改变并将对应的动作记录到新状态中，最后判断转化后的状态是不是一个合法的状态。

仍然以`ACTION::GO_WITH_VEGETABLE`动作为例，其处理逻辑 ProcessFarmerGoTakeVegetable() 的实现如下：

```c++
bool ProcessFarmerGoTakeVegetable(const ItemState& current,ItemState& next)
{
    if((current.farmer != LOCATION::LEFT) || (current.vegetable != LOCATION::LEFT))
        return false;
    next = current;
    
    next.farmer = LOCATION::RIGHT;
    next.vegetable = LOCATION::RIGHT;
    next.curAction = ACTION::GO_WITH_VEGETABLE;
    
    return IsCurrentStateValid(next);
}
```

对 8 个动作循环一遍，即可完成对一个状态的遍历，并根据情况生成新的状态，所以，遍历的动作就是对 actMap 做一个循环，依次调用每个动作对应的 TakeAction 逻辑。

遍历代码的主体大致是这样的：

```c++
ItemState next;
for(auto& act : actMap)
{
    if(act.TakeAction(current,next))
    {
        .....
    }
}
```

#### 剪枝和优化（重复状态和非法状态判断）

根据图（2）显示的状态树，需要剪枝处理的情况有两种，一种是非法状态，另一种是重复的状态。

对非法状态的过滤，体现在过河动作对应的处理逻辑中，ProcessFarmerGoTakeVegetable() 函数中最后调用 IsCurrentStateValid() 判断这个状态是不是合法状态。

对于产生非法状态的情况，ProcessFarmerGoTakeVegetable() 函数返回 false，遍历循环就跳过这个动作，继续遍历下一个动作。

对重复状态的过滤，是在 TakeAction 逻辑返回 true 的情况下才进行的，如下代码所示，两个 if 判断就是对上述两种情况的剪枝处理。

```c++
if(act.TakeAction(current, next))
{
    if(!IsProcessedState(states, next))
    {
        ......
    }
}
```

#### 代码实现

#### 搜索算法代码

SearchState() 函数实现状态树的搜索遍历，整体结构和“三个水桶等分 8 升水”问题类似，由两部分内容组成：

第一部分的 IsFinalState() 函数判断当前状态序列中最后一个状态是不是最终结果状态，如果是就输出一组状态序列（以及对应的过河动作）；

如果当前状态序列中最后一个状态不是结果状态，则转入第二部分开始搜索新的状态。

```
void SearchStates(deque<ItemState>& states)
{
    ItemState current = states.back(); /*每次都从当前状态开始*/
    if(current.IsFinalState())
    {
        PrintResult(states);
        return;
    }

    ItemState next;
    for (auto& act : actMap)
    {
        if(act.TakeAction(current, next))
        {
            if(!IsProcessedState(states, next))
            {
              states.push_back(next);
              SearchStates(states);
              states.pop_back();
            }
        }
    }
}
```

#### 判断非法动作和重复状态

如果农夫不在场，狼会吃羊，羊会吃菜，根据这个描述，无法直接写出代码，把这句话换一种说法，则会更容易转化成代码实现：

- 如果狼和羊位置相同，并且农夫的位置与它们不同，则是非法状态；
- 如果羊和菜位置相同，并且农夫的位置与它们不同，则是非法状态；
- 其他情况均为合法状态。

这样一来，这个判断函数就比较容易用代码描述了：

```c++
bool IsCurrentStateValid(const ItemState& current)
{
    if ((current.wolf == current.sheep) && (current.sheep != current.farmer))
    {
        return false;
    }

    if ((current.vegetable == current.sheep) && (current.sheep != current.farmer))
    {
        return false;
    }

    return true;
}
```

重复状态的判断更简单，就是对状态队列进行一次查找操作：

```c++
bool IsProcessedState(deque<ItemState>& states, const ItemState& newState)
{
    auto it = find_if( states.begin(), states.end(),
        [&newState](ItemState& item) { return item.IsSameState(newState); });

    return (it != states.end());
}
```

### 3-4 24点计算器

24 点游戏是一个很有意思的数字游戏，也是一道常见的算法面试题。

题目是这样的：任给四个数（为了便于人们心算或口算，一般都是小于 10 的数），对四个数字用各种组合进行加、减、乘、除四则运算，看看结果是否能等于 24？

对于面试题来说，这是一个典型的穷举类型算法问题。

这个题目比较有意思的地方是它除了要对数字组合进行枚举，还要对四个运算符进行组合。

这一课我们要介绍的方法有点特殊，它没有简单地使用穷举遍历，而是采用穷举法和分治法相结合的方法来解决这个问题，这种方法比数字 + 运算符一起枚举的方法简单，容易理解，整个算法只有大约 40 行有效代码，其中主体部分有效代码只有不到 20 行，快来看看是怎么回事儿吧。

#### 问题分析与建模

这个算法问题的难点主要有两个，

一个是数字和运算符的穷举遍历，另一个是将四则运算表达式作为结果输出。

无论是运算符遍历还是表达式输出，都要考虑运算符的优先级，必要时要加括号。

当然，也可以采用后缀表达式的形式，避免在枚举遍历的过程中考虑括号的问题。一般我们书写和计算都采用中缀表达式，中缀表达式的特点是运算符始终位于两个操作数的中间，对于运算符的优先级采用括号的方式解决，比如以下四则运算采用的就是中缀表达式的形式：

7 + ( 3 + 2 ) × 4 − 8

后缀表达式又称为“逆波兰表达式”，上述中缀表达式转换成后缀表达式后就是这个样子：

732 + 4 × + 8 −

后缀表达式通过运算符的位置来决定计算顺序，避免使用括号，便于计算机计算处理。

后缀表达式的求解计算一般用栈比较方便，具体的方法就是从左向右扫描表达式，当遇到操作数时就将操作数入栈；

当遇到操作符时就从栈中弹出两个操作数，将操作数与这个运算符一起计算得到一个结果，并将这个结果入栈，然后继续扫描表达式，直到结束。

后缀表达式的计算以及将中缀表达式转变成后缀表达式也都是经典数据结构课程的算法，这一课我们就不具体介绍了。大家如果感兴趣可以在读者圈中留言，我们后面可以安排补充一篇关于后缀表达式的内容。

引言部分提到过，我们这个方法会用到分治法，分治法的主要特点之一就是通过分解子问题的方式减小问题的规模，怎么划分子问题呢？

复习一下前面讲过的内容，子问题和原始问题必须是同构的，所谓同构就是问题必须是一样的，问题的模式不能变，能变的只是问题的规模。

对于这个问题来说，原始问题的规模是 4 个数字计算 24 点，那么分解子问题可以从两个方向考虑：

一种是只考虑减少问题的规模，对于这个问题来说，减少规模不就是变成 3 个数字计算 24 点吗？然后再减少为两个数字计算 24 点，以此类推，直到问题能够直接求解为止；

另一种是在减少问题规模的同时，调整结果的范围，同样，对这个问题来说，假如说我将问题规模从 4 个变成 3 个，被排除的数字是 3，那么子问题就应该变成“3 个数字计算 21 点”。进一步将问题规模减少成两个数字时，假如被排除的数字是 7，则子问题就变成“2 个数字计算 14 点”，以此类推，直到问题能直接解决为止。

本课我们尝试采用第一种方法来分解子问题。我们的思路是每次从 4 个数字中任选两个，分别应用加、减、乘、除四种运算方法得到 4 个计算结果，每个计算结果与剩下的 2 个数字一起组成一个规模为 3 个数字的子问题，一共可以得到 4 个子问题，其变化过程如图（1）所示（图中第一行的数字为 4 个数字的索引位置，第二行的数字分别是 4 个待计算数字，第三行是计算过程），使用第一个数字和第二个数字组合计算，得到了一组 4 个子问题，然后用第一个数字和第三个数字组合计算，得到了另一组 4 个子问题：

![QQ截图20190602234202](.\QQ截图20190602234202.png)

根据组合规则，从 4 个数字中选两个进行不能有重复的排列，可以得到 P_{4}^{2} = 12 个组合结果，也就是说总共有 12 × 4 = 48 个规模为 3 个数字的子问题，图（1）展示了其中的两组。

接下来，我们选择图（1）中紫色标识的那个子问题，再进一步应用上述思想减小问题的规模。

从 3 个数字中任选两个，然后应用加、减、乘、除四种运算方法得到 4 个计算结果，每个计算结果与剩下的 1 个数字组成一个规模为两个数字的子问题，又可以得到 4 个子问题。

从 3 个数字中任选两个进行不重复的排列，可以得到 P_{3}^{2} =6 个组合结果，也就是说总共有 6 × 4 = 24 个规模为两个数字的子问题，图（2）展示了其中一组，也就是第一个数 3/7 和第二个数 3 的组合情况：

![QQ截图20190602234530](.\QQ截图20190602234530.png)

3/7 和 3 经过加、减、乘、除得到了 4 个结果，分别是 24/7、−18/7、9/7 和 1/7，将它们与剩下的数字 7 组合，得到了图（2）所示的 4 个子问题。

接下来，我们选择图（2）中黄色标识的子问题，再进一步应用上述思想减小问题的规模。

从两个数字中任选两个，然后应用加、减、乘、除四种运算方法得到 4 个计算结果，得到 4 个规模是 1 个数字的子问题，如图（3）所示：

![QQ截图20190602234623](.\QQ截图20190602234623.png)

从两个数字中任选两个进行无重复的排列，可以得到 P_{2}^{2} =2 个组合结果，也就是说总共有 2 × 4 = 8 个规模为 1 个数字的子问题，图（3）展示了其中一组，即 24/7 与 7 分别进行加、减、乘、除计算。

此时问题的规模已经减小到可以直接得到结果的程度了，淡灰色标识的那个子问题结果是 24，就是我们要求解的结果。当然，从其他分支也能得到正确的结果，从图（1）到图（3）只展示了其中一个结果的生成过程。

以上就是我们介绍的穷举法 + 分治法解决 24 点计算问题的算法分析过程。

前面提到过，这个问题的难点有两个，上述分析过程解决了第一个，即数字和运算符的穷举遍历问题。

还有第二个问题，也就是将四则运算表达式作为结果输出的问题没有解决。

可能大家已经从几个图上看到了，图的第三行就是最后要输出的中缀表达式，这是怎么做到的呢？其实很简单，我们给每个数字都指定了一个“出身”，所谓的“出身”就是描述这个数字的来历，或者是计算过程。

每个数字的“出身”记录了这个数字的计算过程，当数字被带入到子问题的时候，这个计算过程也跟着被带入到子问题，并随着子问题的求解过程一步一步带到最后。

对于原问题来说，4 个数字的出身就是数字本身，当两个数字参与一次计算称为一个结果数字时，就将这两个数字的计算过程作为结果数字的“出身”。

为了简化算法实现，避免处理运算符的优先级，我们对每个运算过程都用了括号。

好了，根据上面的分析，我们已经明确了问题和子问题的定义，就是“用 m 个数排列组合计算 24 点（1⩽m⩽4）”。

所以我们的子问题的参数就是 m 个数，考虑用数组来组织这 m 个数。每个数除了数字本身，还有一个出身，用以下数据结构来描述这个“数”：

```c++
typedef struct
{
    double num;
    std::string num_str;
}Number;
```

num_str 是这个数的“出身”，用字符串描述没问题，num 是数字本身，但是数据类型用了 double，这也是实际计算过程的需要，毕竟从上图中也能看到，我们的计算方法是支持分数形式的，中间计算过程会出现浮点数，最终子问题定义就是 Calc24() 函数的参数：

```c++
void Calc24(const std::vector<Number>& nums)
{
    //求解子问题
}

//原始问题的定义
std::vector<Number> numbers = { { 3, "3" },{ 3, "3" },{ 7, "7" },{ 7, "7" } };
Calc24(numbers);
```

随着子问题规模的减小，nums 数组的长度由 4 减小到 3，再减小到 2，直至减到 1，numbers 就是子问题的初始状态，也就是原始问题。

考虑到一些读者不熟悉 C++，介绍一下上面的数组定义。首先 std::vector<…> 定义了一个向量 vector，vector 的行为实际上就是数组，其内存结构是连续的，并且提供下标运算符 []，可以像访问原生数组一样使用 vector（当然，也可以使用迭代器）。

`std::vector<Number>` 表示数组的每个元素是 Number 类型。Number 是个数据结构定义，它有两个成员，分别是 num 和 num_s。

#### 算法实现

算法实现要解决的问题是将上述分析过程落地实现，完成 Calc24() 函数。

本课程基础部分介绍分治法的时候，我提到过“递归作为一种算法的实现方式，与分治法是一对儿天然的好朋友”，这个问题我们也决定使用递归方式实现 Calc24() 函数。

这意味着 Calc24() 函数要在内部构造子问题的`std::vector<Number>`数组，并将其作为递归调用 Calc24() 函数时的参数，从而实现对子问题的求解。

Calc24() 函数对子问题进行处理的时候，要对子问题规模是 1 个数的情况做处理，这实际上也是递归函数的退出（递归终止）条件。

对于这个问题来说，当子问题的规模是 1 个数的时候，就要检查这个数是否是 24，如果是则输出一组结果，并退出递归处理；如果不是，说明这个穷举出来的结果是个无效结果，直接退出递归处理。这部分判断和处理的实现在第 4 行开始的 if (count == 1) 处理流程里，比较简单，就不多说了。对于子问题规模大于 1 的情况，就要选两个数进行计算，对于 P_{n}^{2} 问题，常用的代码实现模式就是两重循环。

下一课我会介绍另一种常见的方法，但是那种方法不适合用递归的方式处理不同规模的子问题，所以 Calc24() 函数使用两重循环实现对 P_{n}^{2}的处理。

代码的第 14 行和第 16 行的两个 for 循环就是处理 P_{n}^{2}的排列，因为不能有重复，所以当 (i == j) 的时候，要排除掉这种情况，就是 18 和 19 两行代码做的事情。

第 21 行的 for 循环是对加、减、乘、除四种运算的枚举，也就是将前面两重 for 循环选出来的两个数进行四种运算，得到四个结果。acops 是个函数数组，每一个 op 是一种运算方式，负责将 nums[i]、nums[j] 进行计算，并将结果存入到 new_num 中。

第 27 行定义的`sub_nums`数组是子问题的描述，首先将前面计算的`new_num`加入到`sub_nums`数组中，然后将 nums 数组中没有被选中的数字也加入到`sub_nums`数组中，组成新的子问题。

第 30 行的 for 循环就是将 nums 数组中没被选中的数加入到`sub_nums`数组中。子问题`sub_nums`数组准备好以后，

在第 37 行递归调用`Calc24(sub_nums)`求解子问题。

对于第 30 行的 for 循环来说，当 nums 的规模是 4 个数的时候，这个 for 循环排除掉已经选中的 i 和 j 后，将剩下的两个数加入到`sub_nums`数组中，形成 3 个数的子问题。

当 nums 的规模是 3 个数的时候，这个 for 循环将剩下的 1 个数加入到`sub_nums`数组中，形成两个数的子问题。

当 nums 的规模是两个数的时候，这个 for 循环实际上空转了两次排除掉已经选中的 i 和 j ，没有任何数被加入到`sub_nums`数组中，最后得到只有 1 个数的子问题。用递归方式求解子问题，最难的部分是如何用一致的代码处理不同规模和属性范围的子问题。

前面的两重 for 循环和对`sub_nums`数组的处理，都体现了这种思想。