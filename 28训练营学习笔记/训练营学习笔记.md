## 训练营学习笔记



通过算法提升自己的能力—解决问题的能力，逻辑思维能力

对未知问题的分析和建模能力

### 自测

图有哪两种常见的建模方法？

邻接矩阵和邻接表

“动态规划”性质？

无后向性



### 算法是程序的灵魂

将文字描述的问题抽象成算法能够使用的数据模型。

掌握设计算法的方法和一些常用技巧。



### 1-1 如何“玩”算法

**玩算法要做到以下几点：**

1、对遇到的特殊问题要能够自己设计出算法实现（可能是一个智力游戏题目，也可能是工作中遇到的实际问题）

2、对于原理公开的知名算法，要能将算法原理翻译成具体的算法代码（如二部图匹配的匈牙利算法）

3、对已有具体实现的算法，要能够设计出合适的数学模型，将算法应用到实际问题中（如遗传算法）

**完整的算法应该包含三个重要的组成部分：**

1、数据模型—最终过渡到用计算机语言的数据结构能够描述问题为止

2、算法逻辑主体

3、输入输出

输入就是把自然语言描述的问题转化为计算机存储或处理的数据，并存入数据模型中

输出就是将计算机处理后的结果（也在数据模型中定义）转化成人类能理解的方式输出

算法的逻辑主体就是具体承载数据处理的代码流程，负责对数据模型中的输入数据进行处理、转换，并得到结果。

这三个组成的核心是数据模型，好的数据模型不仅能准确地描述问题，还能简化算法实现或提高算法的效率。

**根据问题的描述简历数据模型的能力就是玩算法关键，不能对问题进行归纳并抽象出数据模型的，就不能设计出解决问题的算法实现，换句话说，就是缺乏解决实际问题的能力**

##### 建立数学模型的一些惯用做法

把问题抽象成数据模型

**1、信息数字化**

信息数字化就是把自然语言描述的信息，转化成方便代码数据模型表达的数字化信息，这是各种问题模型的一个通用思考方向。

比如：

当问题中出现当问题中出现用“甲、乙、丙、丁”或“A、B、C、D”来标识物品或人物的序列时，就可以考虑用数字 1、2、3、4 来表达它们；

判断结果“大于、等于和小于”，可以用正数、0和负数来表示；

布尔值的真假可以用1和0表示，有和无也可以；

例子：

```c++
/*
警察抓了A、B、C、D四名罪犯，其中一名是小偷，审讯的时候：
A说：“我不是小偷。— x!=0
B说：“C是小偷”。 — x=2
C说：“小偷肯定是D。" — x=3
D说：“C 是在冤枉人。" — x!=3
现在知道四个人中三个人说了真话，一个人说了假话，请判断谁是小偷
*/

// 对于这个问题，首先对A、B、C、D四个人用0—3编号，姐姐将四个人的描述结果用数字量化，如果描述为真，则结果是1，描述为假，结果是0.假设小偷的编号是x，对于四个人的描述，数字化结果是：

int dis_a = (x!=0)? 1:0;
int dis_b = (x == 2)? 1:0;
int dis_c = (x == 3)? 1:0;
int dis_d = 1-dis_c;

// 通过以上量化，则有结果
void who_is_thief()
{
    for (int x = 0; x < 4; x++)
    {
        int dis_a = (x != 0) ? 1 : 0;
        int dis_b = (x == 2) ? 1 : 0;
        int dis_c = (x == 3) ? 1 : 0;
        int dis_d = 1 - dis_c;

        if ((dis_a + dis_b + dis_c + dis_d) == 3)
        {
            char thief = 'A' + x;
            std::cout << "The thief is " << thief << std::endl;
            break;
        }
    }
}
```

**信息数字化是建立数学模型的基础，数字化后的数据和数据模型是相辅相成的两个东西，先要知道有什么数据，才能设计响应的数据模型存储和表达这些数据，而好的数据模型不仅有利于数据的存储和访问，也有利于算法的高效实现**

**2、类比和转化**

使用一个我们熟知的模型来解决未知的问题，很重要。

比如：

```其他
判断n个矩形之间是否存在包含关系是经典的算法几何问题。按照一般的思路，应该是n个矩形两两进行包含判断，但是很显然，这个简单的方法需要n（n-1)次矩形包含判断，时间复杂度是O(n^2).
但是如果知道区间树的概念，就可以将这个问题转化为区间树的查询问题。
1、首先根据矩形的几何位置，利用水平边和垂直边分别构造两颗区间树（根据矩形的几何特征，只需要处理一条水平边和一条垂直边即可）
2、然后将n个矩形的水平边作为被查找元素，依次在水平边区间树中查找，如果找到其他矩形的水平边完整覆盖被查找矩形的水平边，则在垂直边区间树上进一步判断该矩形的垂直边被覆盖的情况。
3、如果存在被查找矩形的水平边和垂直边都被同一个矩形的水平边和垂直边覆盖，则说明这两个矩形存在包含关系。
采用区间树的算法复杂度是 O(nlg(n))，额外的开销是建立区间树的开销，但是只要 n 足够大，这个算法仍然比简单的比较法高效。
```

再比如一个项目管理的例子：

```其他
一个工程项目经过层层结构分解最终得到一系列具体的活动，这些活动之间往往存在复杂的依赖关系，如何安排这些活动的开始顺序，使得项目能够顺利完成是个艰巨的任务。
但是如果能把这个问题转化成有向图，图的顶点就是活动，顶点之间的有向边代表活动之间的前后关系，则只需要使用简单的有向图拓扑排序算法就可以解决这个问题。
一个工程分解出的这么多活动，每个活动的时间都不一样，如何确定工程的最短完工时间？
工程的最短完工时间取决于这些活动中时间最长的那条关键活动路径，从成千上百个活动中找出关键路径看似是个无法下手的问题，但是如果将问题转化为有向图，顶点表示事件，边表示活动，边的权代表活动时间，则可以利用有向图的关键路径算法解决问题。
```



**3、数学问题的建模**

计算几何的问题范围都是整个坐标系，比如直线是向两端无限延伸的，但是对于计算机来说，即便有大数计算库的支持，它能表达的最大范围也是有限的。通常会根据实际应用场景裁剪规模，以便于计算机算法的建模和处理。比如某绘图仪的最大坐标范围是 [−32768,32768]，那就可以定义一个比 −32768 还小的数作为负无穷大，定义一个比 32768 还大的数作为正无穷大，这样直线就可以作为一个两端超过区间 [−32768,32768] 的大线段来建模，对于坐标范围是 [−32768,32768] 来说，模型符合直线的特征，对于计算机来说，这是一条数据模型能表达和存储的线段。

对于涉及数学公式的建模，相对比较简单，只要定义的数据结构能表达公式描述的各项属性即可。

**需要注意的是，很多公式是隐含着无穷数列的特征的，在建模时需要增加约束条件，使得问题能在某个范围内用算法解决。**

例如：n次二项式的展开式的系数问题

![二项式](.\二项式.png)

多项式项数与n相关（n+1)

受制于空间的限制，考虑数据模型的时候需要限制n的最大值

观察每个展开项可知，需要存储的数据有多项式系数、a的幂和b的幂三个属性，因此定义的数据结构要有相对应的条目这些属性，可以定义每一项的数据结构：

```c++
typedef struct
{
    int c;// 系数
    int am; // a幂
    int bm;
}ITEM
```

需要一个列表来存储各项的数据，显然列表不存在频繁删除和插入操作，可以选择用数据作为数据模型。限制n最大为32.

最终定义的数据模型为：

```C++
ITEM items[N]; // N<32;
```

![杨辉三角](D:\usegit\github\algorithmcompetition\28训练营学习笔记\杨辉三角.png)

根据定义的数据类型items，求二项式展开式各项系数和幂的算法实现也水到聚成了：

```C++
if(n == 0)
{
    items[0] = {1,0,0}; // 初始化结构体
    return;
}

// 从第一阶开始递推到第n阶
for(unsigned int i = 1; i <= n;i++)
{
    unsigned int nc = i+1;// 每一阶的项数
    items[nc-1] = {1,0,i}; // 末项
    
    // 倒着递推第二项到第n-1项的值，实际下标范围是[1,nc-2],不需要额外的存储空间转存
    for(unsigned int j = nc-2;j>0;j--)
    {
        unsigned int c = items[j].c + tems[j-1].c;
        item[j] = {c,i-j,j};
    }
    items[0] = {1,i,0} // 首项
}
```

计算机也无法直接表示大小和不等于这样的关系，对于不等式的建模，通常是转换成减法，然后对结果进行正、负的判断。对于方程也是一样的，通常将方程转换成 f(x)=0 的形式建模，模型会比较简单。



**4、图论算法的建模**

图论相关的算法也是非常典型的一类问题。描述图的数据结构最常用的是邻接矩阵和邻接链表两种形式.

邻接矩阵一般由一个一维的顶点信息表和一个二维的邻接关系表组成，根据实际问题的情况，还可以增加其他属性，如顶点个数和边的个数等。

一个典型的邻接矩阵数据模型的定义：

```C++
typedef struct
{
    int vertex[MAX_VERTEX];// 顶点信息表
    int edge[MAX_VERTEX][MAX_VERTEX]; // 边信息表
    int numV; // 顶点数
    int numE; // 边数
}GRAPH；
```

如果你使用的编程语言中数组的属性中包含元素个数，那么表示顶点数的 numV 属性就没有必要，同样，表示边数的 numE 属性也不是必需的。

如果问题中关于顶点信息除了编号，还有其他信息，那么顶点信息表的元素类型就不能简单用 int 类型了，而是要根据题目给出的信息做相适应的修改。

比如与地图有关的问题，通常作为顶点的每个城市有很多属性，如城市名称、公路出口个数和入口个数等，就需要定义相关的顶点数据结构

比如包含了城市名称的顶点信息：

```c++
typedef struct
{
    std::string name;
    int node;
}VERTEX

VERTEX vertex[MAX_VERTEX];  //顶点信息表
```

表示边信息的矩阵，每个元素是边的权重，对于不相邻的顶点，权重一般是一个特殊值。

如果边的信息除了权重，若还有其他信息，则需要定义与之相适应的数据结构来描述边的信息。

比如有个求最优解的规划类题目，城市之间除了距离，还有交通困难指数，比如是水路、山路还是平地等信息，

此时边的定义就可以改成如下代码：

```C++
typedef struct
{
    int weight;
    int traffic_type;
}EDGE

EDGE edge[MAX_VERTEX][MAX_VERTEX]; //边信息表
```

使用邻接矩阵定义图，优点是顶点之间的边的信息很容易获取，如果你要处理的问题需要频繁地确定顶点之间的连接信息，那么使用邻接矩阵是一个比较好的选择。

邻接矩阵的缺点是它是一个稀疏矩阵，当顶点比较多的情况下，对存储空间的浪费比较严重。

邻接表是一种顺序分配和链式分配相结合的数据结构，顶点信息顺序存放，每个顶点相邻的顶点信息，则通过一个链表链接到该顶点的邻接点域。一个典型的邻接表数据模型如下：

```c++
typedef struct EDGE
{
    int node;  //边的对应顶点
    int weight;
    EDGE *nextEdge;  //下一条边的信息
}EDGE;

typedef struct
{
    int node;
    EDGE *firstEdge; //第一个边的信息
}VERTEX;

typedef struct 
{
    VERTEX vertex[MAX_VERTEX]; //顶点列表
    int numV; //顶点数
    int numE; //边数
}GRAPH;
```

### 1-2 算法设计常用思想之贪婪法

模式作为算法演进的一些固定的思路，它提供了一些构造算法的常用思想。常用的算法设计思想有迭代法、贪婪法、穷举搜索法、递推法、递归法、回溯法、分治法、动态规划法等，这一课将介绍贪婪法。

#### 基本思想

贪婪法（Greedy Algorithm），又称贪心算法。

这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好的或最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果也是最好或最优的解。

贪婪法的每次决策都以当前情况为基础并根据某个最优原则进行选择，**不从整体上考虑其他各种可能的情况**。

一般来说，这种贪心原则在各种算法模式中都会体现，这里单独作为一种方法来说明，是因为贪婪法对于特定的问题是非常有效的方法。

贪婪法和动态规划法以及分治法一样，都需要对问题进行分解，定义最优解的子结构。

但是与其他方法最大的不同在于，**贪婪法每一步选择完局部最优解之后就确定了，不再进行回溯处理**，也就是说，每一个步骤的局部最优解确定以后，就不再修改，直到算法结束。

因为不进行回溯处理，贪婪法只在很少的情况下可以得到真正的最优解，比如**最短路径问题、图的最小生成树问题**。在大多数情况下，由于选择策略的“短视”，贪婪法会错过真正的最优解，而得不到问题的真正答案。但是贪婪法简单、高效，省去了为找最优解可能需要的穷举操作，**可以得到与最优解比较接近的近似最优解**，通常作为其他算法的辅助算法来使用。

#### 步骤

- 建立对问题精确描述的数学模型，包括定义最优解的模型；
- 将问题分解为一系列的子问题，同时定义子问题的最优解结构；
- 应用贪心原则确定每个子问题的局部最优解，并根据最优解的模型，用子问题的局部最优解堆叠出全局最优解。

定义最优解的模型通常和定义子问题的最优结构是**同时进行的**

最优解的模型一般都体现了最优子问题的分解结构和堆叠方式。

对于子问题的分解有多种方式，有的问题可以按照问题的求解过程一步一步进行分解，每一步都在前一步的基础上选择当前最好的解，每做一次选择就将问题简化为一个规模更小的子问题，当最后一步的求解完成后就得到了全局最优解。还有的问题可以将问题分解成相对独立的几个子问题，对每个子问题求解完成后再按照一定的规则（比如某种公式或计算法则）将其组合起来得到全局最优解。

例如：

```c++
/*
找零钱问题；
某国发行的货币有 25 分、10 分、5 分和 1 分四种硬币，如果你是售货员且要找给客户 41 分钱的硬币，如何安排才能找给客人的钱既正确且硬币的个数又最少？
这个问题的子问题定义就是从四种币值的硬币中选择一枚，使这个硬币的币值和其他已经选择的硬币的币值总和不超过 41 分钱。子
问题的最优解结构就是在之前的步骤已经选择的硬币再加上当前选择的一枚硬币。
当然，选择的策略是贪婪策略，即在币值总和不超过 41 的前提下选择币值最大的那种硬币。按照这个策略，第一步会选择 25 分的硬币一枚，第二步会选择 10 分的硬币一枚，第三步会选择 5 分的硬币一枚，第四步会选择 1 分的硬币一枚，总共需要 4 枚硬币。
*/

/*
上面的例子得到的确实是一个最优解，但是很多情况下贪婪法都不能得到最优解。同样以找零钱为例，假如，某国货币发行为 25 分、20 分、5 分和 1 分四种硬币，这时候找 41 分钱的最优策略是 2 枚 20 分的硬币加上 1 枚 1 分硬币，一共 3 枚硬币，但是用贪婪法得到的结果却是 1 枚 25 分硬币、3 枚 5 分硬币和 1 枚 1 分硬币，一共 5 枚硬币。
*/
```

#### 贪婪法例子：0-1背包问题

问题描述：

有 N 件物品和一个承重为 C 的背包（也可定义为体积），每件物品的重量是 wi，价值是 pi，求解将哪几件物品装入背包可使这些物品在重量总和不超过 C 的情况下价值总和最大？

背包问题（Knapsack Problem）是此类组合优化的 NP 完全问题的统称，如货箱装载问题、货船载物问题等，因问题最初来源于如何选择最合适的物品装在背包中而得名，这个问题隐含了一个条件，每个物品只有一件，也就是限定每件物品只能选择 0 个或 1 个，因此又被称为 0-1 背包问题。

具体的例子：

```c++
/*
有一个背包，最多能承载重量为 C=150 的物品，现在有 7 个物品（物品不能分割成任意大小），编号为 1~7，重量分别是 wi=[35,30,60,50,40,10,25]，价值分别是 pi=[10,40,30,50,35,40,30]，现在从这 7 个物品中选择一个或多个装入背包，要求在物品总重量不超过 C 的前提下，所装入的物品总价值最高。
分析：
这个问题的数学模型非常简单，就是一个承重是 C 的背包和 n 个物品，每个物品都有重量和价值两个属性。
但是在对问题分析的过程中，我们发现，每个物品还需要一个状态用于标记该物品的选择状态，以确定该物品是否已经被选进背包了，状态是 1 表示物品已经被装到包里了，后续的选择不要再考虑这个物品了。需要特别说明的是状态值为 2 的情况，这种情况表示用当前策略选择的物品导致总重量超过了背包承重量，在这种情况下，如果放弃这个物品，按照策略从剩下的物品中再选一个，有可能就能满足背包承重的要求。因此，设置了一个状态 2，表示当前选择物品不合适，下次选择也不要再选这个物品了。
*/

// 描述每个物品的数据结构 OBJECT 定义为：
typedef struct
{
    int weight;
    int price;
    int status; // 0-未选中，1—已选中；2—已经不可选
}OBJECT;

// 背包问题的定义，背包问题包括两个属性，一个是可选物品列表，另一个是背包总的称重量
// 简单定义背包问题数据结构如下：
typedef struct
{
    std::vector<OBJECT> objs;
    int totalC;
}KNAPSACK_PROBLEM;

// 这就是该问题的数学模型！！！
```

确定数学模型之后，接下来就要确定子问题了。

根据题意，本题的子问题可以描述为：

在背包承重还有 C’ 的情况下，选择一个还没有被选择过，且符合贪婪策略的物品装入背包。每选择一个物品 p[i]，都要调整背包的承重量 C’=C’-p[i].weight，问题的初始状态是 C’=150，且所有物品都可以选择。

假如选择了一个重为 35 的物品后，子问题就变成在背包容量 C’ 是 115 的情况下，从剩下 6 件物品中选择一个物品。

确定了子问题的描述，算法的整体实现过程就是按照选择物品装入背包的过程，按部就班地一步一步解决子问题，直到背包不能再装入物品或所有物品都已经装入背包时，结束算法。

**那么如何选择物品呢？这就是贪婪策略的选择问题。**

对于本题，常见的贪婪策略有三种：

第一种策略是根据物品价值选择，每次都选价值最高的物品，根据这个策略最终选择装入背包的物品编号依次是 4、2、6、5，此时包中物品总重量是 130，总价值是 165。

第二种策略是根据物品重量选择，每次都选择重量最轻的物品，根据这个策略最终选择装入背包的物品编号依次是 6、7、2、1、5，此时包中物品总重量是 140，总价值是 155。

第三种策略是定义一个价值密度的概念，每次选择都选价值密度最高的物品，物品的价值密度 si 定义为 pi/wi，这 7 件物品的价值密度分别为 si=[0.286,1.333,0.5,1.0,0.875,4.0,1.2]。根据这个策略最终选择装入背包的物品编号依次是 6、2、7、4、1，此时包中物品的总重量是 150，总价值是 170。

**算法实现**

```c++
/*
GreedyAlgo() 函数是贪婪算法的主体结构，包括子问题的分解和选择策略的选择都在这个函数中。
能够明显看出来这个算法使用了迭代法的算法模式，当然，这个算法主体的实现还可以使用递归法，正如函数所展示的那样，它可以作为此类问题的一个通用解决思路：
*/
void GreedyAlgo(KBAPSACK_PROBLEM *problem,SELECT_POLICY spFunc)
{
    int idx;
    int ntc = 0;
    
    //spFunc 每次选择最符合策略的那个物品，选后再检查
    while((idx = spFunc(probelm->objs,proble->totalC-ntc)) != -1)
    {
        // 所选物品是否都满足背包称重要求?
        if((ntc + problem->obj[idx].weight) <= problem->totalC)
        {
            problem->objs[idx].status = 1;
            ntc += problem->objs[idx].weight;
		}
        else
        {
            // 不能选这个物品了，做个标记重新选
            problem->objs[idx].status = 2;
        }
	}
    
    PrintResult(problem->objs);
}

/*
spFunc 参数是选择策略函数的接口，通过替换这个参数，可以实现上文提到的三种贪婪策略，分别得到各种贪婪策略下得到的解。以第一种策略为例，每次总是选择 price 最大的物品，可以这样实现：
*/
int Choosefunc1(std::vector<OBJECT>& objs,int c)
{
    int index = -1;// -1表示背包容量已满
    int mp = 0;
    for(int i = 0; i<static_cast<int>(objs.size());i++)
    {
        if((objs[i].status == 0) && (objs[i].price > mp))
        {
            mp = objs[i].price;
            index = i;
		}
    }
    
    return index;
}
```

看起来第三种策略取得了最好的结果，和动态规划方法得到的最优结果是一致的.

但是实际上，这只是对**这组数据的验证结果**而已，如果换一组数据，结果可能完全相反。当然，对于一些能够证明贪婪策略得到的就是最优解的问题，应用贪婪法可以高效地求得结果，比如**求最小生成树的 Prim 算法和 Kruskal 算法**。

在大多数情况下，贪婪法受自身策略模式的限制，通常很难直接求解全局最优解问题，也很难用于多阶段决策问题。贪婪法只能得到比较接近最优解的近似最优解，但是作为一种启发式辅助方法在很多算法中都得到了广泛的应用，很多常用的算法在解决局部最优决策时，都会应用到贪婪法。比如 Dijkstra 的单源最短路径算法在从 dist 中选择当前最短距离的节点时，就是采用的贪婪法策略。事实上，在任何算法中，只要在某个阶段使用了只考虑局部最优情况的选择策略，都可以理解为使用了贪婪算法。

### 1-3 算法设计常用思想之分治法

